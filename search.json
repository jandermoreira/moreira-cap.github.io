[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Construção de Algoritmos e Programação",
    "section": "",
    "text": "Apresentação\nEste sítio é a versão online do livro “Construção de Algoritmos e Programação: Programação em C”.\nA disciplina de graduação Construção de Algoritmos e Programação, que é ofertada regularmente pelo Departamento de Computação para os cursos de Bacharelado em Ciência da Computação e Bacharelado em Engenharia da Computação da Universidade Federal de São Carlos, motivou a escrita deste livro, pensando em uma abordagem distinta da usualmente feita em cursos básicos de programação.",
    "crumbs": [
      "Apresentação"
    ]
  },
  {
    "objectID": "index.html#a-versão",
    "href": "index.html#a-versão",
    "title": "Construção de Algoritmos e Programação",
    "section": "A versão Programação em C",
    "text": "A versão Programação em C\nA linguagem C é uma linguagem básica, na qual a proximidade do código com as representações internas da memória é uma característica importante. Outras linguagens possuem nível de abstração mais alto, ocultando muitos detalhes do programador, como é o caso de Python e R, por exemplo.\nNa experiência do autor, dominar minimamente uma linguagem de programação de nível de abstração mais baixo auxilia qualquer programador a entender muitos dos aspectos, sejam vantagens ou ciladas, existentes em qualquer outra linguagem procedural ou mesmo orientada a objetos. Isso torna aprender C uma experiência efetivamente enriquecedora.\nAs questões mais básicas da linguagem C são o assunto deste texto, fornecendo uma visão geral da codificação e de elementos de memória e representação que compõem um conhecimento precioso para quem desenvolve programas.",
    "crumbs": [
      "Apresentação"
    ]
  },
  {
    "objectID": "index.html#disponibilidade-online",
    "href": "index.html#disponibilidade-online",
    "title": "Construção de Algoritmos e Programação",
    "section": "Disponibilidade online",
    "text": "Disponibilidade online\n\n\nAlgoritmos para quem já sabe programar: https://jandermoreira.github.io/cap-algoritmos\nProgramação em C : https://jandermoreira.github.io/cap-linguagem-c\nPrática com algoritmos: https://jandermoreira.github.io/cap-pratica-algoritmos",
    "crumbs": [
      "Apresentação"
    ]
  },
  {
    "objectID": "preambulo_prefacio.html",
    "href": "preambulo_prefacio.html",
    "title": "Programação em C",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nExiste uma infinidade de linguagens de programação. Algumas são mais fáceis, outras mais complexas, umas mais abstratas, outras muito concretas. A linguagem C se encontra entre as linguagens mais básicas, ou seja, mais próximas ao hardware. Faz parte do grupo conhecido como linguagem de nível baixo.\nC abstrai o conceito do processador: o código fonte é escrito de forma a ser independente de qual processador é usado e de qual sistema operacional está instalado. Por outro lado, a abstração em relação à memória é pequena. Em programas mais simples é possível ignorar completamente como a memória é usada para armazenar os dados; porém basta um pequeno aumento na complexidade do problema (e também de sua solução) que questões como quantidade de bytes disponíveis, localização dos dados na memória ou outros aspectos emergem e têm que ser trabalhadas pelo programador.\nEsse aspecto da linguagem que exige um conhecimento mais concreto de como a memória é usada e como as instruções devem ser organizadas gera, por uma lado, um ambiente desafiador e até um pouco intimidador, mas, de outro ponto de vista, traz um conhecimento mais sedimentado da programação, o que é algo bastante enriquecedor.\nO conteúdo da linguagem C oferecido neste livro não é maior do que muitos outros encontrados por uma simples busca em qualquer ferramenta de busca disponível. O que talvez torne este material diferenciado é a abordagem, a qual visa proporcionar um bom domínio dos principais elementos de forma crescente. O enfoque é a apresentação dos conceitos de forma simples (tanto quanto possível), consolidando-os antes de progredir para a próxima etapa.",
    "crumbs": [
      "{{< meta book.subtitle >}}"
    ]
  },
  {
    "objectID": "algoritmos-nocoes.html",
    "href": "algoritmos-nocoes.html",
    "title": "1  Noções de algoritmos",
    "section": "",
    "text": "1.1 Características gerais dos algoritmos\nUm algoritmo é uma descrição de passos que, se seguidos, levam à solução de um determinado problema e, genericamente falando, quaisquer instruções, orientações ou coisa similar podem ser classificadas como um algoritmo.\nA partir dessa óptica, há uma infinidade de algoritmos. Quando se trata de computação e mais especificamente de programação, há um subconjunto dos algoritmos com características mais particulares. Este capítulo trata da contextualização dos algoritmos computacionais.\nPor exemplo, as instruções de como higienizar uma máquina de lavar roupas são um algoritmo. Esse algoritmo parte do pressuposto de uma máquina de lavar para ser higienizada, descreve os passos para serem seguidos (deixar o cesto vazio, acrescentar a água sanitária, deixar em um ciclo específico por um determinado tempo) e atinge o resultado desejado, que é a máquina limpa.\nA montagem de uma estante comprada online também segue o algoritmo estabelecido no manual de montagem, tendo como objetivo partir de um conjunto de peças separadas e obter a estante montada e funcional. Os passos passam pela verificação da disponibilidade de todas as peças e ferramentas necessárias, montagem organizada das diversas partes e devidas finalizações.\nUm último (e clássico) exemplo é uma receita culinária, a qual parte dos ingredientes constituintes e chega a um bolo, um assado ou outro prato qualquer.\nTodos esses algoritmos possuem três elementos principais:\nA situação inicial são as pré-condições, ou seja, o que tem haver antes da execução dos passos para que todas as ações possam ser seguidas de forma adequada. Os passos determinam as ações que devem ser executadas e uma ordem coerente para que aconteçam. As pós-condições caracterizam a situação final, ou seja, a completude do que o algoritmo se propôs a resolver.\nNa Tabela 1.1 são apresentados esses elementos para dois exemplos específicos, ilustrando-os de forma simplificada.\nEsta definição não se aplica, em particular, à receita do pão indicada na Tabela 1.1. O resultado tende a variar consideravelmente dependendo de uma variedade de situações não mencionadas, como o tipo e a qualidade da farinha, a temperatura ambiente que influencia no crescimento da massa e o forno usado, que pode aquecer mais ou menos que outro forno, por exemplo. Para se garantir um resultado sempre “igual”, todas essas variáveis deveriam entrar nas pré-condições. Felizmente, essas variações são toleradas no resultado final da receita, sendo até esperadas tais diferenças. As pré-condições e pós-condições podem, dependendo do caso, ter graus de especificidade variados.\nEssa variação de resultados, porém, não é tolerada na atualização do saldo bancário. Dado o mesmo saldo inicial e as mesmas movimentações, o resultado não pode ser diferente sob nenhuma hipótese. Tem que haver uma previsibilidade do resultado. Neste caso, pré e pós-condições são bastante determinísticas.\nOs algoritmos com resultados e passos mais maleáveis, que toleram certas variações no resultado final, enquadram-se como algoritmos gerais. Entre eles estão as receitas, instruções de montagem de móveis, orientações para se chegar a um destino com GPS ou instruções de como inserir um novo contato na agenda do telefone. Em todos eles, até a vivência e experiências pessoais de quem os executa podem ter influência no resultado. Há pessoas com ótima mão para fazer bolos, por exemplo.\nSe for pedido a um humano que converta 95 Fahrenheit para graus Celsius, ele pode usar seu smartphone para abrir uma ferramenta de busca, digitar “quanto é 95 farenheit em celsius” (sim, com o erro de digitação) e obter a resposta de 35oC. Ele poderia estar sem bateria e optado por usar um computador para fazer a busca; poderia também ter escolhido uma ferramenta de busca no lugar de outra; poderia até ter digitado o texto da consulta de diversas outras maneiras distintas. Esse humano poderia também ter boa memória e se lembrar da fórmula, além de ter facilidade para fazer contas de cabeça e dar o resultado sem nenhum outro recurso a não ser ele mesmo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Noções de algoritmos</span>"
    ]
  },
  {
    "objectID": "algoritmos-nocoes.html#características-gerais-dos-algoritmos",
    "href": "algoritmos-nocoes.html#características-gerais-dos-algoritmos",
    "title": "1  Noções de algoritmos",
    "section": "",
    "text": "A situação inicial;\nA sequência de passos que devem ser seguidos;\nA situação final.\n\n\n\n\n\n\nTabela 1.1: Exemplos ilustrando os elementos (pré-condições, passos, pós-condições) para dois problemas específicos.\n\n\n\n\n\n\n\n\n\n\n\nCocção de um pão\nAtualização de um saldo bancário\n\n\n\n\nPré-condições\nDisponibilidade dos ingredientes e utensílios necessários\nO saldo anterior e todas as movimentações no período\n\n\nPassos\nPreparação da massa, descanso, crescimento, forno\nAtualização do saldo passando-se por cada movimentação individual\n\n\nPós-condições\nPão\nO saldo atualizado\n\n\n\n\n\n\n\n\n\n\n\n\nAlgoritmo\n\n\n\n Um algoritmo pode ser definido como uma sequência finita de passos que levam de uma situação inicial (pré-condições) a uma situação final (pós-condições) de forma bem definida. A partir desse conceito, é esperado que, a partir do mesmo estado inicial e seguidos os mesmos passos, o estado final seja atingido.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Noções de algoritmos</span>"
    ]
  },
  {
    "objectID": "algoritmos-nocoes.html#algoritmos-computacionais",
    "href": "algoritmos-nocoes.html#algoritmos-computacionais",
    "title": "1  Noções de algoritmos",
    "section": "1.2 Algoritmos computacionais",
    "text": "1.2 Algoritmos computacionais\nExiste uma classe particular de algoritmos para os quais há um maior rigor nos mais diversos aspectos e eles não podem depender da experiência ou interpretação de que os executa. Esses são os algoritmos escritos para serem executados, em última instância, por um sistema computacional (processador e memória eletrônicos) e, para tanto, têm que ser extremamente claros e precisos em cada instrução a ser executada, bem como possuem pré-condições e pós-condições bastantes específicas.\nCaso um sistema computacional, ou seja, um programa, deva realizar a mesma tarefa, ele tem que ter bem definidas todas as etapas. As pré-condições, por exemplo, definiriam que o valor deveria ser um número real, os passos indicariam o cálculo da conversão e qual seria a expressão usada e, finalmente, o resultado produzido como pós-condição estaria bem definido.\n\n\n\n\n\n\nAlgoritmos computacionais\n\n\n\n Um algoritmo computacional é aquele que define com clareza todas pré-condições e estabelece também claramente as pós-condições. Também define os passos de forma inequívoca e direta, sem margens para interpretações ou variações. Seu objetivo é ser executado em um sistema computacional.\n\n\n\n1.2.1 Fluxogramas\nOs fluxogramas são representações visuais com os passos que implementam cada algoritmo. Os símbolos (caixas) possuem formas específicas para cada função e setas as ligam indicando a ordem em que devem ser executadas. Na Figura 1.1 é apresentado um fluxograma para o cálculo das raízes reais de equação de segundo grau e apresentação de mensagens de erro nos casos adequados.\n\n\n\n\n\n\nFigura 1.1: Fluxograma para cálculo e apresentação das raízes reais de uma equação de segundo grau.\n\n\n\n\n\n1.2.2 Pseudocódigo\nComo alternativa aos fluxogramas, é bastante comum o emprego do chamado pseudocódigo, o qual se assemelha a programas, mas é uma abstração da solução. O Algoritmo 1.1 é apresentado na forma de pseudocódigo.\nO Algoritmo 1.1 se refere à mesma solução lógica da Figura 1.1.\n\n\nAlgoritmo 1.1: Pseudocódigo para o cálculo e apresentação das raízes reais de uma equação de segundo grau.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Noções de algoritmos</span>"
    ]
  },
  {
    "objectID": "algoritmos-nocoes.html#algoritmos-e-programas",
    "href": "algoritmos-nocoes.html#algoritmos-e-programas",
    "title": "1  Noções de algoritmos",
    "section": "1.3 Algoritmos e programas",
    "text": "1.3 Algoritmos e programas\nO Algoritmo 1.2 é um algoritmo computacional simples com uma solução para a conversão de temperaturas entre duas escalas termométricas: de graus Celsius para Fahrenheit.\n\n\nAlgoritmo 1.2: Conversão de graus Celsius para Fahrenheit.\n\n\n\nPara exemplificar como esse algoritmo pode se tornar um programa, seguem exemplos de sua implementação em algumas linguagens distintas, sendo importante salientar a grande variação de formatos de comandos e da estrutura de cada linguagem.\nPascal:\n(*\nConversão de escalas termométricas, de graus Celsius para Fahrenheit\nRequer: a temperatura em graus Celsius\nAssegura: a temperatura em Fahrenheit\n*)\nprogram ConversaoTemperaturas;\nvar\n    Celsius, Fahrenheit: real;\nbegin\n    read(Celsius);\n    Fahrenheit := 9 / 5 * Celsius + 32;\n    write(Fahrenheit:5:2);\nend.\nPython:\n# Conversão de escalas termométricas, de graus Celsius para Fahrenheit\n# Pré-condição: a temperatura em graus Celsius\n# Pós-condição: a temperatura em Fahrenheit\n\ncelsius = float(input())\nfahrenheit = 9 / 5 * celsius + 32\nprint(f\"{fahrenheit:.2f}\")\nC:\n/*\nConversão de escalas termométricas, de graus Celsius para Fahrenheit\nRequer: a temperatura em graus Celsius\nAssegura: a temperatura em Fahrenheit\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    fgets(entrada, sizeof entrada, stdin);\n    double celsius;\n    sscanf(entrada, \"%ld\", &celsius);\n\n    double fahrenheit = (double)9 / 5 * celsius + 32;\n    printf(\"%.2f\", fahrenheit);\n\n    return 0;\n}\nR:\n# Conversão de escalas termométricas, de graus Celsius para Fahrenheit\n# Pré-condição: a temperatura em graus Celsius\n# Pós-condição: a temperatura em Fahrenheit\n\ncelsius &lt;- as.numeric(readline(\"\"))\nfahrenheit &lt;- celsius * 9 / 5 + 32\ncat(fahrenheit, \"\\n\")\nJava:\n// Conversão de escalas termométricas, de graus Celsius para Fahrenheit\n// Pré-condição: a temperatura em graus Celsius\n// Pós-condição: a temperatura em Fahrenheit\n\nimport java.util.Scanner;\n\npublic class ConversorTemperatura {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        double celsius = scanner.nextDouble();\n\n        double fahrenheit = celsius * 9 / 5 + 32;\n        System.out.println(fahrenheit);\n        \n        scanner.close();\n    }\n}\nAda:\n-- Conversão de escalas termométricas, de graus Celsius para Fahrenheit\n-- Pré-condição: a temperatura em graus Celsius\n-- Pós-condição: a temperatura em Fahrenheit\n\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Conversor_Temperatura is\n   Celsius : Float;\n   Fahrenheit : Float;\n\nbegin\n   Get(Item =&gt; Celsius);\n   Fahrenheit := Celsius * 9.0 / 5.0 + 32.0;\n   Put_Line(Float'Image(Fahrenheit));\nend Conversor_Temperatura;\nLua:\n-- Conversão de escalas termométricas, de graus Celsius para Fahrenheit\n-- Pré-condição: a temperatura em graus Celsius\n-- Pós-condição: a temperatura em Fahrenheit\n\nlocal celsius = tonumber(io.read())\nlocal fahrenheit = celsius * 9 / 5 + 32\nprint(fahrenheit)\nExiste, claramente, uma distância entre a solução (algoritmo) e sua implementação (código da linguagem).\nO principal conceito por trás dos algoritmos é ter uma solução mais abstrata, a qual não se restringe aos detalhes que cada linguagem impõe e, entretanto, apresenta uma solução simples de entender e objetiva quanto a como o problema abordado é resolvido.\nEste livro não aborda o desenvolvimento de algoritmos, porém faz uso deles quando necessário, dada a inteção de deixar clara uma solução antes de apresentar sua implementação em C. Esta estratégia visa auxiliar o programador menos experiente ou com menor familiaridade com a linguagem a identificar o que fazem as instruções do programa.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Noções de algoritmos</span>"
    ]
  },
  {
    "objectID": "c-introducao-a-linguagem-c.html",
    "href": "c-introducao-a-linguagem-c.html",
    "title": "2  Introdução à linguagem C",
    "section": "",
    "text": "2.1 Origens da linguagem C\nNeste capítulo é feita a apresentação da linguagem C, um pouco de suas origens e a evolução de sua especificação. Juntamente a essa introdução, a compilação e os conceitos de código fonte, objeto e executável também são tratados.\nConhecer um pouco do caminho de uma das mais importantes linguagens de programação deve trazer ao programador, de certa forma, uma sensação de pertencimento e autoridade no uso dessa linguagem.\nA inspiração da linguagem C veio das linguagens BCPL e B, ambas projetadas para a implementação de sistemas operacionais. Muitos elementos de C se originaram dessas linguagens.\nC surgiu como uma linguagem de propósito geral que incorporava os principais mecanismos de controle de fluxo, como condicionais e estruturas de repetição, juntamente com estruturas de dados como arranjos e registros. A linguagem não foi estruturada como tendo um alto nível de abstração e não foca em nenhuma área de aplicação em particular.\nDennis Ritchie projetou e implementou a linguagem C em um DEC PDP-11, o qual usava o sistema operacional UNIX. Na realidade, tanto o compilador C quanto o próprio sistema operacional foram implementados em C. Esse desenvolvimento ocorreu de 1969 a 1973. Também à época, compiladores C já haviam sido implementados para executar em diversas outras máquinas, como equipamentos IBM, Honeywell e Interdata.\nEste histórico foi baseado em Richards (1969), Johnson e Kernighan (1973), Ritchie et al. (1978) e Ritchie (1993).\nSegundo consulta ao índice de popularidade elaborado pela TIOBE1, C permanece como uma das linguagens de programação mais populares mundialmente, disputando os primeiros lugares com Python, C++ e Java (dados de novembro de 2023).",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução à linguagem C</span>"
    ]
  },
  {
    "objectID": "c-introducao-a-linguagem-c.html#origens-da-linguagem-c",
    "href": "c-introducao-a-linguagem-c.html#origens-da-linguagem-c",
    "title": "2  Introdução à linguagem C",
    "section": "",
    "text": "2.1.1 Padronização da linguagem\nSem uma padronização de facto da linguagem C nos anos seguintes a sua criação, havia uma liberdade grande demais na implementação dos diversos compiladores que apareceram. A especificação conhecida por K&R C era, na ocasião, a única disponível.\nDe 1983 a 1989, o American National Standards Institute (ANSI) formou um grupo de trabalho para a padronização da linguagem, estabelecendo, ao final o padrão conhecido por C89 ou ANSI C. Esse mesmo padrão foi reeditado em 1990, com o rótulo C90, porém sem modificações relevantes na especificação.\nUma extensão foi incorporada à especificação em 1995, com novas definições e adições à biblioteca padrão. Este padrão foi chamado de C95.\nModificações significativas na linguagem foram introduzidas no padrão C99, finalizado em 1999 e adotado a partir do ano 2000. Merecem destaque novos tipos de dados, como long long e _Bool, a incorporação de arranjos de comprimento definido durante a execução, a inclusão de novos cabeçalhos de bibliotecas, a possibilidade de comentários com //, a mistura de declarações e código e funções inline.\nEm 2011 foi publicada a especificação C11, a qual provê suporte a caracteres Unicode, expressões com tipos genéricos (_Generic) e execução paralela multi-plataforma com threads.h.\nO padrão atual para a linguagem C, no momento da escrita deste texto, é o C17, publicado em 2018. O C17 não acrescenta novos recursos à linguagem, porém corrige falhas na versão C11. A especificação C17 também é referenciada como C18.\nNeste ano de 2023 é esperada a próxima edição do padrão da linguagem C, informalmente designado C23.\nA especificação K&R C foi descrita em Ritchie et al. (1978); as demais especificações estão apropriadamente descritas em Wikipedia (2023).",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução à linguagem C</span>"
    ]
  },
  {
    "objectID": "c-introducao-a-linguagem-c.html#programa-básico",
    "href": "c-introducao-a-linguagem-c.html#programa-básico",
    "title": "2  Introdução à linguagem C",
    "section": "2.2 Programa básico",
    "text": "2.2 Programa básico\nProgramar em C não é tão complexo, mas também não é tão natural. Muitos aspectos básicos da linguagem requereriam, em teoria, um conhecimento mais sólido sobre o que são variáveis, como estas existem na memória e como podem ser manipuladas.\nEm um primeiro momento, estes detalhes serão ignorados, visto que é possível começar a programar e apenas aceitar que algumas coisas são assim mesmo. Para estes detalhes, por enquanto, basta pensar “não sei, só sei que foi assim”2.\n\n2.2.1 Primeiro programa: um programa mínimo (e inútil)\nPara começar diferente, o primeiro programa exemplo não será o Hello, world!, amplamente utilizado na literatura e em tutoriais. Ele será o código mínimo na linguagem que é válido e coerente. Por ser mínimo, porém, não faz nada útil.\nint main(void) {\n    return 0;\n}\nMesmo sendo minimalista, este código contém vários elementos interessantes:\n\nA função main e seu bloco de comandos\nO comando return\n\nUm bloco de comandos é uma coleção de comandos delimitados por chaves. O nome main é associado a esse bloco de comandos, que contém apenas um comando simples (o return 0;) neste caso. Os tipos int e void indicados não são relevantes neste momento. Chamar o bloco de comandos de main (principal) é obrigatório, pois indica onde a execução do programa começa.\nNeste exemplo, há um único comando dentro de main: return 0;. Este comando indica que, ao ser terminado, o programa devolve ao sistema operacional um valor inteiro, que é um indicador que indica em que condições o programa encerrou sua execução. Por convenção, o valor zero significa que a execução se encerrou sem erros.\nAo ser compilado e executado, este programa apenas indica ao sistema operacional que terminou sem erros.\n\n\n2.2.2 Segundo programa: Hello, world!\nO segundo exemplo expande o código anterior, agora para apresentar uma mensagem na tela. Para isso, ele usa uma função chamada printf, responsável por apresentar uma saída formatada.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n\");\n    return 0;\n}\nHello, world!\nEste programa, além do printf, também usa a linha #include &lt;stdio.h&gt;. O arquivo stdio.h é um arquivo de cabeçalho (stdio significa standard input and output e .h indica header) e contém informações sobre como o printf deve ser processado pelo compilador. Este arquivo de cabeçalho descreve uma série de funções para entradas e saídas feitas pelos programas.\nO argumento do printf é o texto Hello, world!. Em C, textos são sempre especificados entre aspas duplas. No exemplo, \\n é um indicador para mudar para a linha seguinte.\nUm outro detalhe no código ainda pode ser destacado: cada comando simples é terminado com um ponto e vírgula, que é o caso tanto do printf quanto do return.\nNa sequência é apresentada a versão definitiva do código do Hello, world!.\n/*\nPrograma \"Hello, world\": código exemplo do clássico primeiro programa em C\n    que apenas apresenta uma mensagem de saudação na tela\nAssegura: a apresentação da mensagem padrão \"Hello, world\"\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n\");\n    return 0;\n}\nHello, world!\nEsta versão acrescenta a documentação do código. Qualquer texto colocado entre /* e */ é um comentário e é ignorado completamente pelo compilador ao analisar o código fonte. Os comentários não são para o compilador, mas para humanos que lerão o código do programa.\nNeste caso específico, o comentário tem a função de documentar o propósito do código. Ele fornece uma descrição do propósito do código e dá informações relevantes. O grau de detalhe depende sempre do contexto; códigos simples podem ter documentação mais simples, enquanto programas que fazem parte de um projeto compartilhado entre vários desenvolvedores deve conter as informações necessárias para que todos da equipe os compreendam.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução à linguagem C</span>"
    ]
  },
  {
    "objectID": "c-introducao-a-linguagem-c.html#comandos-simples",
    "href": "c-introducao-a-linguagem-c.html#comandos-simples",
    "title": "2  Introdução à linguagem C",
    "section": "2.3 Comandos simples",
    "text": "2.3 Comandos simples\n Um componente estrutural da linguagem é o chamado comando simples. Esse comando de caracteriza por uma instrução individual no código do programa.\nOs comandos simples seguem uma sintaxe também simples.\n\n\n\n\n\n\nComando simples\n\n\n\ninstrução ;\n\n\nNos exemplos dados, cada printf usado para apresentar uma informação e também o return 0 são comandos simples e, desta forma, obrigatoriamente terminados com um ponto e vírgula. A execução do printf é uma instrução, assim como o término da execução indicado pelo return.\nSegue um exemplo simples de programa com alguns comandos simples.\n/*\nApresentação de uma série de mensagens na tela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Bom dia! \");\n    printf(\"Este é um exemplo de \");\n    printf(\"vários comandos simples.\\n\");\n    printf(\"Todos são execuções do printf e todos são finalizados com ';'.\\n\");\n    printf(\"O 'return 0', naturalmente, também é um comando simples.\\n\");\n\n    return 0;\n}\nBom dia! Este é um exemplo de vários comandos simples.\nTodos são execuções do printf e todos são finalizados com ';'.\nO 'return 0', naturalmente, também é um comando simples.\n\n\n\n\n\n\nDica\n\n\n\nEmbora a linguagem C não tenha objeções quando a escrever dois comandos simples em uma única linha do programa, sugere-se forntemente que cada comando tenha sua própria linha.\n\n\n\n\n\n\n\n\nCuriosidade\n\n\n\nEm C, existe a possibilidade de que o comando simples seja vazio. Para especificá-lo, bastar inserir o ponto e vírgula.\n    printf(\"Um!\");\n    ;  // comando vazio que não faz nada...\n    printf(\"Dois!\");\nResta pensar quando um comando que não faz nada pode ser útil.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução à linguagem C</span>"
    ]
  },
  {
    "objectID": "c-introducao-a-linguagem-c.html#código-fonte-objeto-e-executável",
    "href": "c-introducao-a-linguagem-c.html#código-fonte-objeto-e-executável",
    "title": "2  Introdução à linguagem C",
    "section": "2.4 Código fonte, objeto e executável",
    "text": "2.4 Código fonte, objeto e executável\nTodos os programas em C são escritos em arquivos de texto simples, que são os que não dão suporte a negrito e itálico, tipos de fonte ou formatação de parágrafo, entre outros recursos. O código em C segue uma sintaxe bastante específica e os programas escritos são chamados de código fonte.\nPara um programa escrito em C ser executado, primeiramente é necessário que ele seja compilado. O compilador é um programa cuja atribuição principal é analisar o código fonte, interpretando as letras, símbolos e dígitos ali escritos e gerar o código objeto, que é o código compilado. O código objeto é guardado em um arquivo e já não é mais legível por humanos, já que contém as instruções que o processador é capaz de entender e executar.\nO código fonte, depois de compilado, leva a um código objeto que é dependente da máquina. Assim, são produzidos códigos objeto específicos para processadores x86, ARM ou outro. Para que um mesmo programa possa ser executado em plataformas diferentes, é preciso que ele seja compilado para cada plataforma alvo individualmente.\nHá inúmeros compiladores disponíveis para C, como o GNU e o CLang, por exemplo. Também há implementações de compiladores específicos para cada plataforma de sistema operacional e e de processador. Ou seja, há um compilador GNU para Windows executando em processadores x86 e outro para Linux em um processador ARM. Cada compilador um possui suas próprias regras internas, mas todos obedecem especificações rigorosas e padronizadas. Desta forma, independente do hardware e do sistema operacional, um mesmo código fonte, ao ser compilado e executado, produz um mesmo resultado. Isso é uma regra e, para ela, naturalmente há exceções.\nNeste texto, a especificação conhecida como C17 (da ISO) é a adotada para todas as implementações. Os programas são compilador usando o compilador GNU em um sistema operacional Linux, tudo sobre um hardware x86.\nFinalmente, ainda há uma última etapa, na qual o código compilado é colocado em um arquivo que o sistema operacional da vez consegue carregar para a memória e colocá-lo em execução. Este é chamado de código executável e também depende da plataforma.\nUsualmente a etapa do código objeto é escondida de quem usa o compilador e, aparentemente, do código fonte é gerado diretamente o executável. Na prática, esse é o efeito final.\n\n2.4.1 Compilação com o gcc\nHá uma diversidade de compiladores para a linguagem C, além de diversos IDEs3 com diferentes facilidades para escrever códigos fonte. Há IDEs que podem ser instalados, como Visual Studio Code4, Code::Blocks5, Visual Studio6 ou Eclipse7, por exemplo, além das disponíveis online, como GDB8, Programiz9 ou Replit10.\n\nNeste livro os programas foram compilados invocando no terminal o compilador GNU GCC11 na versão mais recente disponível no repositório oficial do Debian.\n$ gcc --version\ngcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0\nCopyright (C) 2023 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\nAs opções -Wall e -pedantic são incluídas automaticamente e ativam uma vasta gama de mensagens de erro e avisos importantes, dando maior controle sobre o código executável que está sendo gerado. A especificação C17 da linguagem C é adotada com a opção -std=c17 (Seção 2.1.1).\nalias gcc='gcc -Wall -pedantic -std=c17'\n\nPara exemplificar, considere um arquivo com nome bom_dia.c com código fonte seguinte.\n/*\nApresentação um bom dia!\nAssegura: uma mensagem de bom dia apresentada na tela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Bom dia! Que seu dia seja ótimo!\\n\");\n\n    return 0;\n}\nUsando o comando file é possível ver (ou tentar ver) o tipo de informação guardada em um arquivo. Para o caso do código fonte, o arquivo é identificado como C source code, ou seja, código fonte em C.\n$ file bom_dia.c\nbom_dia.c: C source, Unicode text, UTF-8 text\nA compilação pode ser feita com o comando apresentado. A opção -o permite nomear o arquivo executável que é criado.\n$ gcc -Wall -pedantic -std=c17 bom_dia.c -o bom_dia\nEsse comando compila bom_dia.c e gera o arquivo executável bom_dia. No caso de sucesso na compilação, o gcc não apresenta saídas; apenas eventuais problemas são apresentados na tela.\n$ file bom_dia\nbom_dia: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically \nlinked, interpreter /lib64/ld-linux-x86-64.so.2, \nBuildID[sha1]=87d67e99709397eb27df650972aaab8300baf796, for GNU/Linux 3.2.0, \nnot stripped\nA execução de file, nesse caso, apresenta muita informação. A relevante, neste momento, é que o arquivo contém um ELF 64-bit LSB pie executable, o que quer dizer que é um programa executável.\nNa sequência é apresentada a execução do programa bom_dia.\n$ ./bom_dia\nBom dia! Que seu dia seja ótimo!\n\n\n\n2.4.2 Erros de sintaxe\nSendo uma linguagem de programação, os comandos são sempre analisados de forma rígida. A falta de um parêntese, um espaço no lugar errado ou uma grafia errada (como prinft, por exemplo) já dá margem para o compilador reclamar que algo está errado e se recusar a gerar o executável. Esses são os erros de sintaxe e é função do compilador encontrá-los.\nO programador deve aprender a ler as mensagens de erro produzidas pelo compilador e interpretá-las, permitindo a remoção dos erros sintáticos.\nComo exemplo, segue uma versão incorreta do programa exemplo. Nela, “acidentalmente” o ponto e vírgula foi esquecido.\n/*\nPrograma \"Hello, world\": código exemplo do clássico primeiro programa em C\n    que apenas apresenta uma mensagem de saudação na tela\nAssegura: a apresentação da mensagem padrão \"Hello, world\"\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n\")\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:9:30: error: expected ‘;’ before ‘return’\n    9 |     printf(\"Hello, world!\\n\")\n      |                              ^\n      |                              ;\n   10 |     return 0;\n      |     ~~~~~~                    \nA mensagem de erro aponta em que linha e coluna deveria haver um ponto e vírgula.\nOs erros são apresentados conforme o compilador consegue detectar, apresentando mensagens tão boas quanto possível. Além disso, uma única falha pode desencadear uma sequência de erros, como no exemplo seguinte, na qual apenas faltou fechar as aspas no argumento da função printf.\n/*\nPrograma \"Hello, world\": código exemplo do clássico primeiro programa em C\n    que apenas apresenta uma mensagem de saudação na tela\nAssegura: a apresentação da mensagem padrão \"Hello, world\"\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n);\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:9:12: warning: missing terminating \" character\n    9 |     printf(\"Hello, world!\\n);\n      |            ^\nmain.c:9:12: error: missing terminating \" character\n    9 |     printf(\"Hello, world!\\n);\n      |            ^~~~~~~~~~~~~~~~~~\nmain.c:10:5: error: expected expression before ‘return’\n   10 |     return 0;\n      |     ^~~~~~\nmain.c:10:14: error: expected ‘;’ before ‘}’ token\n   10 |     return 0;\n      |              ^\n      |              ;\n   11 | }\n      | ~             \n\n\n2.4.3 Erros de lógica\nUm programa pode ser compilado e gerar o executável sem erros ou qualquer tipo de aviso que o compilador esteja ajustado para dar. Mas apesar disso, a execução não produz o resultado desejado. Neste caso, mesmo com a sintaxe correta, as instruções contém um erro (uma falha de cálculo, uma comparação equivocada) que invalida o programa. Esse são os erros de lógica e, desta vez, cabe ao programador encontrá-los e corrigi-los.\nA evitação de erros de lógica é considerada ao longo de todo o livro.\n\n\n\n\nJohnson, Stephen C, e Brian W Kernighan. 1973. The programming language B. Bell Laboratories Murray Hill, New Jersey. https://minnie.tuhs.org/Mirrors/Dennis/btut.pdf.\n\n\nRichards, Martin. 1969. “BCPL: A tool for compiler writing and system programming”. Em, 557566. https://dl.acm.org/doi/pdf/10.1145/1476793.1476880.\n\n\nRitchie, Dennis M. 1993. “The development of the C language”. ACM Sigplan Notices 28 (3): 201208. https://www.bell-labs.com/usr/dmr/www/chist.pdf.\n\n\nRitchie, Dennis M, Stephen C Johnson, ME Lesk, e BW Kernighan. 1978. “The C programming language”. Bell Sys. Tech. J 57 (6): 19912019. https://www.academia.edu/download/67840358/1978.07_Bell_System_Technical_Journal.pdf#page=85.\n\n\nWikipedia. 2023. “C (programming language)”. https://en.wikipedia.org/w/index.php?title=C_(programming_language)&oldid=1182945224.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução à linguagem C</span>"
    ]
  },
  {
    "objectID": "c-introducao-a-linguagem-c.html#footnotes",
    "href": "c-introducao-a-linguagem-c.html#footnotes",
    "title": "2  Introdução à linguagem C",
    "section": "",
    "text": "TIOBE: http://www.tiobe.com.↩︎\nComo diria Chicó, em Auto da Compadecida, peça de teatro de Ariano Suassuna também retratada em uma minissérie de televisão.↩︎\nUm ambiente de desenvolvimento integrado, ou integrated development environment (IDE), é um programa que dá suporte para escrever programas, provendo um editor de texto dedicado, destaque de sintaxe (diferentes elementos do programa aparecem em cores diferenciadas), acesso ao compilador com o clique de um botão ou uma combinação simples no teclado.↩︎\nVisual Studio Code: https://code.visualstudio.com.↩︎\nCode::Blocks: https://www.codeblocks.org.↩︎\nVisual Studio: https://visualstudio.microsoft.com.↩︎\nEclipse: https://www.eclipse.org.↩︎\nGDB Online: https://www.onlinegdb.com.↩︎\nProgramiz: https://www.programiz.com.↩︎\nReplit: https://replit.com. ↩︎\nGnu Compiler Collection: https://gcc.gnu.org.↩︎",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introdução à linguagem C</span>"
    ]
  },
  {
    "objectID": "c-tipos-de-dados.html",
    "href": "c-tipos-de-dados.html",
    "title": "3  Tipos de dados da linguagem C",
    "section": "",
    "text": "3.1 Representação de dados\nQualquer linguagem de programação, dentre as milhares existentes, têm como premissa a manipulação e a transformação de dados. Esta parte do texto trata de como dados são representados em computação e faz uma apresentação dos principais tipos de dados usados na linguagem C.\nA ilustração dos tipos de dados, suas limitações e principais características envolvem, adicionamente, a apresentação da função printf, responsável por apresentar os dados do programa para o usuário.\nEm computação, as informações são estruturadas em bits. A forma mais básica de circuitos eletrônicos representarem algo é pela ausência ou presença de corrente elétrica. Assim, um bit é uma parte do circuito que indica “desligado” ou “ligado”, “sem corrente elétrica” ou “com corrente elétrica”, “ausente” ou “presente” ou, simplificadamente, “zero” ou “um”. O uso dos valores binários 0 e 1 é a forma tradicional de se representar um bit.\nPara serem usados de forma prática, os bits são sempre organizados em sequências de comprimento oito. O grupo de oito bits é chamado de byte. Nos sistemas computacionais, os circuitos responsáveis por armazenar os bytes são chamados de memória. Esta é usualmente medida em gigabytes, sendo cada gigabyte correspondente a 1.073.741.824 bytes (230).\nCada byte, com seus oito bits, pode assumir os valores 00000000, 00000001, 00000010, 000000011… até 11111111. São 28 possíveis combinações.\nProgramas manipulam dados, como nomes de localidades, taxas de câmbio, velocidade de veículos, listas de espera e tantos outros. Para representar os dados, programas usam essa memória estruturada em bytes. Tanto as instruções que serão executadas pelo processador quanto os dados precisam ser representados com bytes.\nPara representar um dado qualquer, portanto, é preciso fazer seu mapeamento para bytes.\nA letra A é usualmente representada pelo byte 01000001 e o símbolo !, pelo 00100001. Essas escolhas foram arbitrárias e o mapeamento do conjunto básico de caracteres pode ser consultado em uma tabela chamada de American Standard Code for Information Interchange, ou tabela ASCII1. Textos são representados por sequências de bytes representando os caracteres.\nNúmeros inteiros são frequentemente representados por uma certa quantidade fixa de bytes consecutivos. Assim, considerando-se quatro bytes para um inteiro, é possível associar a sequência 00000000 00000000 00000000 00000000 ao valor zero, 00000000 00000000 00000000 00000001 ao valor 1 e assim, sucessivamente, até 11111111 11111111 11111111 11111111, que equivaleria a 4.294.967.295 (ou 232-1). Números negativos separam o primeiro bit para indicar o sinal (0 é positivo, 1 é negativo) e os demais 31 bits seriam usados para representar os diversos valores, indo de -2.147.483.648 a 2.147.483.647 considerando-se os quatro bytes. Naturalmente, quanto mais bytes, maior o intervalo de valores representados.\nOutros tipos de valores, como números reais, valores lógicos e endereços internos da memória também escolhem uma estratégia para representar seus valores usando um mapeamento adequado para um ou mais bytes.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tipos de dados da linguagem C</span>"
    ]
  },
  {
    "objectID": "c-tipos-de-dados.html#sec-constantes-e-seus-tipos",
    "href": "c-tipos-de-dados.html#sec-constantes-e-seus-tipos",
    "title": "3  Tipos de dados da linguagem C",
    "section": "3.2 Constantes e seus tipos",
    "text": "3.2 Constantes e seus tipos\nTendo em vista que quaisquer dados (números, textos ou qualquer outro) usam bytes para serem representados, a linguagem C também designa uma codificação específica para os valores ao interpretar um código fonte.\nNos programas em C, valores explícitos no código, como um texto ou um valor numérico, é chamado de valor constante. O texto clássico expresso por \"Hello, world!\" é uma constante literal (textual). Em C, as constantes com sequências de caracteres são sempre expressas usando-se aspas duplas.\nO código seguinte visa apresentar como saída o valor de \\(\\pi\\), que foi (grosseiramente) aproximando no código fonte para 3,1416.\n/*\nApresentação do valor aproximado de pi\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"pi vale, aproximadamente, %g\\n\", 3.1416);\n    return 0;\n}\npi vale, aproximadamente, 3.1416\nO comando printf possui dois parâmetros. O primeiro é uma constante textual com o que deve ser apresentado (elemento obrigatório da função); o segundo é um valor real expresso na forma de uma constante (3.1416). O símbolo %g é um indicador de local usado para valores reais, ou seja ele representa onde o valor 3,1416 será inserido no texto.\nA constante 3.1416 (expressa usando o ponto como separador decimal) possui, em C, o tipo double. Esse tipo corresponde a uma representação de precisão dupla, seguindo o padrão IEC 60559. Qualquer constante real em C é representada por um double, exceto quando explicitamente indicado de outra forma.\nConstantes inteiras expressas em base 10 são representadas pelo tipo int, que tem mínimo de 16 bits, embora implementações atuais comumente usem 32 bits. Com o mínimo de bits, os valores representados vão de -32.768 a 32.767; já com 32 bits a variação é de -2.147.483.648 a 2.147.483.647. Desta forma, dependendo da implementação do compilador, os limites podem variar consideravelmente. As constantes inteiras seguem essa regra, exceto quando declaradas explicitamente com um tipo específico.\nCaso uma constante inteira exceda a capacidade de representação de um int, um long int é usado em seu lugar, partindo de um mínimo de 32 bits. Essa escolha é transparente para o programador.\n/*\nApresentação do valor de 5234 elevado ao cubo\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"O cubo de %d é igual a %ld\\n\", 5234, 143384152904);\n    return 0;\n}\nO cubo de 5234 é igual a 143384152904\nNeste programa, o printf usa a especificação %d, significando um int apresentado na base 10 (decimal). A especificação %ld é usada para um long int expresso em decimal. Os valores são substituídos na ordem em que aparecem no printf.\nParticularmente no compilador usado para produzir esse exemplo, o valor 5.234 pode ser representado em um int e escrito com %d; já 143.384.152.904 (5.2343) necessitou de mais bits e foi automaticamente promovido para um long int, cuja especificação de formato é %ld. O compilador poderá apresentar um aviso caso o valor maior tente ser escrito apenas com %d, embora o executável seja gerado e o resultado apresentado seja incorreto.\nDa mesma forma que há especificadores para valores numéricos, há também para valores textuais.\n/*\nApresentação de valores textuais\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%s é primo de %s\\n\", \"Nereu\", \"Eutália\");\n    printf(\"%s é prima de %s\\n\", \"Eutália\", \"Nereu\");\n    printf(\"%s começa com a letra %c\\n\", \"Yolanda\", 'Y');\n\n    return 0;\n}\nNereu é primo de Eutália\nEutália é prima de Nereu\nYolanda começa com a letra Y\n A indicação %s é compatível com textos de comprimento variado, ou seja, cadeias de caracteres. Por outro lado, C define um tipo específico para um único caractere: o tipo char. Ele usa oito bits (mínimo), ou seja, um byte, e é representado por aspas simples: 'Y'. Para caracteres simples do tipo char, usa-se a especificação de formato %c.\nA diferença entre \"Y\" e 'Y' é abordada em mais detalhes no Capítulo 16.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tipos de dados da linguagem C</span>"
    ]
  },
  {
    "objectID": "c-tipos-de-dados.html#mais-sobre-o-printf",
    "href": "c-tipos-de-dados.html#mais-sobre-o-printf",
    "title": "3  Tipos de dados da linguagem C",
    "section": "3.3 Mais sobre o printf",
    "text": "3.3 Mais sobre o printf\nO nome printf vem de print formatted, ou seja, apresente algo de forma formatada. O uso desta função requer o carregamento do arquivo de cabeçalho stdio.h.\nA função apresenta um texto na saída padrão (a tela do terminal) e este deve ser o primeiro parâmetro. Além de apresentar o texto, a função também faz conversões de valores, usando os marcadores iniciados com %. Por exemplo, %d é usado para um valor inteiro decimal, %g para apresentar um valor real e %s é usado para apresentar valores textuais, chamados cadeias de caracteres ou strings. Outro elemento de formatação são os caracteres especiais como \\n, que indica a mudança de linha, \\t, que é uma tabulação similar à dos editores de texto, ou ainda \\\", que indica aspas duplas.\nCada marcador com o símbolo % é substituído em ordem. Assim, se houver várias substituições, cada uma delas é feita sucessivamente.\n/*\nExemplo de escrita de vários valores\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Meu nome é %s, nasci em %d e ganho R$ %g de salário.\\n\",\n        \"Fulano\", 2003, 2512.17);\n\n    return 0;\n}\nMeu nome é Fulano, nasci em 2003 e ganho R$ 2512.17 de salário.\nPara valores inteiros, segue um exemplo para a escrita do valor de uma expressão usando variações de formato. Algumas opções diferentes de escrita são acrescentadas.\n/*\nExemplo de escrita de valores inteiros\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Um valor inteiro    : %d\\n\", 481);\n    printf(\"Outro valor inteiro : %8d\\n\", 481);\n    printf(\"E mais outro        : %08d\\n\", 481);\n\n    return 0;\n}\nUm valor inteiro    : 481\nOutro valor inteiro :      481\nE mais outro        : 00000481\nQuando um número inteiro é inserido entre o % e o d, como em %8d, e reservado um espaço fixo para o inteiro, que é formatado à direita. No exemplo, como o valor escrito possui três dígitos, antes dele são acrescentados cinco espaços para, no total, preencher as oito posições especificadas. No caso de %08d, o dígito 0 indica que os espaços faltantes devem ser preenchidos com o dígito zero.\nNo caso de valores reais, o formato %g é uma representação que busca a “melhor” forma de se apresentar um valor, seguindo um algoritmo interno.\n/*\nExemplo de escrita de valores reais com %g\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Um valor real    : %g\\n\", 23.0);\n    printf(\"Outro valor real : %g\\n\", 163778837773.32998827);\n    printf(\"E mais outro     : %g\\n\", 3.3/1234567.8);\n    printf(\"E um último      : %g\\n\", 1.23432624324);\n\n    return 0;\n}\nUm valor real    : 23\nOutro valor real : 1.63779e+11\nE mais outro     : 2.673e-06\nE um último      : 1.23433\nNeste programa, o valor 23,0, como não possui casas decimais, é mostrado como se fosse um valor inteiro. Os outros dois valores usam a notação científica para deixar a escrita mais concisa, lembrando que 1.63779e+11 equivale a 1,63779 \\(\\times\\) 1011 e 2.673e-07, a 2,673 \\(\\times\\) 10-7. O último exemplo mostra um arredondamento do valor escrito.\nÉ possível acrescentar ao %g o comprimento total que o valor deve ter (%10g para 10 espaços), o número de casas decimais que serão apresentadas (%.5g para cinco decimais), além de outras opções.\nAlém da especificação %g, é possível usar %f (nunca usa notação científica) ou %e (sempre notação científica) para valores reais.\nFinalmente, ainda há especificações para apresentação de endereços de memória (%p) e valores inteiros nas bases hexadecimal (%x) e octal (%o).\n/*\nExemplo de escrita alguns formatos de apresentação\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"O decimal %d pode ser escrito %x (hexadecimal) ou %o (octal).\\n\",\n        125, 125, 125);\n    printf(\"Este é o endereço nulo: %p\\n\", NULL);\n\n    return 0;\n}\nO decimal 125 pode ser escrito 7d (hexadecimal) ou 175 (octal).\nEste é o endereço nulo: (nil)",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tipos de dados da linguagem C</span>"
    ]
  },
  {
    "objectID": "c-tipos-de-dados.html#sec-constante-com-tipo-explicito",
    "href": "c-tipos-de-dados.html#sec-constante-com-tipo-explicito",
    "title": "3  Tipos de dados da linguagem C",
    "section": "3.4 Constantes com tipo explícito",
    "text": "3.4 Constantes com tipo explícito\nAs constantes expressas em C possuem tipos automáticos ligados à ela, como apresentado na Seção 3.2. A linguagem, porém, permite escrever um valor constante e associar a ele um tipo específico.\n/*\nExemplos de constantes com tipo explícito\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Este %d é int, mas este %ld é long int\\n\", 10, 10L);\n    printf(\"Este %u é um unsigned int\\n\", 10U);\n\n    printf(\"A diferença entre %g (precisão dupla) e %g (simples) é %g\\n\",\n        1e-7, 1e-7f, 1e-7 - 1e-7f);\n\n    return 0;\n}\nEste 10 é int, mas este 10 é long int\nEste 10 é um unsigned int\nA diferença entre 1e-07 (precisão dupla) e 1e-07 (simples) é -1.16861e-15",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tipos de dados da linguagem C</span>"
    ]
  },
  {
    "objectID": "c-tipos-de-dados.html#hexadecimal-e-octal",
    "href": "c-tipos-de-dados.html#hexadecimal-e-octal",
    "title": "3  Tipos de dados da linguagem C",
    "section": "3.5 Hexadecimal e octal",
    "text": "3.5 Hexadecimal e octal\nAs constantes inteiras são, usualmente, escritas usando a base 10. A linguagem C permite, além desta, escrever constantes na base oito (octal) e 16 (hexadecimal). O uso dessas bases é prático quando quando a linguagem é usada para manipulação em nível baixo, ou seja, no nível dos bits.\n/*\nExemplos de constantes em hexadecimal e em octal\nConstante hexadecimais se iniciam com 0x\nValores em octal são expressos iniciando o número com zero\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Três maneiras de escrever %d: %d e %d\\n\", 10, 0xA, 012);\n    printf(\"Três maneiras de escrever %x: %x e %x\\n\", 10, 0xA, 012);\n    printf(\"Três maneiras de escrever %o: %o e %o\\n\", 10, 0xA, 012);\n\n    return 0;\n}\nTrês maneiras de escrever 10: 10 e 10\nTrês maneiras de escrever a: a e a\nTrês maneiras de escrever 12: 12 e 12",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tipos de dados da linguagem C</span>"
    ]
  },
  {
    "objectID": "c-tipos-de-dados.html#footnotes",
    "href": "c-tipos-de-dados.html#footnotes",
    "title": "3  Tipos de dados da linguagem C",
    "section": "",
    "text": "Existem outras estratégias para representação de caracteres, principalmente para incorporar acentuações (como ñ do espanhol), caracteres particulares (ß do alemão) ou ainda caracteres como os japoneses e hebraicos.↩︎",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tipos de dados da linguagem C</span>"
    ]
  },
  {
    "objectID": "c-variaveis-identificadores-e-leitura.html",
    "href": "c-variaveis-identificadores-e-leitura.html",
    "title": "4  Variáveis e leituras em C",
    "section": "",
    "text": "4.1 Variáveis, declarações e atribuição\nUm programa em C lida com dados, que podem ser de diferentes tipos, como int, long int ou double, por exemplo. Neste capítulo são apresentados onde os dados são armazenados nos programas (variáveis), seus nomes (identificadores) e como guardar e substituir os valores desses dados (atribuição e leitura).\nConforme abordado na Seção 3.1, qualquer informação precisa ser mapeada para bytes para poder ser utilizada em um sistema computacional.\nPara que um programa faça sua tarefa de resolver um dado problema, é preciso que ele tenha acesso à memória e sua representação. Quase na totalidade das linguagens de programação, uma área da memória na qual está guardado um dado é referenciado por um nome arbitrário. Por exemplo, se o ano de um evento é um dado que precisa ser guardado, os bytes reservados para o armazenamento dessa informação é referenciado por um identificador. E dado que o conteúdo da memória possa eventualmente ser modificado, a esse armazenamento é dado o nome de variável, no sentido de mutável.\nAssim, uma variável corresponde a uma área da memória principal e os bytes que a compõe são referenciados por um identificador.\nO programa seguinte exemplifica o uso de duas variáveis para o armazenamento de valores de temperatura.\nA variável cujo identificador é celsius armazena valores reais usando o tipo double. Ela representa alguns bytes na memória principal na qual o valor de 25,5ºC é representado. Uma segunda variável do tipo double também é usada para armazenar outro valor real. Neste caso, o valor armazenado é um cálculo que envolve a primeira variável e equivale à conversão da escala Celsius para Fahrenheit (notando que o operador * denota a multiplicação). O identificador desta segunda variável é fahrenheit. Ambos os nomes (identificadores) foram escolhidos pelo programador à sua conveniência.\nHá pontos importantes neste programa:\nA primeira variável, celsius, é declarada precedendo-se seu identificador por seu tipo, que, no caso, é double. Valores reais, via de regra, devem usar o tipo double como tipo para a representação e armazenamento.\nO sinal de igual é o operador de atribuição. Ele indica que o valor à direita (o valor 25.5, que é um double) será armazenado na área de memória reservada para a variável. Assim, a variável é criada (declaração) e tem um valor atribuído a ela (com o =) na mesma linha de código. Estas duas ações são finalizadas por um ponto e vírgula.\nO mesmo ocorre com a segunda variável, que é declarada e a ela é atribuído um valor resultante de uma expressão que envolve uma multiplicação (*) e uma soma (+).\nA diferença aqui é que o valor atribuído à variável, isto é, armazenado nela, é o resultado de uma expressão aritmética cujo objetivo é a conversão entre as unidades de temperatura. Outra diferença é que a expressão usa o valor de celsius, ou seja, ela usa o conteúdo armazenado nessa variável específica.\nDeste modo, é importante salientar que, por meio do identificador de uma variável, um conteúdo pode ser armazenado nela e também esse valor pode ser consultado para uso.\nPor fim, vale ainda comentar que na função printf os valores armazenados nas duas variáveis são novamente consultados para serem convertidos para uma representação textual e apresentados.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variáveis e leituras em C</span>"
    ]
  },
  {
    "objectID": "c-variaveis-identificadores-e-leitura.html#variáveis-declarações-e-atribuição",
    "href": "c-variaveis-identificadores-e-leitura.html#variáveis-declarações-e-atribuição",
    "title": "4  Variáveis e leituras em C",
    "section": "",
    "text": "/*\nConversão de escalas termométricas, de graus Celsius para Fahrenheit\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double celsius = 25.5; \n    double fahrenheit = 1.8 * celsius + 32;\n\n    printf(\"%g graus Celsius = %g Fahrenheit\\n\", celsius, fahrenheit);\n\n    return 0;\n}\n25.5 graus Celsius = 77.9 Fahrenheit\n\n\n\nHá a declaração de duas variáveis;\nExistem valores atribuídos a ambas;\nO valor armazenado nas variáveis é consultado.\n\n\ndouble celsius = 25.5; \n\n\ndouble fahrenheit = 1.8 * celsius + 32;",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variáveis e leituras em C</span>"
    ]
  },
  {
    "objectID": "c-variaveis-identificadores-e-leitura.html#identificadores",
    "href": "c-variaveis-identificadores-e-leitura.html#identificadores",
    "title": "4  Variáveis e leituras em C",
    "section": "4.2 Identificadores",
    "text": "4.2 Identificadores\nNas linguagens de programação, muitos de seus elementos possuem nomes, chamados de identificadores. O nome dado a uma variável é seu identificador; main é o identificador da função por onde o programa em C começa sua execução.\n Um identificador é uma sequência de caracteres usada como nome. Existem palavras reservadas na linguagem, como void, return, int e double, entre outras, que não podem ser usadas como identificadores. Até agora, foram usados nos exemplos identificadores para variáveis (celsius) e funções (printf).\nUm identificador válido na linguagem C é formado exclusivamente por letras, dígitos e pela sublinha (_), nunca se iniciando com um dígito. A Tabela 4.1 apresenta exemplos.\n\n\n\nTabela 4.1: Identificadores e sua validade.\n\n\n\n\n\nIdentificadores válidos.\n\n\nIdentificador\nValidade\n\n\n\n\nnome\nsim\n\n\nidade\nsim\n\n\nsalario_medio\nsim\n\n\nprefixo1\nsim\n\n\nprefixo2\nsim\n\n\nmassa_kg\nsim\n\n\na1b2c3d4__\nsim\n\n\n__estado__\nsim\n\n\n\n\n\n\nIdentificadores inválidos.\n\n\nIdentificador\nValidade\n\n\n\n\n2pi\nnão (inicia com dígito)\n\n\nsalario-medio\nnão (hífen presente)\n\n\nkm/h\nnão (barra presente)\n\n\nmassa total\nnão (espaço presente)\n\n\nnota.geral\nnão (ponto presente)\n\n\ntotal:geral\nnão (dois pontos presente)\n\n\nvalor~\nnão (til presente)\n\n\nmontante_r$\nnão (cifrão presente)\n\n\n\n\n\n\n\n\nAs letras podem ser maiúsculas ou minúsculas, como valor, Idade e ponto_A, por exemplo. O jargão da computação para referenciar maiúsculas e minúsculas é caso. A linguagem C tem identificadores sensíveis ao caso: total, Total e TOTAL são identificadores distintos e podem coexistir.\nA escolha dos identificadores é responsabilidade do programador.\n\n4.2.1 Estilo\nNos programas apresentados neste livro, todos os identificadores de variáveis e de funções são escritos em snake case, que é um estilo de escrita. No snake case, todas as letras usadas são minúsculas e, quando um identificador é composto de duas ou mais palavras, é usada a sublinha para separá-las.\nEssa regra é seguida mesmo quando os nomes possuem sua combinação de maiúsculas e minúsculas característicos. Desta forma, o armazenamento do CPF usará uma variável cpf, um cálculo envolvendo o pH usará ph ou a temperatura em Fahrenheit usará fahrenheit.\nEsse padrão não é necessariamente adotado pelas bibliotecas da linguagem, que usam abreviações e combinações de estilo próprias e independentes. Como exemplos, não é usado print_formatted, mas printf, e na manipulação de caracteres há uma função chamada strcat, que significa string concatenation (sim, concatenation é abreviada para cat).\n\n\n\n\n\n\nDica\n\n\n\nA aderência a um padrão no formato dos identificadores, qualquer que ela seja, é muito importante para códigos claros e compreensíveis. Uma vez escolhido um padrão, este deve ser mantido constante em todo o código.\n\n\nOs estilos usados nos programas implementados neste material estão descritos no ?sec-guia-de-estilo.\n\n\n\n\n\n\nDica\n\n\n\nA versões mais atuais das especificações para a linguagem C permitem o uso de caracteres acentuados nos identificadores. Essa é uma prática de uso raro, porém.\n/*\nAumento de salário\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double salário_atual = 3500.00;\n    double porcentagem_aumento = 0.15;  // 15%\n\n    printf(\"Salário anterior: %.2f.\\n\", salário_atual);\n\n    salário_atual = salário_atual * (1 + porcentagem_aumento);\n    printf(\"Salário novo: %.2f.\\n\", salário_atual);\n\n    return 0;\n}\nSalário anterior: 3500.00.\nSalário novo: 4025.00.\nFica registrada uma recomendação de que somente caracteres ASCII simples sejam usados para os identificadores. A manutenção do código por terceiros, por exemplo, pode se tornar complicada se outros programadores, com configurações de teclado diferentes, simplesmente não conseguirem digitar o nome de uma variável, como um código escrito em tcheco com uma variável chamada stáří (idade).\n\n\n\n\n4.2.2 Identificadores significativos\nEm programas bem escritos a clareza é importante. O compilador não se importa com o nome escolhido para uma variável; essa escolha é para os humanos que leem o código fonte. A escolha de bons nomes ajuda a entender melhor o que o comandos fazem e, em consequência, permitem a identificação de erros, a correção dessas falhas e a incorporação de novas funcionalidades.\nA regra básica para escolher um nome de variável é deixar claro o que ela contém. A opção por um ou outro nome depende bastante do contexto e é nesse contexto que deve haver clareza. Como um exemplo, uma variável chamada nível pode conter um valor numérico correspondente ao nível de um reservatório ou então ser uma valor textual com valores esperados \"fácil\", \"médio\" ou \"difícil\".\nHá uma tendência natural (e bem comum) de associar as variáveis dos programas às variáveis da matemática, o que leva a escolha de variáveis com identificadores genéricos e não significativos, como x, t ou a. Em geral, se uma variável possui uma única letra, essa escolha não é uma boa opção. Há, porém, exceções.\n\n\n\n\n\n\nDica\n\n\n\nSe um programador precisar explicar, de alguma forma, o que uma variável contém, é porque o identificador dela foi mal escolhido.\n\n\nAo longo do livro, os programas usam variáveis com nomes significativos. Muitas vezes os nomes são longos, o que pode levar o programador a ter preguiça de digitá-los. Felizmente, os IDEs modernos possuem recursos de auto-completar as digitações, que eliminam essa dificuldade.\nUm problema de identificadores muito longos é que as linhas de código também ficam muito longas. Abreviações nos nomes podem ser empregadas, porém de forma criteriosa. Se temperatura é uma escolha clara para guardar um valor de temperatura, temp também pode ser. Porém temp é uma abreviação comum para um valor temporário e, em um contexto de temperaturas, não deve ser empregado.\n\n\n\n\n\n\nDica\n\n\n\nA decisão do comprimento de um identificador envolve clareza do código e a facilidade de visualização do código fonte por um humano. O programador deve balancear esses e quaisquer outros aspectos, sempre com o objetivo de tornar o código o mais inteligível possível.\n\n\nUma amostra de um código com identificadores pobremente escolhidos é apresentando na sequência. A ausência de documentação é proposital neste caso.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 57;\n    int a = 1967;\n\n    int e = a + i;\n    printf(\"%d ou %d\\n\", e, e + 1);\n\n    return 0;\n}\n2024 ou 2025\nSegue agora uma nova versão do mesmo código, para o qual o compilador gera resultados idênticos (e provavelmente códigos executáveis iguais também).\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int idade = 10;\n    int ano_nascimento = 2013;\n\n    int estimativa_ano_atual = ano_nascimento + idade;\n    printf(\"%d ou %d\\n\", estimativa_ano_atual, estimativa_ano_atual + 1);\n\n    return 0;\n}\n2023 ou 2024\nHá claramente uma maior compreensão do propósito do programa nesta segunda versão. Nomes significativos ajudam a entender melhor o contexto como um todo.\nSegue, para fins didáticos, a versão final do código.\n/*\nEstimativa do ano atual dadas a idade e o ano de nascimento de uma pessoa.\nDuas estimativas são feitas, pois o ano corrente depende se a pessoa fez ou \nnão aniversário nesse ano.\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int idade = 10;\n    int ano_nascimento = 2013;\n\n    int estimativa_ano_atual = ano_nascimento + idade;\n    printf(\"%d ou %d\\n\", estimativa_ano_atual, estimativa_ano_atual + 1);\n\n    return 0;\n}\n2023 ou 2024",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variáveis e leituras em C</span>"
    ]
  },
  {
    "objectID": "c-variaveis-identificadores-e-leitura.html#sec-mais-sobre-declaracoes-de-variaveis",
    "href": "c-variaveis-identificadores-e-leitura.html#sec-mais-sobre-declaracoes-de-variaveis",
    "title": "4  Variáveis e leituras em C",
    "section": "4.3 Mais sobre declarações de variáveis",
    "text": "4.3 Mais sobre declarações de variáveis\nNa prática, a atribuição a uma variável não é sempre necessária quando uma declaração é feita e, portanto, pode ser suprimida. Uma declaração simples de uma variável pode ser feita como se segue.\n/*\nEscrevendo o valor de pi com cinco casas decimais\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double pi;\n    \n    pi = 3.141592654;\n    printf(\"pi = %.5f\\n\", pi);\n\n    return 0;\n}\npi = 3.14159\nA variável pi é criada com valor indefinido, mas antes de ser usada no printf tem um valor apropriado atribuído a ela. Sem a atribuição, o conteúdo da variável é considerado indeterminado e, portanto, não deve ser usado antes de se garantir uma atribuição prévia1.\n A declaração segue o formato seguinte.\n\n\n\n\n\n\nDeclaração de variáveis\n\n\n\nespecificação_tipo lista_especificação_identificador ;\n\n\nO tipo base da variável, a especificação_tipo, é o primeiro elemento de uma declaração e é indicado por um tipo já existentes, como int, long int ou double, por exemplo. A lista_especificação_identificador é uma relação de especificações de identificador separados por vírgulas. O ponto e vírgula é obrigatório para indicar o término de uma declaração.\nO exemplo seguinte apresenta declarações de variáveis simples, sem atribuição conjugada.\nint idade;\nint ano;\nDe forma equivalente, essa declaração poderia ser expressa como se segue.\nint idade, ano;\nQualquer uma das duas formas podem ser usadas.\n\n\n\n\n\n\nDica\n\n\n\nUma fonte de erro comum é o uso do valor de uma variável para a qual nenhuma atribuição ainda foi feita, pois seu conteúdo não pode ser previsto.\nO programa seguinte exemplifica esse problema.\n/* \nExemplo de uso de uma variável sem valor previamente atribuído\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double valor;\n    printf(\"valor: %g\\n\", valor);\n\n    return 0;\n}\nvalor: 6.95266e-310\nO valor que é apresentado é efetivamente o conteúdo da variável dado pelos bytes que estão na memória. A saída produzida pelo programa é imprevisível.\n\n\nNa declaração, segundo conveniência, cada variável declarada pode ter sua própria atribuição.\nint dia = 7, mes = 9, ano = 1822;\ndouble salario_inicial = 4321.12, salario_final;\nNeste exemplo, cada uma das três variáveis int são declaradas já com valores iniciais. Para as variáveis double, apenas salario_inicial possui atribuição, enquanto salario_final permanece sem iniciação.\nNos programas em C, todas as variáveis que forem usadas precisam ser declaradas.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variáveis e leituras em C</span>"
    ]
  },
  {
    "objectID": "c-variaveis-identificadores-e-leitura.html#mais-sobre-atribuições",
    "href": "c-variaveis-identificadores-e-leitura.html#mais-sobre-atribuições",
    "title": "4  Variáveis e leituras em C",
    "section": "4.4 Mais sobre atribuições",
    "text": "4.4 Mais sobre atribuições\n A atribuição de um valor a uma variável utiliza a sintaxe seguinte.\n\n\n\n\n\n\nAtribuição\n\n\n\nexpressão_esquerda = expressão_direita\n\n\nNa atribuição, expressão_esquerda indica onde será armazenado o valor resultante de expressão_direita. Para realizar essa operação, inicialmente a expressão_direita é completamente avaliada e, obtido o valor resultante, a expressão_esquerda é considerada para indicar o local de armazenamento na memória. Em geral, expressão_esquerda é somente um identificador de uma variável, enquanto expressão_direita pode ser qualquer expressão cujo resultado tenha tipo compatível.\nNo exemplo seguinte, para cada das duas atribuições, tanto a variável que é usada como local de armazenamento quanto o valor final da expressão que é atribuído a ela são do tipo double.\ndouble valor_cheio, valor_reduzido;\n\nvalor_cheio = 417.8;\nvalor_reduzido = valor_cheio / 3;\nAmbas as atribuições são caracterizadas como comandos simples e, assim, devem ser terminadas com pontos e vírgulas.\n\n\n\n\n\n\nDica\n\n\n\nA atribuição de um valor a uma variável somente deve ser feita se ele for essencial. Uma atribuição desnecessária ou irrelevante pode prejudicar o entendimento do código.\n/* \nApresentação de um cálculo simples\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double fator1 = 1.2;\n    double fator2 = 4.8;\n    double resultado = 0;  // atribuição irrelevante\n\n    resultado = fator1 * fator2;\n    printf(\"%g * %g = %g\\n\", fator1, fator2, resultado);\n\n    return 0;\n}\n1.2 * 4.8 = 5.76\nNesse programa, a atribuição de zero para resultado é irrelevante, pois esse valor será substituído logo na sequência. É curioso notar que poderia ser resultado = -1.2e14 e o programa funcionaria normalmente.\nNeste caso, apenas a declaração simples da variável deve ser feita.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variáveis e leituras em C</span>"
    ]
  },
  {
    "objectID": "c-variaveis-identificadores-e-leitura.html#leitura-para-programas-interativos",
    "href": "c-variaveis-identificadores-e-leitura.html#leitura-para-programas-interativos",
    "title": "4  Variáveis e leituras em C",
    "section": "4.5 Leitura para programas interativos",
    "text": "4.5 Leitura para programas interativos\nAté o momento, a manipulação de variáveis foi exemplificada apenas com atribuições diretas, o que torna o programa demasiadamente restrito. Por exemplo, no exemplo de conversão de Celsius para Fahrenheit, o programa não precisaria fazer as contas nem usar variáveis, pois como tudo é fixo, bastaria conter o comando seguinte e o resultado seria precisamente o mesmo.\nprintf(\"25.5 graus Celsius = 77.9 Fahrenheit\\n\");\nTornar os programas mais úteis, então, requer escrever códigos mais gerais, como para converter qualquer temperatura em graus Celsius para Fahrenheit. Para isso, o programa precisa obter qual o valor que deve ser convertido e isso não pode ser feito por uma atribuição.\nQuando um programa obtém um dado externo ao código, esse processo é chamado de leitura. Desta forma, um programa geralmente faz a leitura de dados, realiza um processamento com eles e escreve os resultados.\nA leitura do que o usuário digita em um terminal usualmente opera em duas etapas. Na primeira, o usuário digita seu texto (podendo eventualmente apagar um erro de digitação) e, quando tiver terminado, ele pressiona a tecla ENTER. Aí se inicia a segunda etapa, que consiste em repassar para o programa todos os caracteres digitados, incluindo a mudança de linha (\\n) produzida pelo ENTER.\n\n4.5.1 Leitura conteúdo textual com fgets\nNo programa seguinte, um nome é solicitado pelo programa e, em seguida, apresentado de volta juntamente com uma saudação.\n/* \nSaudação\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Digite seu nome: \");\n\n    char nome[80];\n    fgets(nome, sizeof nome, stdin);\n\n    printf(\"Olá, %s!\\n\", nome);\n\n    return 0;\n}\nDigite seu nome: Alfonso Cardoso\nOlá, Alfonso Cardoso\n!\nUma variável string é usada para o armazenamento de cadeias de caracteres. Em C, o tipo básico char é usado para indicar uma único caractere; porém, como textos são sequências de caracteres (letras, dígitos, pontuações), os colchetes colocados depois do identificador nome indicam o comprimento máximo de caracteres que a variável suporta. No caso, o programa pode armazenar até 80 caracteres, o que é suficiente para um nome.\nA função fgets (stdio.h) copia o que o usuário digitou no terminal, byte a byte, para a cadeia de caracteres. Esta função possui três parâmetros: o primeiro é para onde os dados digitados serão copiados (variável nome), o segundo é o comprimento da memória disponível para copiar (sizeof nome) e, por final, o último que é stdin, que é o fluxo de bytes vindo do teclado.\nNa execução do programa anterior, é possível notar que a exclamação é apresentada na linha de baixo, logo depois do nome. A razão para isso é que o ENTER também é passado ao programa. Assim, para que se obtenha apenas o nome, é preciso remover esse \\n. Essa ação é feita substituindo-se a mudança de linha por um caractere nulo (\\0).\n/* \nSaudação\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;  // para strlen\n\nint main(void) {\n    printf(\"Digite seu nome: \");\n\n    char nome[80];\n    fgets(nome, sizeof nome, stdin);\n    nome[strlen(nome) - 1] = '\\0';  // sobrepõe '\\0' ao '\\n'\n\n    printf(\"Olá, %s!\\n\", nome);\n\n    return 0;\n}\nDigite seu nome: Alfonso Cardoso\nOlá, Alfonso Cardoso!\nO comando nome[strlen(nome) - 1] = '\\0' determina a posição do \\n usando o comprimento do texto digitado dado por strlen e atribui ali o \\0. É importante notar que '\\0' é escrito usando aspas simples, pois é um único caractere. Esses aspectos são abordados em mais detalhes no Capítulo 16.\n\n\n4.5.2 Leitura de valores numéricos\nToda digitação provida pelo usuário e passada ao programa é textual. Como exemplo, se o usuário digita 10 como entrada, o programa recebe os caracteres 1, 0 e o ENTER, ou seja, \"10\\n\". Para transformar essa sequência de caracteres em um int, por exemplo, é preciso convertê-la.\nA função sscanf pode ser usada para diversas conversões, pois ela analisa os caracteres e os interpreta adequadamente.\nPara exemplificar a leitura de dados numéricos, considere o problema de estimar qual é o ano atual baseado na idade de uma pessoa e de seu ano de nascimento. O cálculo é simples, apesar da resposta depender se a pessoa já fez ou não aniversário no ano atual. Desta forma, o Algoritmo 4.1 dá os dois possíveis resultados.\n\n\nAlgoritmo 4.1: Determinação do ano atual baseado na idade e no ano de nascimento de uma pessoa.\n\n\n\n/*\nDeterminação do ano atual com base na idade e do ano de nascimento de uma\n    pessoa\nRequer: A idade e o ano de nascimento de uma pessoa\nAssegura: As duas possibilidades do ano corrente, considerando se a\n    pessoa já fez ou não aniversário\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Qual sua idade? \");\n    fgets(entrada, sizeof entrada, stdin);\n    int idade;\n    sscanf(entrada, \"%d\", &idade);\n\n    printf(\"Que ano você nasceu? \");\n    fgets(entrada, sizeof entrada, stdin);\n    int ano_nascimento;\n    sscanf(entrada, \"%d\", &ano_nascimento);\n\n    int estimativa_ano_atual = ano_nascimento + idade;\n    printf(\"Se você já fez aniversário este ano, estamos em %d.\\n\",\n        estimativa_ano_atual);\n    printf(\"Se não, o ano é %d.\\n\", estimativa_ano_atual + 1);\n    printf(\"Bem, este é meu chute...\\n\");\n\n    return 0;\n}\nQual sua idade? 20\nQue ano você nasceu? 2003\nSe você já fez aniversário este ano, estamos em 2023.\nSe não, o ano é 2024.\nBem, este é meu chute...\nA linha que merece atenção neste programa é a que segue.\nsscanf(entrada, \"%d\", &idade);\nA função sscanf faz uma varredura na variável entrada (seu primeiro parâmetro), buscando um valor inteiro escrito em decimal (%d). Se achar o valor, faz a interpretação adequada e coloca o valor na variável inteira idade. É importante neste caso que a função precisa saber onde a variável está na memória e, assim, o operador &, que significa algo como “o local onde está”, é obrigatório. A linha de comando pode ser, então, lida da seguinte forma: “procure no texto contido em entrada um valor no formato %d e o armazene na memória onde está a variável idade”.\nPara o ano de nascimento o procedimento é exatamente igual e a variável entrada é reaproveitada para fazer a segunda leitura.\nUma observação relevante é que, na interpretação da linha pela busca do valor inteiro, o sscanf ignora qualquer texto em branco antes dos dígitos numéricos esperados, como espaços e tabulações. Ele também encerra a interpretação ao encontrar qualquer coisa que não seja compatível com o tipo buscado e, desta forma, o \\n no final de entrada é automaticamente ignorado.\nSegue novo exemplo, com leituras simples, agora usando valores reais armazenados em variáveis double.\n/*\nLeitura de variáveis do tipo double\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor real: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double valor1;\n    sscanf(entrada, \"%lf\", &valor1);\n\n    printf(\"Digite outro valor real: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double valor2;\n    sscanf(entrada, \"%lf\", &valor2);\n\n    printf(\"%g + %g = %g\\n\", valor1, valor2, valor1 + valor2);\n\n    return 0;\n}\nDigite um valor real: 872.2\nDigite outro valor real: 1.03e5\n872.2 + 103000 = 103872\nValores do tipo double usam a especificação de formato %lf (%g só é usado no printf) e a interpretação é feita agora pela busca de qualquer combinação que possa ser interpretada como um valor real válido, incluindo a notação científica usada no exemplo.\n\n\n4.5.3 Leitura de um único caractere\nA função fgets, por si só, obtém o texto digitado no terminal. O filtro para que apenas o primeiro caractere seja capturado em uma variável do tipo char pode ser feito também com o sscanf usando-se o indicador de formato %c.\n/*\nLeitura de um valor em uma variável do tipo char com sscanf\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um caractere: \");\n    fgets(entrada, sizeof entrada, stdin);\n\n    char caractere;\n    sscanf(entrada, \"%c\", &caractere);\n    printf(\"O caractere digitado foi o %c\\n\", caractere);\n    printf(\"Seu código hexadecimal ASCII é %X\\n\", caractere);\n\n    return 0;\n}\nDigite um caractere: M\nO caractere digitado foi o M\nSeu código hexadecimal ASCII é 4D\nNo exemplo, na variável entrada é armazenada a sequência M\\n, ou seja o M digitado e o ENTER usado para enviar a linha ao programa. Com o %c do sscanf, somente o primeiro caractere da entrada é considerado, ignorando-se tudo o que existe depois dele. Na prática, depois do M do exemplo poderiam vir quaisquer outros caracteres e somente o primeiro é extraído de entrada.\nPara este exemplo em particular, há uma forma mais simples e direta de obter o primeiro caractere do que o usuário digitou. Isso é feito explicitamente selecionando o primeiro caractere da variável: entrada[0].\n/*\nLeitura de um valor em uma variável do tipo char usando indexação da cadeia\nde entrada\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um caractere: \");\n    fgets(entrada, sizeof entrada, stdin);\n\n    char caractere = entrada[0];\n    printf(\"O caractere digitado foi o %c\\n\", caractere);\n    printf(\"Seu código hexadecimal ASCII é %X\\n\", caractere);\n\n    return 0;\n}\nDigite um caractere: m\nO caractere digitado foi o m\nSeu código hexadecimal ASCII é 6D\nEsta última versão é, na opinião do autor, mais simples e direta, superando a leitura a obtenção do caractere com o sscanf.\n\n\n4.5.4 Várias leituras em uma única linha\nÉ bastante comum, em programas que processam dados, que uma linha possa conter mais que um valor. Desta forma, é preciso indicar ao sscanf para varrer a cadeia de entrada por mais que um valor.\nO programa seguinte implementa o Algoritmo 4.2 e mostra a leitura de coordenadas em \\(\\mathbb{R}^2\\). O programa solicita os valores para \\(x\\) e para \\(y\\), mas ambos devem ser digitados na mesma linha. Como resultado, o programa apresenta a distância desse ponto à origem do sistema de coordenadas.\n\n\nAlgoritmo 4.2: Distância de um ponto \\((x, y)\\) à origem\n\n\n\n/*\nCálculo e apresentação da distância de um ponto em R^2 à origem, tendo como\n    entrada os valores das coordenadas x e y desse ponto\nRequer: x e y\nAssegura: a distância de (x, y) à (0, 0)\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;  // para sqrt (raiz quadrada)\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite os valores de x e y: \");\n    fgets(entrada, sizeof entrada, stdin);\n\n    double x, y;\n    sscanf(entrada, \"%lf%lf\", &x, &y);\n\n    double distancia_origem = sqrt(x * x + y * y);\n    printf(\"A distância de (%g, %g) a (0, 0) é %g.\\n\", x, y, distancia_origem);\n\n    return 0;\n}\nDigite os valores de x e y: 3.2 -1.8\nA distância de (3.2, -1.8) a (0, 0) é 3.67151.\nPrimeiramente é relevante destacar o uso da função sqrt (square root) para o cálculo da raiz quadrada, a qual está especificada no arquivo de cabeçalho math.h, que deve ser incluído no preâmbulo do código fonte. Para o cálculo do quadrado foi usado o “truque” elementar que \\({x^2 = x\\cdot x}\\). Além disso, como biblioteca de funções matemáticas não é automaticamente incluída durante a compilação, deve ser acrescentada a opção -lm (i.e., faça a ligação, link, com a biblioteca matemática m) no final da linha de compilação com o gcc.\nVoltando agora para leitura, o destaque é para a especificação de formato %lf%lf usada no sscanf. Ela indica que dois valores reais devem ser buscados em entrada e cada um deve ser armazenado, respectivamente, nas variáveis x e y, ambas double. A ordem das variáveis deve corresponder à ordem em que os valores são digitados. Como já apresentado, as leituras de valores numéricos ignoram caracteres brancos antes de encontrar o valor em si, de forma que espaços ou tabulações antes de cada %lf são descartadas na varredura da linha, o que significa que, na digitação, a quantidade de espaços antes de cada valor é irrelevante. De forma complementar, tudo o que não corresponder a um valor real que apareça depois do segundo valor também é descartado.\nA mistura de diferentes tipos em uma única linha também é possível, como indica o exemplo na sequência.\n/*\nExemplos de leituras de tipos diferentes em uma mesma linha\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n    double d;\n    int i1, i2;\n    char c;\n\n    printf(\"Digite um inteiro e um real: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%d%lf\", &i1, &d);\n    printf(\"O inteiro é %d e o o real é %g.\\n\\n\", i1, d);\n\n    printf(\"Digite um inteiro, um real e outro inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%d%lf%d\", &i1, &d, &i2);\n    printf(\"Os inteiros são %d e %d; o o real é %g.\\n\\n\", i1, i2, d);\n\n    printf(\"Digite um real seguido por um caractere: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%lf%c\", &d, &c);\n    printf(\"O real é %g e o caractere é %c.\\n\\n\", d, c);\n\n    return 0;\n}\nDigite um inteiro e um real: 320 44.5\nO inteiro é 320 e o o real é 44.5.\n\nDigite um inteiro, um real e outro inteiro: 10 1.1 20\nOs inteiros são 10 e 20; o o real é 1.1.\n\nDigite um real seguido por um caractere: 0.125ee\nO real é 0.125 e o caractere é e.\nExistem, naturalmente e previsivelmente, limitações nas leituras. Por exemplo, a última varredura usando %lf%c para obter um número real e um caractere esbarra na capacidade de análise dos caracteres digitados. Por exemplo, se o usuário digitar 0.1235A é possível separar o 0,125 da letra A; se for digitado 0.125 A, a variável d conterá o valor 0,125, mas c conterá o espaço, que é o próximo caractere depois do número, sendo o A\\n que sobram ignorados. Além disso, é impossível com esse formato que o caractere seja um dígito, pois ele seria interpretado como parte do número e não como o caractere depois do número.\nO contorno de tais limitações foge do escopo deste material.\n\n\n\n4.5.5 Um pouco mais sobre o sscanf\nO objetivo da função sscanf é analisar uma cadeia de caracteres procurando por padrões, os quais, reconhecidos adequadamente, são convertidos para o tipo indicado e atribuído às variáveis indicadas por seus endereços (razão do operador & usado nos exemplos diversos). Assim, ao se especificar %d%d%lf o sscanf espera encontrar dois inteiros e um real, nesta ordem. Para sumarizar, a Tabela 4.2 apresenta as principais especificações de formato usadas no sscanf.\n\n\n\nTabela 4.2: Relação entre formatos e tipos utilizados pelo sscanf.\n\n\n\n\n\nEspecificação\nTipo associado\n\n\n\n\n%d\nint\n\n\n%ld\nlong int\n\n\n%f\nfloat\n\n\n%lf\ndouble\n\n\n%c\nchar\n\n\n%s\nchar[\\(n\\)]\n\n\n\n\n\n\n\nSobre os padrões interpretados no sscanf\nO padrão especificado no segundo parâmetro da função sscanf é muito mais poderoso do que apenas a busca por números ou caracteres. Seguem alguns poucos exemplos sobre a versatilidade do sscanf na sua interpretação.\n/*\nCálculo e apresentação da distância de um ponto em R^2 à origem, tendo como\n    entrada os valores das coordenadas x e y desse ponto\nRequer: o ponto (x, y)\nAssegura: a distância de (x, y) à (0, 0)\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um ponto no formato (x, y): \");\n    fgets(entrada, sizeof entrada, stdin);\n\n    double x, y;\n    sscanf(entrada, \"(%lf,%lf)\", &x, &y);\n\n    double distancia_origem = sqrt(x * x + y * y);\n    printf(\"A distância de (%g, %g) a (0, 0) é %g.\\n\", x, y, distancia_origem);\n\n    return 0;\n}\nDigite um ponto no formato (x, y): (3.2, -1.8)\nA distância de (3.2, -1.8) a (0, 0) é 3.67151.\nEste exemplo é uma releitura do programa que calcula a distância de um ponto à raiz, com referência ao Algoritmo 4.2. Nesta nova versão, a digitação da entrada deve seguir o formato convencional de representação de um ponto no plano, ou seja, circundar os valores com parênteses e usar uma vírgula para separar os \\(x\\) de \\(y\\). O padrão que foi dado é (%lf,%lf), o que significa que a função espera, nesta sequência, um abre parênteses, um valor real, uma vírgula, outro valor real e um fecha parênteses. O conteúdo provavelmente não será interpretado corretamente se o padrão não for completamente satisfeito.\nO padrão de interpretação pode indicar que um dado valor será ignorado da interpretação. Para isso, um asterisco deve ser adicionado logo depois do símbolo %. Por exemplo, %*lf significa que um valor real deve ser reconhecido, mas seu valor será descartado. O exemplo seguinte mostra como, de uma linha com dois valores inteiros, utilizar apenas o segundo.\n/*\nLeitura de uma linha com quatro inteiros, porém descartando o primeiro e\no terceiro\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite quatro valores inteiros: \");\n    fgets(entrada, sizeof entrada, stdin);\n\n    int segundo, quarto;\n    sscanf(entrada, \"%*d%d%*d%d\", &segundo, &quarto);\n\n    printf(\"Valores de interesse: %d e %d.\\n\", segundo, quarto);\n\n    return 0;\n}\nDigite quatro valores inteiros: 6652 943 7609 -7\nValores de interesse: 943 e -7.\n\n\nInterpretação em bases decimal, octal e hexadecimal\nAlém dos valores inteiros em decimal (%d), é possível interpretá-los nas bases 8 e 16. Nestes dois últimos casos, os valores devem ser sempre positivos e, para tanto, o tipo da variável tem que ser unsigned int, ou seja, um inteiro sem sinal.\n/*\nLeituras de valores inteiros nas bases decimal, octal e hexadecimal (10, 8\ne 16, respectivamente)\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n    unsigned int valor;\n\n    printf(\"Digite inteiro decimal: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%u\", &valor);\n    printf(\"O valor é %d(10), %o(8) e %X(16).\\n\\n\", valor, valor, valor);\n\n    printf(\"Digite inteiro octal: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%o\", &valor);\n    printf(\"O valor é %d(10), %o(8) e %X(16).\\n\\n\", valor, valor, valor);\n\n    printf(\"Digite inteiro hexadecimal: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%x\", &valor);\n    printf(\"O valor é %d(10), %o(8) e %X(16).\\n\\n\", valor, valor, valor);\n\n    return 0;\n}\nDigite inteiro decimal: 63\nO valor é 63(10), 77(8) e 3F(16).\n\nDigite inteiro octal: 63\nO valor é 51(10), 63(8) e 33(16).\n\nDigite inteiro hexadecimal: 63\nO valor é 99(10), 143(8) e 63(16).\nOs dígitos 6 e 3 são dígitos válidos nas três bases exemplificadas e 6310, 638 e 6316 têm sua interpretação descrita na Tabela 4.3. A conversão do valor digitado depende do formato expresso no sscanf: decimal (%d), octal (%o) ou hexadecimal (%x). A escolha de um dos formatos invalida a interpretação dos outros dois.\n\n\n\nTabela 4.3: Interpretação dos dígitos 63 nas bases decimal, octal e hexadecimal.\n\n\n\n\n\n\n\n\n\n\nValor\nInterpretação\nValor decimal equivalente\n\n\n\n\n6310\n6 \\(\\times\\) 101 + 3 \\(\\times\\) 100\n63\n\n\n638\n6 \\(\\times\\) 81 + 3 \\(\\times\\) 80\n51\n\n\n6316\n6 \\(\\times\\) 161 + 3 \\(\\times\\) 160\n99\n\n\n\n\n\n\nÉ possível dar liberdade ao usuário na escolha da base que será usada. A especificação de formato %i significa um valor inteiro, independente da base. Valores decimais são, como esperado, interpretados como decimais; valores iniciados com 0 são interpretados como números octais e os precedidos da sequência 0x são considerados na base 16.\n/*\nLeituras genérica de valores inteiros\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n    int valor;\n\n    printf(\"Digite inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%i\", &valor);\n    printf(\"O valor é %d(10), %o(8) e %X(16).\\n\\n\", valor, valor, valor);\n\n    printf(\"Digite inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%i\", &valor);\n    printf(\"O valor é %d(10), %o(8) e %X(16).\\n\\n\", valor, valor, valor);\n\n    printf(\"Digite inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%i\", &valor);\n    printf(\"O valor é %d(10), %o(8) e %X(16).\\n\\n\", valor, valor, valor);\n\n    return 0;\n}\nDigite inteiro: 63\nO valor é 63(10), 77(8) e 3F(16).\n\nDigite inteiro: 063\nO valor é 51(10), 63(8) e 33(16).\n\nDigite inteiro: 0x63\nO valor é 99(10), 143(8) e 63(16).\nNeste exemplo, 63 é o decimal 63, 063 é 638 e 0x63 é 6316.\n\n\nErros de interpretação do padrão\nA função sscanf é capaz de interpretar corretamente um valor numérico tanto quanto o valor faça sentido. Se houver um erro na interpretação, a análise da varredura é interrompida e o valores corretamente convertidos são atribuídos às respectivas variáveis; as variáveis restantes não têm seu valor modificado.\nO exemplo seguinte apresenta a situação de duas leituras\n/*\nLeituras corretas e incorretas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Valores iniciais\n    int i1 = 1, i2 = 2, i3 = 3, i4 = 4;\n    printf(\"i1 = %d; i2 = %d; i3 = %d; i4 = %d.\\n\\n\", i1, i2, i3, i4);\n\n    // Leitura 1\n    printf(\"Digite os valores para i1, i2, i3 e i4: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%d%d%d%d\", &i1, &i2, &i3, &i4);\n    printf(\"i1 = %d; i2 = %d; i3 = %d; i4 = %d.\\n\\n\", i1, i2, i3, i4);\n\n    // Leitura 2\n    printf(\"Digite os valores para i1, i2, i3 e i4: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%d%d%d%d\", &i1, &i2, &i3, &i4);\n    printf(\"i1 = %d; i2 = %d; i3 = %d; i4 = %d.\\n\\n\", i1, i2, i3, i4);\n\n    return 0;\n}\ni1 = 1; i2 = 2; i3 = 3; i4 = 4.\n\nDigite os valores para i1, i2, i3 e i4: 10 20 30 40\ni1 = 10; i2 = 20; i3 = 30; i4 = 40.\n\nDigite os valores para i1, i2, i3 e i4: 100 200 abc 400\ni1 = 100; i2 = 200; i3 = 30; i4 = 40.\nNa primeira leitura do programa, todos os valores são lidos corretamente e todas as atribuições são feitas. Na segunda leitura a varredura falha ao encontrar abc quando um número inteiro era esperado. Com o erro na interpretação, apenas i1 e i2 são atualizados, enquanto i3 e i4 não têm seus valores modificados.\n\n\nsscanf é uma função e tem valor de retorno\nEmbora frequentemente usada como um comando simples, sscanf é, na realidade, uma função que retorna o número de leituras corretamente realizadas. Com essa característica, é possível contornar erros de leitura e deixar o código mais robusto.\n/*\nVerificação de leituras corretas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite os valores para i1, i2, i3 e i4: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int i1, i2, i3, i4;\n    int numero_atribuicoes = sscanf(entrada, \"%d%d%d%d\", &i1, &i2, &i3, &i4);\n    printf(\"i1 = %d; i2 = %d; i3 = %d; i4 = %d.\\n\\n\", i1, i2, i3, i4);\n    printf(\"Na leitura feita, %d valores foram corretamente lidos.\\n\",\n        numero_atribuicoes);\n\n    return 0;\n}\nDigite os valores para i1, i2, i3 e i4: 10 20 abc 40\ni1 = 10; i2 = 20; i3 = -1; i4 = 64.\n\nNa leitura feita, 2 valores foram corretamente lidos.\nCom apenas dois valores corretamente lidos, a execução do programa mostra que os valores originais de i3 e i4 são preservados. Essas variáveis recaem na categoria variáveis não iniciadas, como exemplificado em uma das dicas da Seção 4.3.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variáveis e leituras em C</span>"
    ]
  },
  {
    "objectID": "c-variaveis-identificadores-e-leitura.html#ressalvas-quanto-ao-scanf",
    "href": "c-variaveis-identificadores-e-leitura.html#ressalvas-quanto-ao-scanf",
    "title": "4  Variáveis e leituras em C",
    "section": "4.6 Ressalvas quanto ao scanf",
    "text": "4.6 Ressalvas quanto ao scanf\nEm grande parte do material disponível em páginas na Internet é comum que a leitura use a função scanf no lugar de um fgets seguido de um sscanf. O objetivo da função scanf é aplicar as especificações de formato diretamente na entrada de dados, sem usar a variável entrada como nos exemplos apresentados.\nEssa prática de usar diretamente scanf leva a uma dificuldade muito grande quando leituras de cadeias de caracteres e de valores numéricos, visto que essa função varre o que foi digitado, porém mantém o que ainda não foi analisado. O próprio manual do scanf apresenta o conteúdo seguinte.\nThe scanf() family  of functions scans input like sscanf(3), but read\nfrom a FILE.  It is very difficult to use  these  functions  correctly,\nand  it  is preferable to read entire lines with fgets(3) or getline(3)\nand parse them later with sscanf(3) or more specialized functions  such\nas strtol(3).\nTraduzindo livremente as partes mais relevantes: “é muito difícil usar essas funções corretamente”; “é preferível ler linhas inteiras com fgets (…) e analisá-las com sscanf (…)”. Em outras palavras, o uso de scanf diretamente exige conhecimento mais detalhado de como o fluxo de entrada é tratado e, desta forma, foi substituído por outros comandos, conforme a recomendação do próprio manual.\n O texto também dá como alternativas getline (muito similar a fgets), e strtol (com os mesmos objetivos de sscanf). A função getline tem os mesmos parâmetros de fgets e pode ser usada sem seu lugar, mas tem vantagens quando se usa memória alocada dinamicamente. Por sua vez, strtol é também interessante, mas exige o uso de ponteiros e o entendimento de endereçamento de memória.\nO emprego de getline e strtol em substituição a fgets e sscanf é uma sugestão interessante para quando os conceitos de alocação dinâmica de memória e ponteiros fizerem parte dos conhecimentos do programador. Ponteiros são tratados no Capítulo 20, enquanto o ?sec-alocacao-dinamica-de-memoria aborda a alocação dinâmica de memória.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variáveis e leituras em C</span>"
    ]
  },
  {
    "objectID": "c-variaveis-identificadores-e-leitura.html#sobre-a-função-gets",
    "href": "c-variaveis-identificadores-e-leitura.html#sobre-a-função-gets",
    "title": "4  Variáveis e leituras em C",
    "section": "4.7 Sobre a função gets",
    "text": "4.7 Sobre a função gets\n Infelizmente, quando se procura por informações sobre leitura de dados em C nos diversos mecanismos de busca, ainda são comuns os exemplos usando a função gets. Esta função é uma “versão simplificada” de fgets que não precisa informar o espaço de memória disponível para a leitura nem requer a especificação do stdin, que é usado automaticamente.\nO problema desta função é exatamente a falta de especificação da área de memória disponível, pois a leitura não respeita qualquer limite e pode sobrescrever outras áreas importantes da memória, modificando indiretamente outras variáveis e até as instruções que serão executadas.\nO exemplo seguinte mostra o uso, a compilação e o resultado de uma leitura usando gets.\n/*\nLeitura de um texto com gets\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite algo: \");\n    gets(entrada);\n    printf(\"Você digitou: '%s'\\n\", entrada);\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:10:5: warning: implicit declaration of function ‘gets’; did you \nmean ‘fgets’? [-Wimplicit-function-declaration]\n   10 |     gets(entrada);\n      |     ^~~~\n      |     fgets\n/usr/bin/ld: /tmp/ccrhOi7P.o: na função \"main\":\nmain.c:(.text+0x42): aviso: the `gets' function is dangerous and should not \nbe used.\nDigite algo: C é legal, mas não é simples...\nVocê digitou: 'C é legal, mas não é simples...'\nDa compilação desse programa, o destaque é feito para a linha com o aviso: “a função gets é perigosa e não deve ser usada”.\nAlém dessa recomendação do próprio compilador, há ainda no manual da função o trecho reproduzido na sequência. Nesse segmento do texto, o destaque é para a sentença: “nunca use esta função”.\nDESCRIPTION\n       Never use this function.\n\n       gets()  reads  a  line from stdin into the buffer pointed to by s until\n       either a terminating newline or EOF, which it replaces with a null byte\n       ('\\0').  No check for buffer overrun is performed (see BUGS below).\nPara deixar bem claras as consequências dessa função, considere o programa seguinte. Nele, o tamanho disponível para entrada é de 20 bytes, o que limita o texto máximo a 19. Também foi acrescentada uma variável inteira, usada apenas para ilustrar o problema.\n/*\nLeitura de um texto com gets\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[20];\n    int valor = 10;\n\n    printf(\"'valor' vale %d\\n\", valor);\n    printf(\"Digite algo: \");\n    gets(entrada);\n    printf(\"Você digitou: '%s'\\n\", entrada);\n    printf(\"'valor' vale %d\\n\", valor);\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:12:5: warning: implicit declaration of function ‘gets’; did you \nmean ‘fgets’? [-Wimplicit-function-declaration]\n   12 |     gets(entrada);\n      |     ^~~~\n      |     fgets\n/usr/bin/ld: /tmp/ccTRemiH.o: na função \"main\":\nmain.c:(.text+0x5c): aviso: the `gets' function is dangerous and should not \nbe used.\n*** stack smashing detected ***: terminated\nKilled\n\n[Programa encerrado com código 137]\nÉ importante reparar que o código permite, inadvertidamente, que a variável inteira valor tenha seus bytes modificados pela insegurança de gets. Dado que não há verificação do espaço disponível para armazenar a leitura, os bytes digitados pelo usuário ultrapassam os 20 bytes de entrada e destroem os bytes de valor. Este programa aparentemente não tem problemas, até que uma entrada seja maior que o espaço disponível.\nA conclusão simples e prática desta seção é, portanto, não usar gets. Nunca.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variáveis e leituras em C</span>"
    ]
  },
  {
    "objectID": "c-variaveis-identificadores-e-leitura.html#footnotes",
    "href": "c-variaveis-identificadores-e-leitura.html#footnotes",
    "title": "4  Variáveis e leituras em C",
    "section": "",
    "text": "Mais detalhes sobre valores iniciais de variáveis são apresentados no Capítulo 19.↩︎",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Variáveis e leituras em C</span>"
    ]
  },
  {
    "objectID": "c-expressoes-aritmeticas.html",
    "href": "c-expressoes-aritmeticas.html",
    "title": "5  Expressões aritméticas de C",
    "section": "",
    "text": "5.1 Operadores aritméticos\nUma coisa que um computador consegue fazer com eficiência são contas e faz isso muito rapidamente. Nesta parte são tratados os principais aspectos dos cálculos feitos por programas escritos em C.\nUma expressão aritmética é aquela que envolve valores numéricos e, pelo uso operadores, produzem um resultado também numérico. Um exemplo de uma expressão aritmética é o cálculo do discriminante \\({b^2 - 4ac}\\), referente a uma equação de segundo grau \\({ax^2 + bx + c = 0}\\) (\\(a\\neq 0\\)).\nA linguagem C dispõe dos operadores aritméticos tradicionais para soma, subtração, multiplicação e divisão. Como na matemática, os operadores possuem prioridades entre si, sendo que multiplicações e divisões tem precedência sobre somas e subtrações. Os operadores aritméticos são apresentados na Tabela 5.1.\nO programa seguinte exemplifica o uso dos operadores para valores inteiros.\nO resultado da execução é, em grande parte, o esperado. Há, porém, um detalhe importante relativo à divisão. Seria esperado que a expressão 15 / 6 resultasse em aproximadamente 2,14286, porém o resultado foi 2. Em C, a divisão de um inteiro por outro resulta em outro inteiro; a parte decimal resultante da divisão é ignorada. Desta forma, 3 / 2 é igual a 1, 20 / 6, 32 / 6 é calculado como 5 e 999 / 1000 resulta em zero. Não são feitos arredondamentos; a parte inteira é truncada.\nO operador % é o não tão conhecido operador modular, escrito \\(k\\) mod \\(n\\), e que corresponde ao resto da divisão de \\(k\\) por \\(n\\). No exemplo, 15 % 6 é o resto da divisão de 15 por 6, ou seja, 3.\nA multiplicação é indicada pelo *, que deve sempre ser explícito. Nas equações matemáticas, a ausência do operador é imediatamente associada à multiplicação (\\(xy\\) significa \\(x\\) multiplicado por \\(y\\)). Em C, deve-se sempre escrever x * y.\nNa sequência é apresentado um programa usando os operadores aritméticos com dados do tipo double.\nQuando os operadores são usados em valores reais (double), os resultados são os esperados da matemática. Como a aritmética modular é aplicada exclusivamente a valores inteiros, o operador % é inválido quando os operandos são double.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Expressões aritméticas de C</span>"
    ]
  },
  {
    "objectID": "c-expressoes-aritmeticas.html#operadores-aritméticos",
    "href": "c-expressoes-aritmeticas.html#operadores-aritméticos",
    "title": "5  Expressões aritméticas de C",
    "section": "",
    "text": "Tabela 5.1: Operadores aritméticos. A ordem precedência vai de 1 (maior precedência) a 3 (menor precedência). A associatividade pode ser da esquerda para a direita (\\(\\rightarrow\\)) ou da direita para a esquerda (\\(\\leftarrow\\)).\n\n\n\n\n\n\n\n\n\n\n\n\nOperador\nDescrição\nPrecedência\nSintaxe\nAssociatividade\n\n\n\n\n+ (unário)\nMantém o sinal do operando seguinte\n1\n+a\n\\(\\leftarrow\\)\n\n\n- (unário)\nAlteração do sinal do operando seguinte\n1\n-a\n\\(\\leftarrow\\)\n\n\n*\nMultiplicação de dois operandos\n2\na * b\n\\(\\rightarrow\\)\n\n\n/\nDivisão do operando esquerdo pelo direito\n2\na / b\n\\(\\rightarrow\\)\n\n\n%\nMódulo do operando direito pelo esquerdo\n2\na % b\n\\(\\rightarrow\\)\n\n\n+ (binário)\nSoma de dois operandos\n3\na + b\n\\(\\rightarrow\\)\n\n\n- (binário)\nSubtração do operando direito do esquerdo\n3\na - b\n\\(\\rightarrow\\)\n\n\n\n\n\n\n\n/*\nOperadores aritméticos com argumentos inteiros\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int operando1 = 15;\n    int operando2 = 6;\n\n    printf(\"Operandos em uso: op1 = %d e op2 = %d.\\n\", operando1, operando2);\n    printf(\"+op1 = %d\\n\", +operando1);\n    printf(\"-op1 = %d\\n\", -operando1);\n    printf(\"op1 * op2 = %d\\n\", operando1 * operando2);\n    printf(\"op1 / op2 = %d\\n\", operando1 / operando2);\n    printf(\"op1 + op2 = %d\\n\", operando1 + operando2);\n    printf(\"op1 - op2 = %d\\n\", operando1 - operando2);\n    printf(\"op1 %% op2 = %d\\n\", operando1 % operando2);\n\n    return 0;\n}\nOperandos em uso: op1 = 15 e op2 = 6.\n+op1 = 15\n-op1 = -15\nop1 * op2 = 90\nop1 / op2 = 2\nop1 + op2 = 21\nop1 - op2 = 9\nop1 % op2 = 3\n\n\n\n\n\n\n\n\n\nAritmética modular\n\n\n\nA aritmética modular, que é um sistema para inteiros, corresponde números cíclicos. Para módulo 3, por exemplo, os números são sequencialmente 0, 1, 2, 0, 1, 2, 0,…, ciclicamente. Assim, para se chegar ao 7, a sequência seria 1, 2, 0, 1, 2, 0, 1. Nesta contagem, 3 \\(\\equiv\\) 0 (mod 3), pois ambos chegam ao zero no final. Ainda tem-se 1 \\(\\equiv\\) 4 (mod 3), 2 \\(\\equiv\\) 5 (mod 3) e 2 \\(\\equiv\\) 8 (mod 3), por exemplo.\nUm exemplo prático de contagem modular é o relógio de 12 horas, que inicia às 0h e, quando chegaria às 12h, volta a contar do zero novamente. Se o relógio marca, por exemplo, 9h, depois de cinco horas ele marcará 2h, pois opera mod 12. Ou seja, (9 + 5) \\(\\equiv\\) 2 (mod 12).\nO operador módulo, denotado por \\(k\\) mod \\(n\\), corresponde a um inteiro único \\(r\\) tal que 0 \\({\\leq r \\leq n}\\) e \\(r \\equiv n\\) (mod \\(n\\)).\nA consequência prática e útil da operação modular na computação é que, para valores inteiros positivos, a % b corresponde ao resto da divisão inteira de a por b. Assim, 8546 % 43 resulta em 32, ou seja, 8546 dividido por 43 é 198 com resto 32.\n\n\n\n/*\nOperadores aritméticos com argumentos inteiros\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double operando1 = 12.5;\n    double operando2 = 3.8;\n\n    printf(\"Operandos em uso: op1 = %g e op2 = %g.\\n\", operando1, operando2);\n    printf(\"+op1 = %g\\n\", +operando1);\n    printf(\"-op1 = %g\\n\", -operando1);\n    printf(\"op1 * op2 = %g\\n\", operando1 * operando2);\n    printf(\"op1 / op2 = %g\\n\", operando1 / operando2);\n    printf(\"op1 + op2 = %g\\n\", operando1 + operando2);\n    printf(\"op1 - op2 = %g\\n\", operando1 - operando2);\n\n    return 0;\n}\nOperandos em uso: op1 = 12.5 e op2 = 3.8.\n+op1 = 12.5\n-op1 = -12.5\nop1 * op2 = 47.5\nop1 / op2 = 3.28947\nop1 + op2 = 16.3\nop1 - op2 = 8.7\n\n\n5.1.1 Ordem de avaliação\nA ordem de avaliação de uma expressão aritmética em C pode ser traiçoeira. Embora, em grande parte das vezes, o valor de uma expressão seja direto, há um não tão pequeno número de situações em que o programador pode se equivocar.\nPara avaliar uma expressão, o compilador usa os seguintes passos de decisão:\n\nPara operadores com precedências diferentes, a ordem da precedência é seguida;\nPara operadores de mesma precedência, a associatividade é seguida.\n\nPor exemplo, na expressão a + b * c, b * c é avaliado primeiro, sendo a soma realizada em um segundo momento.\nPara a expressão a * b * c + d * e, a ordem de avaliação é:\n\nPrimeiro ocorre a multiplicação de a por b, gerando um resultado intermediário \\(r_1\\);\nDepois, \\(r_1\\) é multiplicado por c (\\(r_2\\));\nComo a multiplicação tem precedência sobre a soma, d e e são multiplicados (\\(r_3\\));\nPor fim, \\(r_2\\) e \\(r_3\\) são somados.\n\nA ordem de avaliação, portanto, é (((a * b) * c) + (d * e)), embora se saiba que a ordem de multiplicação dos três primeiros termos não interfira no resultado.\nFelizmente, para os operadores de soma, subtração e multiplicação, a ordem seguida pelo compilador é normalmente a esperada.\nQuando há uma divisão, uma margem para erros acaba se apresentando. Como exemplo, pode-se considerar a expressão a * b / c * d, na qual todos os operadores possuem a mesma ordem de precedência, mas diferentes ordens de avaliação levam a resultados distintos. Para este caso, a ordem de avaliação é:\n\nÉ feita inicialmente a multiplicação de a por b (\\(r_1\\));\nEm seguida, \\(r_1\\) é dividido por c, resultando \\(r_2\\);\nPor último, é feita a multiplicação de \\(r_2\\) por d, gerando o resultado final.\n\nA ordem de avaliação segue a associatividade dos operadores de mesma precedência, que neste caso é da esquerda para a direita. Assim, a * b / c * d é avaliado como (((a * b) / c) * d).\n\n\n5.1.2 Quebra da ordem de precedência e da associatividade\nConhecido o procedimento usado pelo compilador para avaliar uma expressão aritmética, fica expressa a necessidade de, por vezes, escolher uma ordem diferente. A linguagem C usa os parênteses para definir a ordem de avaliação. Um exemplo importante e simples é o cálculo media: (v1 + v2)/2. Sem os parênteses, apenas v2 seria dividido por 2.\nApenas parênteses são usados nas expressões, pois colchetes e chaves servem a outros propósitos na linguagem.\nConsiderando a, título de exemplo, que uma variável real discriminante contenha o valor \\(b^2 - 4ac\\) correspondente a uma equação de segundo grau \\({ax^2 + bx + c = {}}\\) 0 (\\(a \\neq\\) 0), a Tabela 5.2 mostra tentativas de escrever o cálculo de uma das raízes da equação, considerando que o discriminante seja não negativo.\n\n\n\nTabela 5.2: Exemplos de tentativas de código para calcular uma raiz de uma equação de segundo grau com discriminante \\(\\Delta \\geq 0\\).\n\n\n\n\n\n\n\n\n\n\nExpressão do código\nExpressão equivalente\nResultado\n\n\n\n\n-b - sqrt(discriminante) / 2 * a\n\\(-b - \\dfrac{\\sqrt{\\Delta}}{2} a\\)\nIncorreto\n\n\n-b - sqrt(discriminante) / (2 * a)\n\\(-b - \\dfrac{\\sqrt{\\Delta}}{2a}\\)\nIncorreto\n\n\n(-b - sqrt(discriminante)) / 2 * a\n\\(\\dfrac{-b - \\sqrt{\\Delta}}{2} a\\)\nIncorreto\n\n\n(-b - sqrt(discriminante))  /  2*a\n\\(\\dfrac{-b - \\sqrt{\\Delta}}{2} a\\)\nIncorreto\n\n\n(-b - sqrt(discriminante)) / (2 * a)\n\\(\\dfrac{-b - \\sqrt{\\Delta}}{2a}\\)\nCorreto\n\n\n(-b - sqrt(discriminante)) / 2 / a\n\\(\\dfrac{-b - \\sqrt{\\Delta}}{2a}\\)\nCorreto\n\n\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nEm C, o compilador ignora os espaços entre os operadores. A ordem que vale é a da precedência, em primeiro lugar, e da associatividade, para precedências iguais. Dessa forma, é indiferente para o compilador escrever a/b*c, a / b * c ou a / b*c, pois todas serão avaliadas ((a / b) * c).\nMesmo que desnecessário, muitas vezes o uso dos parênteses para deixar clara a ordem de avaliação que o programador deseja ajuda na legibilidade e entendimento do código fonte.\nPor exemplo, é comum, no lugar de elevar um valor ao quadrado, usar a multiplicação dele por ele mesmo. Uma expressão que usa esse recurso, por exemplo, seria \\(a^2(b+c)^2\\), que poderia ser escrita (a * a) * ((b + c) * (b + c)), mesmo que a * a * (b + c) * (b + c) seja exatamente equivalente. Os parênteses servem apenas para ênfase.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Expressões aritméticas de C</span>"
    ]
  },
  {
    "objectID": "c-expressoes-aritmeticas.html#expressões-inteiras-vs.-reais-promoção-de-tipo",
    "href": "c-expressoes-aritmeticas.html#expressões-inteiras-vs.-reais-promoção-de-tipo",
    "title": "5  Expressões aritméticas de C",
    "section": "5.2 Expressões inteiras vs. reais (promoção de tipo)",
    "text": "5.2 Expressões inteiras vs. reais (promoção de tipo)\nAs expressões aritméticas envolvem valores numéricos, mas C pode tratar de forma diferente valores numéricos inteiros (int) e reais (double). Um exemplo é a divisão, que resulta em valores diferentes para 18/7 e 18.0/7.0, por exemplo, ou o operador modular %, que não pode ser usado para valores reais.\nPara iniciar o entendimento de como expressões com tipos diferentes são tratadas, o exemplo da conversão de temperaturas do Algoritmo 1.2 é revisitado.\n/* \nConversão de escalas termométricas, de graus Celsius para Fahrenheit\nRequer: valor da temperatura em graus Celsius\nAssegura: valor da temperatura em Fahrenheit\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Temperatura em Celsius: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double temperatura_celsius;\n    sscanf(entrada, \"%lf\", &temperatura_celsius);\n\n    double temperatura_fahrenheit = 1.8 * temperatura_celsius + 32;\n    printf(\"%g graus Celsius = %g Fahrenheit.\\n\", temperatura_celsius,\n        temperatura_fahrenheit);\n\n    return 0;\n}\nTemperatura em Celsius: 23.5\n23.5 graus Celsius = 74.3 Fahrenheit.\nO interesse neste programa está na expressão que faz a conversão de escalas termométricas.\ndouble temperatura_fahrenheit = 1.8 * temperatura_celsius + 32;\nA expressão multiplica um valor double, o 1,8 por outro também double, resultando em um valor intermediário que mantém o tipo dos operandos. Em seguida, o valor 32 é somado, mas esse valor é do tipo int.\nA questão é que claramente int somado com int resulta em int e, de modo análogo, a soma de double resulta em double. Como o compilador pode, então, lidar com a soma de um double com um int?\nQuando uma expressão envolve tipos diferentes, um mecanismo conhecido como promoção de tipo é empregado. A promoção segue o princípio de que, se os tipos são diferentes, o “menor” deve ser promovido ao tipo do “maior”. Neste caso, “menor” e “maior” se referem à capacidade de armazenamento dos tipos envolvidos. Assim, um double é considerado “maior” (mais abrangente) que um int (mais restrito). Essa análise é feita a cada operação.\nRetornando ao caso da soma de um double com um int, primeiramente o int é convertido para double e, então, a soma é feita, resultando evidentemente em double.\nMuitas vezes a expressão usada para a conversão de Celsius para Fahrenheit é dada na forma \\({t_f = \\frac{9}{5}t_c + 32}\\). Usando-se essa configuração, talvez fosse possível substituir a linha do cálculo no programa pela versão seguinte.\ndouble temperatura_fahrenheit = 9 / 5 * temperatura_celsius + 32;  // incorreta!\nEssa expressão apresenta um erro no cálculo. Considerando-se que a divisão e a multiplicação possuem a mesma precedência, a expressão é avaliada da esquerda para a direita, de forma que 9 / 5 é calculada primeiro, para então multiplicar por temperatura_celsius. O problema é que 9 / 5 é igual a 1, pois ambos os operadores são inteiros. Da forma que está escrita, o valor efetivamente atribuído é 1 * temperatura_celsius + 32.\nÉ nítida a consequência da ordem das operações no resultado final, o que leva a uma nova versão para a expressão.\ndouble temperatura_fahrenheit = temperatura_celsius * 9 / 5 + 32;  // correta!\nSeguindo a ordem de avaliação, a primeira operação realizada é a multiplicação de temperatura_celsius por 9, sendo o primeiro operando double e o segundo, int. Aplicada a promoção do 9 para 9.0, a multiplicação é feita, com um resultado do tipo double. Quando é feita a divisão por 5, novamente o segundo operando é promovido (de 5 para 5.0) e novamente se obtém um resultado double. Finalmente a soma é feita, havendo uma nova promoção (do 32), obtendo-se o resultado final. É importante notar que o problema da divisão inteira foi evitado, uma vez que, em nenhum momento, a divisão teve que lidar com dois valores int.\nUm novo exemplo segue, o qual tem que lidar com conversões de tipo. O programa implementa o Algoritmo 5.1.\n\n\nAlgoritmo 5.1: Cálculo de porcentagens considerando o montante de votos.\n\n\n\n/*\nCálculo simples de porcentagens em uma pesquisa com as seguintes \n    possibilidades de resposta: sim, não e não sei. A pergunta feita é\n    irrelevante.\nRequer: a quantidade de votos sim, não e não sei.\nAssegura: as quantidades de votos e respectivas as porcentagens,\n    exibidas no intervalo [0, 1], de cada opção de voto\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Obtenção das quantidades\n    printf(\"Número de respostas SIM: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int quant_votos_sim;\n    sscanf(entrada, \"%d\", &quant_votos_sim);\n\n    printf(\"Número de respostas NÃO: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int quant_votos_nao;\n    sscanf(entrada, \"%d\", &quant_votos_nao);\n\n    printf(\"Número de respostas NÃO SEI: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int quant_votos_nao_sei;\n    sscanf(entrada, \"%d\", &quant_votos_nao_sei);\n\n    // Cálculo das porcentagens (COM ERROS)\n    int quant_total = quant_votos_sim + quant_votos_nao + quant_votos_nao_sei;\n\n    double porcentagem_sim = quant_votos_sim / quant_total;\n    double porcentagem_nao = quant_votos_nao / quant_total;\n    double porcentagem_nao_sei = quant_votos_nao_sei / quant_total;\n\n    // Resultados\n    printf(\"Sim: %d votos (%.2f).\\n\", quant_votos_sim, porcentagem_sim);\n    printf(\"Não: %d votos (%.2f).\\n\", quant_votos_nao, porcentagem_nao);\n    printf(\"Não sei: %d votos (%.2f).\\n\", quant_votos_nao_sei,\n           porcentagem_nao_sei);\n\n    return 0;\n}\nNúmero de respostas SIM: 852\nNúmero de respostas NÃO: 432\nNúmero de respostas NÃO SEI: 73\nSim: 852 votos (0.00).\nNão: 432 votos (0.00).\nNão sei: 73 votos (0.00).\nO exemplo mostra que todas as porcentagens foram calculadas como zero e o problema é a divisão de dois inteiros. A divisão inteira ocorre antes da atribuição, pois toda a expressão já foi calculada. Mesmo com um resultado inteiro, há uma promoção para double ao se fazer a atribuição, dado o tipo da variável.\nAgora o problema é fazer com que a divisão de dois inteiros resulte em um valor real. Para isso pode ser empregada uma promoção de tipo explícita, usando o que é chamado type cast em C. Um cast de tipo é indicado pelo tipo desejado colocado entre parênteses antes do valor. Por exemplo, ao se escrever (double)10, o valor 10 é convertido para double; a expressão (int)valor converte o conteúdo armazenado na variável para int. O cast é sempre aplicado ao item imediamente seguinte na expressão, sendo que em (double)valor_inteiro1 + valor_inteiro2, apenas valor_inteiro1 é afetado pelo modificador de tipo.\nUsando-se essa modificação de tipo, segue uma versão corrigida do programa.\n/*\nCálculo simples de porcentagens em uma pesquisa com as seguintes \n    possibilidades de resposta: sim, não e não sei. A pergunta feita é\n    irrelevante.\nRequer: a quantidade de votos sim, não e não sei.\nAssegura: as quantidades de votos e respectivas as porcentagens,\n    exibidas no intervalo [0, 1], de cada opção de voto\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Obtenção das quantidades\n    printf(\"Número de respostas SIM: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int quant_votos_sim;\n    sscanf(entrada, \"%d\", &quant_votos_sim);\n\n    printf(\"Número de respostas NÃO: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int quant_votos_nao;\n    sscanf(entrada, \"%d\", &quant_votos_nao);\n\n    printf(\"Número de respostas NÃO SEI: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int quant_votos_nao_sei;\n    sscanf(entrada, \"%d\", &quant_votos_nao_sei);\n\n    // Cálculo das porcentagens\n    int quant_total = quant_votos_sim + quant_votos_nao + quant_votos_nao_sei;\n\n    double porcentagem_sim = (double)quant_votos_sim / quant_total;\n    double porcentagem_nao = (double)quant_votos_nao / quant_total;\n    double porcentagem_nao_sei = (double)quant_votos_nao_sei / quant_total;\n\n    // Resultados\n    printf(\"Sim: %d votos (%.2f).\\n\", quant_votos_sim, porcentagem_sim);\n    printf(\"Não: %d votos (%.2f).\\n\", quant_votos_nao, porcentagem_nao);\n    printf(\"Não sei: %d votos (%.2f).\\n\", quant_votos_nao_sei,\n           porcentagem_nao_sei);\n\n    return 0;\n}\nNúmero de respostas SIM: 852\nNúmero de respostas NÃO: 432\nNúmero de respostas NÃO SEI: 73\nSim: 852 votos (0.63).\nNão: 432 votos (0.32).\nNão sei: 73 votos (0.05).\nNeste caso, vale o comentário de que em (double)quant_votos_sim / quant_total somente a primeira variável é explicitamente promovida a double, sendo que a segunda é promovida em função da realização da divisão.\nUma estratégia comum é o uso do elemento neutro para forçar o resultado desejado. Essa alternativa permitiria escrever, por exemplo 1.0 * quant_votos_sim / quant_total. O autor tem como opinião que o uso do cast de tipo explícito é mais elegante, embora o resultado seja equivalente.\n\n\n\n\n\n\nDica\n\n\n\nEm uma expressão aritmética que tenha uma divisão, sempre é preciso atenção quanto ao tipo dos operandos para que se tenha certeza que o resultado seja corretamente calculado.\n\n\nAlgumas conversões são comuns nas atribuições e, em geral, passam despercebidas. Considerando-se as atribuições abaixo, as conversões implícitas fazem sentido.\ndouble d1 = 0;\ndouble d2 = 10;\nAs constantes 0 e 10 são intrinsecamente inteiras, mas devido à variável ser real, ambas são promovidas antes da atribuição. Não há necessidade, por exemplo, de se escrever d1 = 0.0.\nComo mencionado, também é possível converter um valor mais abrangente, como um double para um menos abrangente, como o int. Segue um exemplo.\n/*\nExemplo de conversão de double para inteiro\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double d = 3.75;\n\n    int i1 = 2 * (int)d;\n    int i2 = 2 * d;\n\n    printf(\"i1 = %d e i2 = %d.\\n\", i1, i2);\n\n    return 0;\n}\ni1 = 6 e i2 = 7.\nPara a variável i1, primeiro a parte decimal de d é eliminada e o resultado é multiplicado por 2. Já para i2, primeiro é feita a multiplicação de 2 por d e somente então o resultado é truncado.\nA noção de promoção de tipo é valida não somente de int para double, mas entre quaisquer outros tipos específicos.\n/*\nExemplo de conversão entre double e float\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    float f = 3.75;\n    double d = 2 * f;\n\n    printf(\"f = %g e d = %g.\\n\", f, d);\n\n    return 0;\n}\nf = 3.75 e d = 7.5.\nNeste programa, d é doublee f possui de precisão simples float. Na atribuição para f deve-se notar que 3.74 é double, o qual é “reduzido” para float antes da atribuição. Já na atribuição para d, f é promovida para double ao ser multiplicada por 2 (que é double).\nUm programa que ilustra promoções entre inteiros é apresentada na sequência.\n/*\nExemplo de conversão entre variações de inteiros\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 2000000000;\n    long int li;\n\n    li = 4 * i;\n    printf(\"%ld.\\n\", li);\n\n    li = 4L * i;\n    printf(\"%ld.\\n\", li);\n\n    return 0;\n}\n-589934592.\n8000000000.\n Nesse programa, o valor 2.000.000.000 é intencionalmente grande, pois chega quase ao limite de representação para valores do tipo int e, quando multiplicado por 4 certamente causará um transbordo de bits (overflow)1. A operação 4 * i multiplica dois valores int e o resultado transborda, produzindo um valor incorreto. Quando a operação feita é 4L * i, o valor 4L é uma constante long int e a multiplicação primeiro promove i para long int e o resultado agora tem seus bits comportados pela representação.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Expressões aritméticas de C</span>"
    ]
  },
  {
    "objectID": "c-expressoes-aritmeticas.html#funções-matemáticas",
    "href": "c-expressoes-aritmeticas.html#funções-matemáticas",
    "title": "5  Expressões aritméticas de C",
    "section": "5.3 funções matemáticas",
    "text": "5.3 funções matemáticas\nExiste um arquivo de cabeçalho chamado math.h, o qual define a interface a uma série de funções matemáticas, como radiciação, potenciação e logaritmos, entre outras. O uso das funções requer a inclusão do cabeçalho no código fonte.\n#include &lt;math.h&gt;\nNa Tabela 5.3 são apresentadas algumas das principais funções matemáticas disponíveis. Os argumentos da função são sempre especificados usando-se parênteses e, caso haja mais que um parâmetro, eles são separados por vírgulas. Quando uma função é usada, o tipo de dado usado na expressão é o indicado por seu tipo de retorno.\nComo um exemplo específico, a função pow aceita dois argumentos, ambos do tipo double: pow(1.5, 2.3) indica o cálculo de 1,52,3. Se essa função for usada em uma expressão como pow(1.5, 2.3) - 10, a subtração vê o operando à esquerda como double (tipo de retorno da função) e o à esquerda como int, fazendo a promoção devida antes de gerar o resultado.\n\n\n\nTabela 5.3: Algumas funções matemáticas importantes disponibilizadas por meio de math.h.\n\n\n\n\n\n\n\n\n\n\nFunção\nTipo de retorno\nDescrição\n\n\n\n\nsin(double x)\ndouble\nRetorna o seno de \\(x\\) (em radianos).\n\n\ncos(double x)\ndouble\nRetorna o cosseno de \\(x\\) (em radianos).\n\n\ntan(double x)\ndouble\nRetorna tangente de \\(x\\) (em radianos).\n\n\nexp(double x)\ndouble\nRetorna \\(e^x\\).\n\n\nlog(double x)\ndouble\nRetorna \\(\\log_e x\\).\n\n\nlog10(double x)\ndouble\nRetorna \\(\\log_{10} x\\).\n\n\nsqrt(double x)\ndouble\nRetorna \\(\\sqrt{x}\\).\n\n\nfabs(double x)\ndouble\nRetorna \\(\\lvert x \\rvert\\) (valor absoluto).\n\n\npow(double x, double y)\ndouble\nRetorna \\(x^y\\).\n\n\n\n\n\n\nOs parâmetros e valor de retorno da função são, em geral, do tipo double. Há versões para outros tipos, como o valor absoluto dado por fabsf, que aceita e retorna float, e a raiz quadrada calculada com sqrtl, que aceita e retorna long double.\nPara uso das funções matemáticas, a biblioteca matemática tem que ser conectada ao código executável, de forma que a opção -lm (“link to the math library”) tem que ser acrescentada às opções de compilação.\ngcc main.c -lm\n/* \nDistância entre dois pontos no plano\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"X e Y para P1: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double x1, y1;\n    sscanf(entrada, \"%lf%lf\", &x1, &y1);\n    \n    printf(\"X e Y para P2: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double x2, y2;\n    sscanf(entrada, \"%lf%lf\", &x2, &y2);\n    \n    double distancia = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n    printf(\"D[(%g, %g), (%g, %g)] = %g.\\n\", x1, y1, x2, y2, distancia);\n\n    return 0;\n}\nX e Y para P1: 1.5 4.7\nX e Y para P2: -3.2 0.5\nD[(1.5, 4.7), (-3.2, 0.5)] = 6.30317.\nComo as conversões de tipo são um tópico importante nesta seção do texto, é interessante identificar que, ao elevar ao quadrado com a função pow, para o segundo argumento foi usado 2 (que é int) e a função espera um double; neste caso o int é automaticamente promovido para double ao ser chamada a função.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Expressões aritméticas de C</span>"
    ]
  },
  {
    "objectID": "c-expressoes-aritmeticas.html#atribuições-são-operadores",
    "href": "c-expressoes-aritmeticas.html#atribuições-são-operadores",
    "title": "5  Expressões aritméticas de C",
    "section": "5.4 Atribuições são operadores",
    "text": "5.4 Atribuições são operadores\nDa mesma forma que + ou / são operadores, também é a atribuição com =. Ao se escrever valor = 10, por exemplo, o sinal de igual funciona como um operador com dois efeitos:\n\nO valor da expressão à direita do sinal é atribuído à variável indicada à esquerda;\nEssa operação resulta no valor atribuído.\n\nEmbora possa parecer estranho em um primeiro momento, C admite que um operador de atribuição possa ser usado em qualquer lugar onde caiba uma expressão. O programa seguinte ilustra o uso desse recurso.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int valor1, valor2;\n\n    valor2 = 10 * (valor1 = 5);\n    printf(\"valor1 = %d e valor2 = %d.\\n\", valor1, valor2);\n\n    return 0;\n}\nvalor1 = 5 e valor2 = 50.\n\n\n\n\n\n\nDica\n\n\n\nO uso de atribuições em locais inusitados deve ser evitado. Não é só porque um determinado recurso funciona é que ele deva ser usado indiscriminadamente. A clareza do código deve sempre ser uma prioridade.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Expressões aritméticas de C</span>"
    ]
  },
  {
    "objectID": "c-expressoes-aritmeticas.html#footnotes",
    "href": "c-expressoes-aritmeticas.html#footnotes",
    "title": "5  Expressões aritméticas de C",
    "section": "",
    "text": "Há um transbordo quando o resultado de uma operação precisa de mais bits que o tipo tem disponível, corrompendo a representação por causa dos bits perdidos.↩︎",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Expressões aritméticas de C</span>"
    ]
  },
  {
    "objectID": "c-expressoes-relacionais-e-logicas.html",
    "href": "c-expressoes-relacionais-e-logicas.html",
    "title": "6  C: expressões relacionais e lógicas",
    "section": "",
    "text": "6.1 Expressões relacionais\nAlém de expressões aritméticas, há outros dois tipos de expressões relevantes, ambas tratadas neste capítulo: relacionais e lógicas.\nUma expressão relacional é a que compara (i.e., relaciona) valores. Assim, para determinar de um valor é maior que zero, usa-se uma expressão relacional: valor &gt; 0.\nAs expressões relacionais resultam em valores lógicos: verdadeiro ou falso. Em C, é possível introduzir a noção de algumas expressões relacionais por meio do programa seguinte.\nO resultado de uma operação relacional é um valor inteiro (tipo int, escrito com %d), podendo ser apenas dois valores: 0 se a condição é falsa ou 1, se for verdadeira. Com essa informação é possível interpretar corretamente a saída produzida pelo programa, embora essa saída não seja apropriada para um usuário comum.\nOutro ponto a observar observar são os operadores relacionais em si. Alguns são de fácil compreensão, outros nem tanto. A Tabela 6.1 apresenta os operadores relacionais da linguagem e seus significados.\nPela ordem de precedência das operações, todas as expressões aritméticas são avaliadas antes dos operadores relacionais. Desse modo, ao se escrever 2 * valor1 &lt; 3 * valor2, as duas multiplicações são realizadas antes da comparação, o que é bastante intuitivo.\nUm problema prático interessante e simples é a verificação se alguém está “bem de vida”. No Brasil, uma pessoa é considerada pertencente à classe A (a de maior renda) se tiver renda familiar mensal acima de 20 salários mínimos.\nO Algoritmo 6.1 mostra uma solução que determina se uma renda familiar mensal fornecida pertence ou não à classe A. A verificação é feita por uma comparação de valores e é usada uma variável lógica para guardar o resultado. A saída esperada do algoritmo é verdadeiro ou falso apenas.\nEste algoritmo pode ser implementado em C conforme o código seguinte.\nA variável eh_classe_a é declarada para guardar o resultado da comparação e ela é do tipo _Bool, que guarda um valor inteiro 0 ou 1, seguindo o padrão de representação da linguagem.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C: expressões relacionais e lógicas</span>"
    ]
  },
  {
    "objectID": "c-expressoes-relacionais-e-logicas.html#expressões-relacionais",
    "href": "c-expressoes-relacionais-e-logicas.html#expressões-relacionais",
    "title": "6  C: expressões relacionais e lógicas",
    "section": "",
    "text": "/*\nIlustração de expressões relacionais\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n    printf(\"Digite dois valores inteiros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor1, valor2;\n    sscanf(entrada, \"%d%d\", &valor1, &valor2);\n\n    printf(\"%d == %d? %d.\\n\", valor1, valor2, valor1 == valor2);\n    printf(\"%d != %d? %d.\\n\", valor1, valor2, valor1 != valor2);\n    printf(\"%d &lt; %d?  %d.\\n\", valor1, valor2, valor1 &lt; valor2);\n    printf(\"%d &gt; %d?  %d.\\n\", valor1, valor2, valor1 &gt; valor2);\n    printf(\"%d &lt;= %d? %d.\\n\", valor1, valor2, valor1 &lt;= valor2);\n    printf(\"%d &gt;= %d? %d.\\n\", valor1, valor2, valor1 &gt;= valor2);\n\n    return 0;\n}\nDigite dois valores inteiros: 27 12\n27 == 12? 0.\n27 != 12? 1.\n27 &lt; 12?  0.\n27 &gt; 12?  1.\n27 &lt;= 12? 0.\n27 &gt;= 12? 1.\n\n\n\n\n\nTabela 6.1: Operadores relacionais da linguagem C.\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\n==\nIgual\n\n\n!=\nDiferente\n\n\n&lt;\nMenor que\n\n\n&gt;\nMaior que\n\n\n&lt;=\nMenor ou igual\n\n\n&gt;=\nMaior ou igual\n\n\n\n\n\n\n\n\n\n\n\nAlgoritmo 6.1: Determinação de uma dada renda mensal familiar caracteriza o pertencimento à classe A.\n\n\n\n\n/*\nDeterminação se uma renda familiar mensal é classificada como classe A no\n    Brasil; Classe A: 20 salários mínimos de R\\$1.412,00 (valor de janeiro\n    de 2024)\nRequer: o valor da renda familiar\nAssegura: verdadeiro se se enquadrar na classe A; falso se não\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite o valor da renda mensal familiar: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double renda_familiar;\n    sscanf(entrada, \"%lf\", &renda_familiar);\n\n    _Bool eh_classe_a = renda_familiar &gt; 20 * 1412.00;  // mínimo em 1/2024\n\n    printf(\"Sua família é classe A? %d\\n\", eh_classe_a);\n\n    return 0;\n}\nDigite o valor da renda mensal familiar: 15000\nSua família é classe A? 0\n\n\n\n\n\n\n\nDica\n\n\n\nAs variáveis que armazenam valores lógicos são usadas de forma diferenciada das numéricas, por exemplo. Em consequência disso, os identificadores usados também devem ser diferenciados.\nUma recomendação importante para as variáveis lógicas é que possuam um verbo no nome. Assim, bons identificadores para variáveis lógicas são existe_taxa, possui_filhos ou eh_divisor, por exemplo.\nVale notar que, embora filhos possa ser usada com significando se tem ou não filhos, não é óbvio que a variável seja mesmo um valor lógico, pois poderia conter, por exemplo, o número de filhos. E, assim, a clareza volta a ser um ponto relevante na escrita dos programas.\n\n\n\n6.1.1 Afinal, _Bool ou bool?\nA linguagem C, no início, não possuía um tipo lógico específico. Eram empregadas variáveis do tipo int para representar tanto os valores realmente inteiros (como idades ou contadores) quanto para valores lógicos. Assim, para o programador com alguma experiência, não é estranha essa mistura de significados nos códigos mais antigo e também nos novos.\nComo não havia a necessidade de uma variável lógica, a palavra bool nunca foi reservada para a linguagem e poderia ser usada livremente nos programas. Em decorrência de uma posterior criação do tipo booliano, reservar uma palavra poderia implicar a reescrita em massa dos códigos já existentes. Dessa forma, a palavra-chave escolhida for _Bool.\nPara os programas para os quais não haveria conflito, foi incluída à biblioteca padrão o arquivo de cabeçalho stdbool.h, o qual define bool como um novo nome para _Bool. Além do novo nome, também define true e false para serem usados no lugar de 1 e 0, respectivamente.\nA modificação do programa para usar essas definições é pequena, bastando incluir o arquivo de cabeçalhos e modificar o tipo na declaração da variável.\n#include &lt;stdbool.h&gt;\nbool eh_classe_a = renda_familiar &gt; 20 * 1412.00;\nA forma de escrita usando bool parece, para o autor, a forma mais natural de declaração, pois segue um padrão visual similar ao dos outros tipos. Este será empregado ao longo do texto.\nAntes de apresentar a versão final do código, agora com o cabeçalho stdbool.h, é interessante notar que existe em C uma construção que pode ser usada neste programa para melhorar a apresentação do resultado. Esse elemento é conhecido como condicional ternário.\n\n\n\n\n\n\nOperador condicional ternário\n\n\n\nexpressão_lógica ? resultado_verdadeiro : resultado_falso\n\n\nEsse condicional, assim como os aritméticos e os relacionais, resultam em um valor dependente de seus operandos. Neste caso, há três operandos e dois operadores: ? e :. Se o valor de expressão_lógica for verdadeiro, então o resultado final da expressão é o valor resultado_verdadeiro e, caso contrário, o resultado é resultado_falso.\nSegue um exemplo simples desse condicional ternário.\nint a = 20;\nint b = 12;\n\nint maior = a &gt; b ? a : b;\nNa atribuição a maior, a expressão_lógica do condicional ternário é a &gt; b. Se o resultado dessa expressão for verdadeiro, então o valor de a é o resultado atribuído a maior. Se o valor de a for menor ou igual ao de b, o resultado final será b.\nNão há restrições dos tipos de dados que podem ser usados como resultado do condicional ternário e o programa usa cadeias de caracteres como resultado.\n/*\nDeterminação se uma renda familiar mensal é classificada como classe A no\n    Brasil; Classe A: 20 salários mínimos de R\\$1.412,00 (valor de janeiro\n    de 2024)\nRequer: o valor da renda familiar\nAssegura: verdadeiro se se enquadrar na classe A; falso se não\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite o valor da renda mensal familiar: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double renda_familiar;\n    sscanf(entrada, \"%lf\", &renda_familiar);\n\n    bool eh_classe_a = renda_familiar &gt; 20 * 1412.00;  // mínimo em 1/2024\n\n    printf(\"Sua família %s classe A!\\n\", eh_classe_a ? \"é\" : \"não é\");\n\n    return 0;\n}\nDigite o valor da renda mensal familiar: 30000\nSua família é classe A!\nAs modificações para o uso de bool foram feitas e, para o condicional ternário, se eh_classe_a for verdadeiro, o resultado é o texto \"é\" e, se não for, \"não é\". Um desses dois valores ocupará o lugar do %s no texto do printf.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C: expressões relacionais e lógicas</span>"
    ]
  },
  {
    "objectID": "c-expressoes-relacionais-e-logicas.html#expressões-lógicas",
    "href": "c-expressoes-relacionais-e-logicas.html#expressões-lógicas",
    "title": "6  C: expressões relacionais e lógicas",
    "section": "6.2 Expressões lógicas",
    "text": "6.2 Expressões lógicas\nNeste tópico serão detalhadas as expressões lógicas, as quais foram usadas nos exemplos anteriores mas não foram explicadas completamente.\nUma expressão lógica é uma expressão que resulta em verdadeiro ou falso pela combinação de expressões lógicas. Existem apenas três operadores lógicos: e, ou e não.\nA combinação com o operador de disjunção e somente resulta em verdadeiro quando os dois operandos forem verdadeiros e, caso contrário, em falso. O conceito desse operador pode ser exemplificado por “há isenção de tarifa se o cliente possuir cartão de crédito e o volume de aplicações for superior a R$100.000,00”. Nessa situação, apenas ter o cartão de crédito ou apenas ter aplicações suficientes não dá direito ao desconto. O resultado somente é verdadeiro se ambas as condições forem satisfeitas simultaneamente.\nO ou é o operador de conjunção, que resulta em verdadeiro se qualquer um de seus operadores for verdadeiro, sendo falso apenas quando ambos forem falsos. Por exemplo, “a pessoa tem direito a meia entrada no baile se for sócio do clube ou se for estudante”. Este é o caso em que o resultado é falso apenas para os não sócios e os não estudantes.\nO operador não é a negação, apenas invertendo o resultado. Não verdadeiro é falso e não falso é verdadeiro. Como exemplo, em “se não estiver chovendo, vou sair”, a situação de chuva é verdadeira, o resultado é falso, o que impede a saída da pessoa.\nEm C, a operação e é indicada pelo operador &&, ou usa || e não é o operador unário !. As combinações possíveis de resultados são apresentadas na Tabela 6.2, chamada de tabela verdade.\n\n\n\nTabela 6.2: Tabela verdade para os operadores && (e), || (ou) e ! (não).\n\n\n\n\n\n\n\n\n\n\n\n\n\ne1\ne2\ne1 && e2\ne1 || e2\n!e1\n!e2\n\n\n\n\nfalso\nfalso\nfalso\nfalso\nverdadeiro\nverdadeiro\n\n\nfalso\nverdadeiro\nfalso\nverdadeiro\nverdadeiro\nfalso\n\n\nverdadeiro\nfalso\nfalso\nverdadeiro\nfalso\nverdadeiro\n\n\nverdadeiro\nverdadeiro\nverdadeiro\nverdadeiro\nfalso\nfalso\n\n\n\n\n\n\nComo os demais operadores, há também uma ordem de precedência quando são usados operadores lógicos. O de maior precedência é o !, seguido pelo && e, por último, ||. A quebra da precedência é feita com o uso de parênteses. Seguem exemplos de expressões e como são avaliadas (usando-se parênteses adicionais para reforçar a ordem).\na &gt; b && a != 0 || b != 0  // ((a &gt; b && a != 0) || b != 0)\na != 0 || b != 0 && a &gt; b  // (a != 0 || (b != 0 && a &gt; b))\n// assumindo-se v1 e v2 como variáveis com valores lógicos\n!v1 && v2  // ((!v1) && v2)\n!v1 && !v2  // ((!v1) && (!v2))\n\n\n\n\n\n\nCuriosidade\n\n\n\nExiste uma operação chamada ou exclusivo, que diferentemente do ou, resulta verdadeiro se apenas um dos dois operandos for verdadeiro, mas não os dois. Para se obter esse resultado, a seguinte expressão pode ser usada.\n// assumindo-se v1 e v2 como variáveis com valores lógicos\n!(v1 && v2) && (v1 || v2)\nA opção que segue é também equivalente.\n(v1 && !v2) || (!v1 && v2)\nNote-se que os parênteses nesta última expressão servem apenas para ênfase e são desnecessários dada a ordem de precedência dos operadores.\n\n\n\n6.2.1 Relações matemáticas ternárias e sucessivas\nNo cotidiano é comum usar expressões ternárias como 0 \\(&lt; x &lt;\\) 10 para indicar que \\(x\\) está em um determinado intervalo. Em C é preciso cuidado com tais expressões, pois cada expressão relacional resulta em um valor inteiro.\nPor exemplo, a expressão 0 &lt; valor &lt; 10 é avaliada na seguinte ordem, considerando-se valor contendo 20:\n\n(0 &lt; valor) &lt; 10: avaliação que ocorre da esquerda para a direita;\n1 &lt; 10: substituição do resultado intermediário na expressão;\n1: o resultado final é verdadeiro.\n\nPorém 0 &lt; 20 &lt; 10 é esperado que resulte em falso.\nExpressões ternárias em C não são possíveis e, assim, devem ser escritas como uma combinação de expressões binárias. A expressão deve ser escrita: 0 &lt; valor && valor &lt; 10, sendo que o && significa “e”. O modo com que as expressões relacionais são avaliadas e o uso de valores inteiros como resultado levam à necessidade de que expressões sejam escritas, muitas vezes, de forma extensa.\nEstendendo esse conceito, matematicamente se pode escrever \\(a = b = c = d\\), por exemplo. Em C, a expressão requer expressões relacionais isoladas combinadas com operadores lógicos. Assim, a == b && b == c & c == d é uma expressão equivalente. Seguem exemplos.\na == b && b == c && c == d  // a = b = c = d\na &lt; b && b &lt; c && c &lt; d     // a &lt; b &lt; c &lt; d\na == b && b &lt; c             // a = b &lt; c\n\n\n6.2.2 Comparações com vários valores\nOutra questão que surgem com frequência é a verificação de uma variável com uma série de valores. Este é o caso, por exemplo, para verificar se uma variável inteira mes é um dos meses com 31 dias, ou seja, se \\({m \\in \\{ 1, 3, 5, 7, 8, 10, 12 \\}}\\). Não é incomum que programados iniciantes tentem fazer essa comparação como se segue.\nmes == 1 || 3 || 5 || 7 || 8 || 10 || 12  // incorreto!\nEssa expressão, pelas regras da linguagem, primeiro avalia se mes == 1 e esse resultado é 0 ou 1. A próxima comparação verifica, portanto, 0 || 3 ou 1 || 3, o que resulta em 1, qualquer que seja o valor obtido na primeira comparação. É importante lembrar que o valor falso está associado ao 0, enquanto qualquer valor não nulo é verdadeiro. A expressão acima significa, na prática, “mês igual a 1 ou verdadeiro ou verdadeiro ou verdadeiro…”, o que é sempre verdadeiro, ou seja, 1.\nO ajuste necessário para essa expressão é individualizar as comparações e a comparação seguinte produz o resultado desejado.\nmes == 1 || mes == 3 || mes == 5 || mes == 7 ||  mes == 8 ||\n    mes == 10 || mes == 12  // OK!\n\n\n\n\n\n\nDica\n\n\n\nElaborar expressões lógicas requer prática e atenção. Nem sempre as verificações são óbvias e testar a avaliação da expressão passo a passo pode ser uma estratégia muito interessante ou até necessária.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C: expressões relacionais e lógicas</span>"
    ]
  },
  {
    "objectID": "c-expressoes-relacionais-e-logicas.html#ordem-de-precedência-entre-operadores-relacionais-e-lógicos",
    "href": "c-expressoes-relacionais-e-logicas.html#ordem-de-precedência-entre-operadores-relacionais-e-lógicos",
    "title": "6  C: expressões relacionais e lógicas",
    "section": "6.3 Ordem de precedência entre operadores relacionais e lógicos",
    "text": "6.3 Ordem de precedência entre operadores relacionais e lógicos\nA linguagem C estabelece um padrão curioso (e potencialmente confuso) para ordem de precedência dos operadores relacionais e lógicos. A regra geral é que operações relacionais sejam feitas antes das lógicas, ou seja, comparações antes das combinações com e e ou. Isso é verdade, exceto para o não. Em C, o operador ! tem precedência sobre os operadores relacionais.\nCom exemplo o trecho de código seguinte pode ser considerado.\nint a = 1;\nint b = 2;\nint c = 0;\n\nbool r = a &gt; b && ! b &gt;= c;\nÉ importante observar que, embora b tenha valor 2, ao ser avaliado ! b &gt; c a primeira operação é !b. Como todo valor diferente de zero é verdadeiro, !b é falso e, portanto, igual a 0. Assim, a expressão se torna equivalente a 0 &gt;= c, o que resulta em verdadeiro, uma vez c também é zero.\nA ordem é, portanto:\n\nO operador !;\nOs operadores relacionais;\nO operador &&;\nO operador ||.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C: expressões relacionais e lógicas</span>"
    ]
  },
  {
    "objectID": "c-expressoes-relacionais-e-logicas.html#exemplos-práticos",
    "href": "c-expressoes-relacionais-e-logicas.html#exemplos-práticos",
    "title": "6  C: expressões relacionais e lógicas",
    "section": "6.4 Exemplos práticos",
    "text": "6.4 Exemplos práticos\nEsta seção cobre exemplos diversos de implementações que usam expressões relacionais e lógicas em problemas diretos, com maior ou menor grau de complexidade.\n\n6.4.1 Verificação de cédulas válidas\nEste é um exemplo para determinar se um determinado valor é ou não um valor de cédula válido. Atualmente no Brasil, há cédulas e moedas usadas sendo usada cotidianamente no comércio. As cédulas em papel possuem valores de face de 2, 5, 10, 20, 50, 100 e 200 reais.\nAssim, é proposto o Algoritmo 6.2 para determinar se um valor qualquer é ou não o valor de face de uma cédula brasileira.\n\n\nAlgoritmo 6.2: Determinação se um valor é um valor de face de uma cédula brasileira.\n\n\n\nO programa seguinte codifica esse algoritmo.\n/*\nVerificação se um dado valor inteiro qualquer é ou não um valor de face\n    válido entre as cédulas do Brasil\nRequer: um valor inteiro qualquer\nAssegura: verdadeiro se o valor corresponder a uma das cédulas; falso\n    caso contrário\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor inteiro para verificação de cédula: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor_candidato;\n    sscanf(entrada, \"%d\", &valor_candidato);\n\n    bool eh_valido = valor_candidato == 2 || valor_candidato == 5 ||\n                        valor_candidato == 10 || valor_candidato == 20 ||\n                        valor_candidato == 50 || valor_candidato == 100 ||\n                        valor_candidato == 200;\n\n    printf(\"O valor %d é %s.\\n\", valor_candidato,\n        eh_valido ? \"válido\" : \"inválido\");\n\n    return 0;\n}\nDigite um valor inteiro para verificação de cédula: 100\nO valor 100 é válido.\n\n\n6.4.2 Verificação de aprovação em disciplina\nConsiderando-se que a aprovação de um aluno em uma disciplina exija que ele tenha média maior ou superior a 6 e que sua frequência não seja inferior a 75%, o problema que deve ser resolvido é determinar se um aluno foi ou não aprovado. Para determinar média final, há duas notas e deve ser calculada sua média. Para a frequência, estão disponíveis o número de faltas e o número total de aulas. Assim, é proposto como solução o Algoritmo 6.3.\n\n\nAlgoritmo 6.3: Verificação da aprovação ou reprovação de um aluno em função de notas e frequência.\n\n\n\nA implementação é apresentada na sequência.\n/*\nDeterminação de aprovação em disciplina em função da média de duas notas e frequência baseada no número de faltas e número de aulas\nRequer: duas notas de provas, número de faltas e número de aulas\nAssegura: A média, a frequência e verdadeiro/falso conforme aprovado ou reprovado\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Média\n    printf(\"Digite as duas notas de provas: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double nota1, nota2;\n    sscanf(entrada, \"%lf%lf\", &nota1, &nota2);\n    double media = (nota1 + nota2) / 2;\n    bool tem_media = media &gt;= 6;\n\n    // Frequência\n    printf(\"Digite o número de faltas e o de aulas: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int numero_faltas, numero_aulas;\n    sscanf(entrada, \"%d%d\", &numero_faltas, &numero_aulas);\n    double frequencia = (double) (numero_aulas - numero_faltas) / numero_aulas;\n    bool tem_pouca_frequencia = frequencia &lt; 0.75;\n\n    // Aprovação/reprovação e resultado\n    bool tem_aprovacao = tem_media && !tem_pouca_frequencia;\n    printf(\"Média: %.1f; frequência: %.1f%%.\\n\", media, 100 * frequencia);\n    printf(\"Situação: %s.\\n\", tem_aprovacao ? \"aprovado\" : \"reprovado\");\n\n    return 0;\n}\nDigite as duas notas de provas: 5.8 9.1\nDigite o número de faltas e o de aulas: 8 30\nMédia: 7.4; frequência: 73.3%.\nSituação: reprovado.\nEste programa usa variáveis lógicas para as diversas condições. Um detalhe interessante é a variável tem_pouca_frequencia, a qual indica que a frequência não é suficiente para aprovação. Na verificação final, é usado o operador não para negar essa condição e conceder a aprovação: !tem_pouca_frequencia (i.e., “não tem pouca frequência”).\nO operador ! é pouco usado juntamente com expressões relacionais, pois escrever a &lt;= b é melhor que !(a &gt; b). Por outro lado, se existem uma variável detectou_problema, é mais natural negar escrevendo detectou_problema ou !detectou_problema.\n\n\n\n\n\n\nDica\n\n\n\nOperadores lógicos nunca devem ser comparados com os valores true e false, como exemplificado na sequência.\ntem_aprovacao ? \"aprovado\" : \"reprovado\"           // bom!\ntem_aprovacao == true ? \"aprovado\" : \"reprovado\"   // ruim e desnecessário!\ntem_aprovacao != false ? \"aprovado\" : \"reprovado\"  // pior ainda!\nPode-se considerar que comparar uma variável com true ou false faz tanto sentido como escrever (a &gt; b) == true.\n\n\n\n\n6.4.3 Verificação de existência de triângulo\nPara ilustrar tanto as expressões como o uso de valores lógicos, o problema de verificar se três segmentos de reta podem ser os lados de um triângulo é apresentado. Um triângulo não pode ser formado caso um dos segmentos seja maior ou igual à soma dos outros dois, situação em que o triângulo “não fecha”. Seguem a solução no Algoritmo 6.4 e sua implementação em C.\n\n\nAlgoritmo 6.4: Verificação se três segmentos de reta podem ou não formar um triângulo\n\n\n\n/*\nVerificação se três segmentos de reta com determinados comprimentos podem\n    ou não formar um triângulo\nRequer: os comprimentos $l_1$, $l_2$ e $l_3$ dos segmentos de reta\nAssegura: Verdadeiro se podem formar um triângulo; falso caso contrário\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite os comprimentos dos segmentos de reta: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double lado1, lado2, lado3;\n    sscanf(entrada, \"%lf%lf%lf\", &lado1, &lado2, &lado3);\n\n    bool triangulo_eh_valido = lado1 &lt; lado2 + lado3 && lado2 &lt; lado1 + lado3 &&\n            lado3 &lt; lado1 + lado2;\n\n    printf(\"Triângulo %s.\\n\", triangulo_eh_valido ? \"válido\" : \"inválido\");\n\n    return 0;\n}\nDigite os comprimentos dos segmentos de reta: 3 4 5\nTriângulo válido.\nNeste programa, a variável triangulo_eh_valido é usada como uma variável lógica.\n\n\n6.4.4 Verificação de validade de uma data\nComo exemplo com expressões lógicas, segue um algoritmo para determinar se valores para dia, mês e ano formam uma data válida (Algoritmo 6.5). Os valores formam uma data válida se o valor do dia estiver dentro do intervalo do mês e o ano for diferente de zero1. A solução desconsidera anos bissextos, de forma que fevereiro considera apenas 28 dias. Também considera que valores negativos para um ano indicam AC (antes de Cristo).\n\n\nAlgoritmo 6.5: Determinação se valores inteiros para dia, mês e ano formam uma data válida.\n\n\n\n/*\nDeterminação se valores inteiros para dia, mês e ano formam uma data\nválida,desconsiderando anos bissextos e entendendo anos negativos como AC\nRequer: valores inteiros para dia, mês e ano\nAssegura: verdadeiro se a data é válida ou falso caso contrário\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n    \n    printf(\"Digite os valores para dia, mês e ano: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int dia, mes, ano;\n    sscanf(entrada, \"%d%d%d\", &dia, &mes, &ano);\n\n    bool data_valida = dia &gt; 0 && mes &gt; 0 && ano != 0 && (\n            dia &lt;= 28 && mes == 2 ||\n            dia &lt;= 31 && (mes == 1 || mes == 3 || mes == 5 || mes == 7 ||\n                mes == 8 || mes == 10 || mes == 12) ||\n            dia &lt;= 30 && (mes == 4 || mes == 6 || mes == 9 || mes == 11)\n        );\n\n    printf(\"%02d/%02d/%04d é %s.\\n\", dia, mes, ano, \n        data_valida ? \"válida\" : \"inválida\");\n\n    return 0;\n}\nDigite os valores para dia, mês e ano: 30 2 2050\n30/02/2050 é inválida.\nEmbora a ordem de precedência dos operadores permita escrever as expressões usando apenas os parênteses somente necessário, é usual que expressões mais longas usem o recurso dos parênteses para dar maior clareza à expressão. Um desses casos é envolver o && com parênteses, mesmo sabendo-se que o || será avaliado posteriormente. O programa de verificação de datas é escrito lançando mão dessa estratégia.\n/*\nDeterminação se valores inteiros para dia, mês e ano formam uma data\n    válida,desconsiderando anos bissextos e entendendo anos negativos\n    como AC\nRequer: valores inteiros para dia, mês e ano\nAssegura: verdadeiro se a data é válida ou falso caso contrário\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n    \n    printf(\"Digite os valores para dia, mês e ano: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int dia, mes, ano;\n    sscanf(entrada, \"%d%d%d\", &dia, &mes, &ano);\n\n    bool data_valida = dia &gt; 0 && mes &gt; 0 && ano != 0 && (\n            (dia &lt;= 28 && mes == 2) ||\n            (dia &lt;= 31 && (mes == 1 || mes == 3 || mes == 5 || mes == 7 ||\n                mes == 8 || mes == 10 || mes == 12)) ||\n            (dia &lt;= 30 && (mes == 4 || mes == 6 || mes == 9 || mes == 11))\n        );\n\n    printf(\"%02d/%02d/%04d é %s.\\n\", dia, mes, ano, \n        data_valida ? \"válida\" : \"inválida\");\n\n    return 0;\n}\nDigite os valores para dia, mês e ano: 18 12 1892\n18/12/1892 é válida.\n\n\n6.4.5 Mais sobre valores lógicos em C\nComo já exposto no início do capítulo, se um valor for igual a zero ele é considerado falso e se for diferente de zero é verdadeiro. A questão é que, na linguagem C, isso é válido para qualquer valor e não somente os do tipo bool e inteiros.\nPara exemplificar, o programa abaixo pode ser considerado.\n/*\nExemplo de programa com negação de valor double\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor real: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double d;\n    sscanf(entrada, \"%lf\", &d);\n\n    bool r = !d;\n\n    printf(\"r é %s.\\n\", r ? \"verdadeiro\" : \"falso\");\n    return 0;\n}\nDigite um valor real: 0.0\nr é verdadeiro.\nSe o valor digitado para d for igual a zero, !d é 1; se for diferente de zero, r receberá 0. Para a linguagem, é irrelevante que d seja double.\nSegue mais um exemplo.\n/*\nExemplo de programa com negação de valor double\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor real: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double d;\n    sscanf(entrada, \"%lf\", &d);\n\n    printf(\"O valor digitado é %s zero.\\n\", d ? \"diferente de\" : \"igual a\");\n    return 0;\n}\nDigite um valor real: 5.2\nO valor digitado é diferente de zero.\nNeste programa, o condicional ternário é escrito d ? \"diferente de\" : \"igual a\". Se d for zero, a expressão é assumida como falsa; se não for, é verdadeira.\n\n\n\n\n\n\nCuidado\n\n\n\nNão é uma boa prática usar um valor que não seja lógico como se assim fosse. A escrita do código deve deixar claro o que é o que.\nPor exemplo, mesmo que 2 * i - 1 ? \"Ok\" : \"Não ok\" funcione, resultando em \"Ok\" sempre que 2 * i - 1 for diferente de zero, deve-se sempre escrever 2 * i - 1 != 0 ? \"Ok\" : \"Não ok\", já que a operação aritmética não é, em si, uma expressão lógica.",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C: expressões relacionais e lógicas</span>"
    ]
  },
  {
    "objectID": "c-expressoes-relacionais-e-logicas.html#footnotes",
    "href": "c-expressoes-relacionais-e-logicas.html#footnotes",
    "title": "6  C: expressões relacionais e lógicas",
    "section": "",
    "text": "O calendário da era cristã (Anno Domini, ou ano do Senhor) se inicia com o ano 1 DC e anos antes de Cristo se iniciam com 1 AC. Não há ano zero.↩︎",
    "crumbs": [
      "Programação básica",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>C: expressões relacionais e lógicas</span>"
    ]
  },
  {
    "objectID": "c-execucao-condicional-com-if.html",
    "href": "c-execucao-condicional-com-if.html",
    "title": "7  Execução condicional com if",
    "section": "",
    "text": "7.1 A estrutura condicional if\nA maioria dos programas requer que alguns comandos apenas sejam executados em algumas condições e isso é chamado, naturalmente, de execução condicional.\nA principal estrutura na linguagem C para determinar se determinados comandos são ou não executados é o if. Esta estrutura é o assunto deste capítulo.\nPara introduzir a estrutura condicional é apresentado um programa que implementa o Algoritmo 7.1.\nA codificação em C deste algoritmo pode ser feita como se segue.\nA estratégia da implementação é a mesma do algoritmo, que opta por fazer a troca dos valores (e isso requer o uso de uma variável temporária auxiliar). As três instruções que realizam a troca somente são executadas quando v2 for menor que v1 e ignoradas se isso não for verdade\nÉ importante ressaltar que as chaves agrupam as três atribuições do if, de forma que todos os comandos ficam condicionados. O uso das chaves para agrupar comandos cria um comando composto, o qual pode ser usado no lugar de qualquer comando simples.\nEm C, a estrutura básica do if se estabelece conforme destacado na sequência.\nA condição é uma expressão que deve resultar em verdadeiro ou falso. Somente se a condição for verdadeira comando é executado. O comando, por sua vez, pode ser tanto um comando simples (terminado com ponto e vírgula) ou um comando composto (usando chaves).\nSeguem dois exemplos válidos de estruturas if: a primeira usa um comando simples e, na segunda, um comando composto contendo apenas um comando simples. É interessante observar que o ponto e vírgula ocorre apenas no final do comando simples, enquanto comandos compostos não usam esse terminador depois do fecha chaves.",
    "crumbs": [
      "Controle de fluxo simples",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Execução condicional com `if`</span>"
    ]
  },
  {
    "objectID": "c-execucao-condicional-com-if.html#a-estrutura-condicional-if",
    "href": "c-execucao-condicional-com-if.html#a-estrutura-condicional-if",
    "title": "7  Execução condicional com if",
    "section": "",
    "text": "Algoritmo 7.1: Apresentação de dois valores reais em ordem não decrescente.\n\n\n\n\n/*\nApresentação de dois valores em ordem não decrescente\nRequer: dois valores reais v1 e v2\nAssegura: v1 &lt;= v2\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite dois valores reais: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double v1, v2;\n    sscanf(entrada, \"%lf%lf\", &v1, &v2);\n\n    if(v2 &lt; v1) {\n        double temporario = v1;\n        v1 = v2;\n        v2 = temporario;\n    }\n\n    printf(\"Valores em ordem não decrescente: %g e %g.\\n\", v1, v2);\n    \n    return 0;\n}\nDigite dois valores reais: 4.5 1.3\nValores em ordem não decrescente: 1.3 e 4.5.\n\n\n\n\n\n\n\n\n\nEstrutura if básica\n\n\n\nif ( condição ) comando\n\n\n\n\nif(valor &lt; 0)\n    valor = -valor; // torna positivo\nif(valor &lt; 0) {\n    valor = -valor; // torna positivo\n}",
    "crumbs": [
      "Controle de fluxo simples",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Execução condicional com `if`</span>"
    ]
  },
  {
    "objectID": "c-execucao-condicional-com-if.html#if-else",
    "href": "c-execucao-condicional-com-if.html#if-else",
    "title": "7  Execução condicional com if",
    "section": "7.2 if + else",
    "text": "7.2 if + else\nA cláusula else pode ser adicionada ao if para indicar uma ação a ser feita caso a condição de teste seja avaliada como falsa.\n\n\n\n\n\n\nEstrutura if completa\n\n\n\nif ( condição ) comando_verdade else comando_falso\n\n\nComo exemplo, considere o problema de determinar o peso (massa) ideal de uma pessoa baseada em seu sexo biológico. Para o sexo feminino, o peso em quilogramas é dado pela expressão 62,1\\(h\\)  -  44,7, sendo \\(h\\) a altura da pessoa em metros; para o masculino, o cálculo é 72,7\\(h\\) - 58. Seguem a solução algorítmica e uma implementação em C para esse problema.\n\n\nAlgoritmo 7.2: Estimativa do peso ideal conforme sexo biológico e altura.\n\n\n\n/*\nCálculo estimado da massa ideal de uma pessoa baseada em seu sexo biológico\n    e sua altura\nRequer: o sexo biológico (masculino ou feminino) e a altura em metros\nAssegura: a massa ideal da pessoa apresentada (kg)\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite o sexo (M ou F) e a altura em quilogramas: \");\n    fgets(entrada, sizeof entrada, stdin);\n    char sexo;\n    double altura;\n    sscanf(entrada, \"%c%lf\", &sexo, &altura);\n\n    double massa_ideal;\n    if(sexo == 'F')\n        massa_ideal = 62.1 * altura - 44.7;  // feminino\n    else\n        massa_ideal = 72.7 * altura - 58;  // masculino\n\n    printf(\"Massa ideal: %.1fkg.\", massa_ideal);\n\n    return 0;\n}\nDigite o sexo (M ou F) e a altura em quilogramas: F 1.68\nMassa ideal: 59.6kg.\nNeste há dois caminhos possíveis: o cálculo como sexo biológico feminino ou masculino. Pela especificação do problema, apenas M ou F são entradas válidas, o que permitiu associar ao else, inequivocamente, o valor M. Em C, vale o destaque que = é usado para a atribuição, sendo que a comparação de igualdade é feita com ==.\nEm relação ao if, tanto no caso verdadeiro quanto no falso foram inseridos comandos simples.\nComo exemplo adicional, um algoritmo para classificar um triângulo como equilátero, escaleno ou isósceles a partir do comprimento de seus lados é apresentado no Algoritmo 7.3.\n\n\nAlgoritmo 7.3: Classificação de um triângulo em relação aos comprimentos de seus lados\n\n\n\nEm C, a codificação pode ser expressa na forma seguinte.\n#include &lt;stdio.h&gt;\n/*\nClassificação de um triângulo em relação aos comprimentos de seus lados\nRequer: Os comprimentos dos lados de um triângulo válido\nAssegura: uma classificação em equilátero, escaleno ou isósceles\n*/\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digites os comprimentos dos lados de um triângulo: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double lado1, lado2, lado3;\n    sscanf(entrada, \"%lf%lf%lf\", &lado1, &lado2, &lado3);\n\n    char *classificacao;\n    if(lado1 == lado2 && lado2 == lado3)\n        classificacao = \"equilátero\";\n    else if(lado1 == lado2 || lado2 == lado3 || lado1 == lado3)\n        classificacao = \"escaleno\";\n    else\n        classificacao = \"isósceles\";\n\n    printf(\"O triângulo é %s.\\n\", classificacao);\n\n    return 0;\n}\nDigites os comprimentos dos lados de um triângulo: 9.1 4.3 9.1\nO triângulo é escaleno.\nO programa usa comandos simples para as atribuições, o que dispensa os comandos compostos com as chaves. Na lógica da solução inicialmente verificada a hipótese dos três lados iguais (equilátero). Caso essa verificação dê falso, então há pelo menos um lado diferente e isso leva ao segundo if, que verifica a hipótese de haver algum par de lados de mesmo comprimento.\nEste programa, além do if e algumas operações lógicas com e e ou, também usa uma variável classificacao declarada como do tipo char *. Quando são feitas atribuições como as usadas no exemplo a esse tipo de variável, é feita apenas uma referência à constante e não uma atribuição convencional, na qual uma cópia do texto é guardada na variável. A manipulação de cadeias de caracteres em C é, para se bem dizer, chata e difícil. Como ela não é tão natural, acaba exigindo conhecimento de outros elementos da linguagem. O Capítulo 16 aborda esse tema com mais detalhes.\n\n\n\n\n\n\nDica\n\n\n\nNas comparações com valores double resultantes de expressões aritméticas, nunca se deve verificar pela igualdade. Os valores reais são armazenados com precisão limitada. É conveniente o uso uma tolerância nessas comparações.\n/* \nIlustração do problema de precisão nas operações com double\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    double a = 40.96;\n    double b = 6.4 * 6.4;  // 40.96\n\n    // Opção ruim\n    if(a == b)\n        printf(\"%g == %g.\\n\", a, b);\n    else {\n        printf(\"%g != %g.  :-(\\n\", a, b);\n        printf(\"Diferença: %g.\\n\\n\", a - b);\n    }\n\n    // Opção melhor, contornando o problema\n    if(fabs(a - b) &lt; 1e-5)  // cinco casas decimais...\n        printf(\"%g == %g. (o suficiente!)\\n\", a, b);\n    else {\n        printf(\"%g != %g.  :-(\\n\", a, b);\n        printf(\"Diferença: %g.\\n\\n\", a - b);\n    }\n\n    return 0;\n}\n40.96 != 40.96.  :-(\nDiferença: -7.10543e-15.\n\n40.96 == 40.96. (o suficiente!)\nNeste programa, se a diferença for menor que 0,00001 (segundo if), então os valores são considerados iguais. A tolerância, é claro, depende do contexto do problema.\n\n\nComo um último exemplo, segue o algoritmo para o cálculo das raízes reais de uma equação de segundo grau \\({ax^2 + bx + c = 0}\\) dados seus coeficientes (Algoritmo 1.1, apresentado no Capítulo 1).\n\nSua codificação em C pode ser apresentada conforme se segue.\n/*\nCálculo e apresentação das raízes reais de uma equação de segundo grau na\n    forma ax^2 + bx + c = 0\nRequer: Os coeficientes a, b e c da equação\nAssegura: as raízes reais da equação; ou mensagem que a equação é\n    inválida; ou mensagem que não há raízes reais\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite os valores de a, b e c da equação: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double a, b, c;\n    sscanf(entrada, \"%lf%lf%lf\", &a, &b, &c);\n\n    if(a == 0)\n        printf(\"Não é equação do segundo grau (a = 0).\\n\");\n    else {\n        double discriminante = pow(b, 2) - 4 * a * c;\n        if(discriminante &lt; 0)\n            printf(\"A equação não possui raízes reais.\\n\");\n        else if(discriminante &lt; 1.0e-10) {  // tolerância: &lt; 1.0e-10 é \"zero\"\n            // Uma raiz real\n            double x = -b / (2 * a);\n            printf(\"Uma raiz: %g.\\n\", x);\n        }\n        else {\n            // Duas raízes reais\n            double x1 = (-b - sqrt(discriminante)) / (2 * a);\n            double x2 = (-b + sqrt(discriminante)) / (2 * a);\n            printf(\"Raízes reais: %g e %g.\\n\", x1, x2);\n        }\n    }\n\n    return 0;\n}\nDigite os valores de a, b e c da equação: 1 -5.9 7.14\nRaízes reais: 1.7 e 4.2.",
    "crumbs": [
      "Controle de fluxo simples",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Execução condicional com `if`</span>"
    ]
  },
  {
    "objectID": "c-execucao-condicional-com-if.html#de-quem-é-esse-else",
    "href": "c-execucao-condicional-com-if.html#de-quem-é-esse-else",
    "title": "7  Execução condicional com if",
    "section": "7.3 De quem é esse else?",
    "text": "7.3 De quem é esse else?\nUm ponto relevante quando se usa if dentro de if é a quem pertence um determinado else. Para considerar esse problema é apresentado um código em C.\n/*\nIlustração do problema do else pendente\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 0;\n    int j = 0;\n\n    int k = 5;\n\n    if(k &gt; 10)\n        if (k &gt; 20)\n            i = 10;\n    else \n        j = 10;\n\n    printf(\"i = %d e j = %d.\\n\", i, j);\n    \n    return 0;\n}\ni = 0 e j = 0.\nA intenção do código seria fazer j = 10 para valores de k menores ou iguais a 10. Porém, apesar da organização visual sugerir que o else pertence ao if(k &gt; 10), ele se liga ao if(k &gt; 20). Assim, independentemente da disposição dos comandos no codigo fonte, o programa será sempre interpretado como se segue. E, neste caso, o primeiro if não possui else.\n/*\nIlustração do problema do else pendente\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 0;\n    int j = 0;\n\n    int k = 5;\n\n    if(k &gt; 10)\n        if (k &gt; 20)\n            i = 10;\n        else \n            j = 10;\n\n    printf(\"i = %d e j = %d.\\n\", i, j);\n    \n    return 0;\n}\nO else sempre se ligará ao if mais próximo da sequência das instruções. Para resolver esse problema do exemplo, é preciso isolar o if mais interno, colocando-o em um bloco, formando um comando composto.\nO resultado é apresentado na sequência.\n/*\nIlustração do problema do else pendente\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 0;\n    int j = 0;\n\n    int k = 5;\n\n    if(k &gt; 10) {\n        if (k &gt; 20)\n            i = 10;\n    }\n    else \n        j = 10;\n\n    printf(\"i = %d e j = %d.\\n\", i, j);\n    \n    return 0;\n}\ni = 0 e j = 10.\nÉ ainda interessante notar que, caso o if(k &gt; 20) tivesse seu próprio else, a ambiguidade desapareceria e o comando composto seria desnecessário.\n/*\nIlustração do problema do else pendente\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 0;\n    int j = 0;\n\n    int k = 15;\n\n    if(k &gt; 10) \n        if (k &gt; 20)\n            i = 10;\n        else\n            i = 20;\n    else \n        j = 10;\n\n    printf(\"i = %d e j = %d.\\n\", i, j);\n    \n    return 0;\n}\ni = 20 e j = 0.\n\n\n\n\n\n\nDica\n\n\n\nA manutenção da organização visual do código com as indentações corretas ajuda na identificação dos erros.",
    "crumbs": [
      "Controle de fluxo simples",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Execução condicional com `if`</span>"
    ]
  },
  {
    "objectID": "c-execucao-condicional-com-switch.html",
    "href": "c-execucao-condicional-com-switch.html",
    "title": "8  Execução condicional com switch",
    "section": "",
    "text": "8.1 Entendendo o switch\nA linguagem C provê, além do if, uma segunda estrutura para execução condicional: o switch.\nO switch é uma estrutura da linguagem usada para estabelecer uma sequência de instruções.\nA expressão é qualquer expressão que resulte em um valor escalar, como int, char ou mesmo bool. Por sua vez, comando é um bloco delimitado com chaves com uma lista de comandos que serão executados condicionalmente.\nO trecho de código seguinte ilustra a estrutura do switch com vários chamadas para a função printf. A variável valor pode ser um int, por exemplo.\nEsse código, do jeito que está apresentado, não terá nenhum de seus comandos executados. A especificação para que algo seja executado é feito por rótulos que indicam em que posição da sequência se inicia a execução.\nOs rótulos são especificados com case.\nSegue a lista de comandos com rótulos inseridos. Esses rótulos são as constantes 1, 3 e 10.\nPara essa organização, o funcionamento do switch avalia a expressão (variável valor) e inicia a execução da lista de comandos a partir do case em que houver igualdade.\nAssim, se valor for igual a 1, todos os printf são executados; se for igual a 3, a execução se inicia no printf(\"E\\n\") e vai até o final; e se for igual a 10, somente H e I são escritos. Para qualquer outro valor, nada é escrito, pois não existe o rótulo indicando em que posição da lista começa a execução.\nO programa seguinte contém a implementação completa do exemplo apresentado.\nO conceito da estrutura switch é ter uma lista de comandos e, por meio dos rótulos, indicam em que posição da lista se inicia a execução.\nPara ter um último exemplo de como essa estrutura de seleção funciona, é adicionada uma cláusula default, que indica que, se não houver nenhum rótulo coincidente, é nesse ponto que a execução se inicia.\nTalvez sejam raros os casos em que um problema consiga usar o switch conforme apresentado até o momento, visto que a lista de comandos é sempre executada até o final.\nDessa forma, é comum a inserção de uma interrupção na sequência de comandos e, para isso, é usada a instrução break. O exemplo seguinte é uma nova versão do programa, agora limitando até onde a lista executa.\nQuando um break é encontrado, o switch é interrompido naquele ponto.\nNesta versão, a mais completa e usual, mostra como, dependendo de um dado valor, apenas uma lista específica de instruções é executada.\nPara um exemplo mais prático, pode ser o problema de ler uma expressão com dois operandos e um operador aritmético simples e apresentar o resultado (Algoritmo 8.1).",
    "crumbs": [
      "Controle de fluxo simples",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Execução condicional com `switch`</span>"
    ]
  },
  {
    "objectID": "c-execucao-condicional-com-switch.html#sec-entendendo-o-switch",
    "href": "c-execucao-condicional-com-switch.html#sec-entendendo-o-switch",
    "title": "8  Execução condicional com switch",
    "section": "",
    "text": "Estrutura switch\n\n\n\nswitch ( expressão ) comando\n\n\n\n\nswitch(valor) {\n    printf(\"A\\n\");\n    printf(\"B\\n\");\n    printf(\"C\\n\");\n    printf(\"D\\n\");\n    printf(\"E\\n\");\n    printf(\"F\\n\");\n    printf(\"G\\n\");\n    printf(\"H\\n\");\n    printf(\"I\\n\");\n}\n\n\n\n\n\n\n\n\nEstrutura da rotulação com case\n\n\n\ncase constante :\n\n\n\n    switch (valor) {\n        case 1:\n            printf(\"A\\n\");\n            printf(\"B\\n\");\n            printf(\"C\\n\");\n            printf(\"D\\n\");\n        case 3:\n            printf(\"E\\n\");\n            printf(\"F\\n\");\n            printf(\"G\\n\");\n        case 10:\n            printf(\"H\\n\");\n            printf(\"I\\n\");\n    }\n\n\n\n/*\nExemplo de escolha de execução com switch\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor;\n    sscanf(entrada, \"%d\", &valor);\n\n    switch (valor) {\n        case 1:\n            printf(\"A\\n\");\n            printf(\"B\\n\");\n            printf(\"C\\n\");\n            printf(\"D\\n\");\n        case 3:\n            printf(\"E\\n\");\n            printf(\"F\\n\");\n            printf(\"G\\n\");\n        case 10:\n            printf(\"H\\n\");\n            printf(\"I\\n\");\n    }\n\n    return 0;\n}\nDigite um valor inteiro: 3\nE\nF\nG\nH\nI\n\n\n/*\nExemplo de escolha de execução com switch\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor;\n    sscanf(entrada, \"%d\", &valor);\n\n    switch (valor) {\n        case 1:\n            printf(\"A\\n\");\n            printf(\"B\\n\");\n            printf(\"C\\n\");\n            printf(\"D\\n\");\n        case 3:\n            printf(\"E\\n\");\n            printf(\"F\\n\");\n            printf(\"G\\n\");\n        case 10:\n            printf(\"H\\n\");\n            printf(\"I\\n\");\n        default:\n            printf(\"Y\\n\");\n            printf(\"Z\\n\");\n    }\n\n    return 0;\n}\nDigite um valor inteiro: 4\nY\nZ\n\n\n\n/*\nExemplo de escolha de execução com switch\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor;\n    sscanf(entrada, \"%d\", &valor);\n\n    switch (valor) {\n        case 1:\n            printf(\"A\\n\");\n            printf(\"B\\n\");\n            printf(\"C\\n\");\n            printf(\"D\\n\");\n            break;\n        case 3:\n            printf(\"E\\n\");\n            printf(\"F\\n\");\n            printf(\"G\\n\");\n            break;\n        case 10:\n            printf(\"H\\n\");\n            printf(\"I\\n\");\n            break;\n        default:\n            printf(\"Y\\n\");\n            printf(\"Z\\n\");\n    }\n\n    return 0;\n}\nDigite um valor inteiro: 1\nA\nB\nC\nD\n\n\n\n\nAlgoritmo 8.1: Cálculo de uma expressão aritmética simples a partir dos operandos e do operador.\n\n\n\n/*\nRealização de uma operação aritmética simples dados os operandos e o\n    operador\nRequer: operando1, operador e operando2\nAssegura: o resultado da operação ou mensagem se o operador for\n    desconhecido\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite uma operação aritmética (sem espaços): \");\n    fgets(entrada, sizeof entrada, stdin);\n    double operando1, operando2;\n    char operador;\n    sscanf(entrada, \"%lf%c%lf\", &operando1, &operador, &operando2);\n\n    double resultado;\n    bool eh_operador_valido = true;\n    switch (operador) {\n        case '+':\n            resultado = operando1 + operando2;\n            break;\n        case '-':\n            resultado = operando1 - operando2;\n            break;\n        case '*':\n            resultado = operando1 * operando2;\n            break;\n        case '/':\n            resultado = operando1 / operando2;\n            break;\n        default:\n            eh_operador_valido = false;\n    }\n\n    if (eh_operador_valido)\n        printf(\"%g %c %g = %g.\\n\", operando1, operador, operando2, resultado);\n    else\n        printf(\"Operador não reconhecido.\\n\");\n\n    return 0;\n}\nDigite uma operação aritmética (sem espaços): 1.75*-3.1\n1.75 * -3.1 = -5.425.",
    "crumbs": [
      "Controle de fluxo simples",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Execução condicional com `switch`</span>"
    ]
  },
  {
    "objectID": "c-execucao-condicional-com-switch.html#limitações-do-switch",
    "href": "c-execucao-condicional-com-switch.html#limitações-do-switch",
    "title": "8  Execução condicional com switch",
    "section": "8.2 Limitações do switch",
    "text": "8.2 Limitações do switch\nEmbora bastante útil, o switch serve apenas para comparações de igualdade, não permitindo verificações de intervalos, por exemplo.\nOutra limitação é que a expressão usada tem que ser inteira ou char. Valores reais não podem ser usados.",
    "crumbs": [
      "Controle de fluxo simples",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Execução condicional com `switch`</span>"
    ]
  },
  {
    "objectID": "c-escopo-basico-de-declaracoes.html",
    "href": "c-escopo-basico-de-declaracoes.html",
    "title": "9  Escopo básico de declarações",
    "section": "",
    "text": "9.1 Declarações e validade\nOs códigos fonte em C permitem muitas declarações, como as de variáveis. Este capítulo trata da declaração de variáveis e onde são válidas, além de introduzir superficialmente outras declarações da linguagem.\nO primeiro ponto é, em princípio, bastante intuitivo: para usar uma variável é preciso declará-la antes desse uso. Portanto, a validade de uma variável depende de onde, no código fonte, sua declaração aparece.\nO programa seguinte pode ser considerado para exemplificar as validades.\nNeste programa, a variável entrada existe desde a linha 9 e é válida até a linha 33. A variável em_metros inicia sua validade na linha 13, em_pes na linha 21, em_jardas na 25 e em_polegadas na 29 e, para todas, a validade termina na linha 33.\nNote-se que, porém, que nenhuma variável é válida na linha 34, depois do encerramento do bloco do main. As variáveis são válidas apenas dentro do bloco onde foram declaradas. E é importante destacar que um bloco de comandos é aquele iniciado por { e finalizado por }.\nO programa que implementa o Algoritmo 7.1 é reproduzido na sequência.\nO ponto de destaque desse código é a variável temporario usada para troca de valores. Ela é declarada dentro de um bloco de comandos, formando o comando composto condicionado pelo if. Sua validade é efêmera, pois é válida apenas da linha 18 até a 21, quando o bloco é encerrado. A tentativa de referenciar temporario fora do bloco do if gera um erro de identificador não declarado.\nNesse ponto específico do programa, é relevante perceber que a utilidade de temporario é apenas local e não há qualquer necessidade de que seja declarada como válida em todo o bloco do main.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Escopo básico de declarações</span>"
    ]
  },
  {
    "objectID": "c-escopo-basico-de-declaracoes.html#sec-declaracoes-e-validade",
    "href": "c-escopo-basico-de-declaracoes.html#sec-declaracoes-e-validade",
    "title": "9  Escopo básico de declarações",
    "section": "",
    "text": "/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n\n    // Centímetros\n    double em_centimetros = em_metros * 100;\n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n\n    // Pés\n    double em_pes = em_metros * 3.281;\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n\n    // Jardas\n    double em_jardas = em_metros * 1.094;\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n\n    // Centímetros\n    double em_polegadas = em_metros * 39.37;\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\n// Fim do código fonte\nDigite uma distância em metros: 300\n&gt; 300.0m = 30000.0cm\n&gt; 300.0m = 984.3 pés\n&gt; 300.0m = 328.2 jardas\n&gt; 300.0m = 11811.0 polegadas\n\n\n\n\n\n\n\n\nDica\n\n\n\nÉ indicado que a declaração de uma variável seja feita o mais próximo possível de seu uso, o que promove clareza de padronização ao programa.\n\n\n\n/*\nApresentação de dois valores em ordem não decrescente\nRequer: dois valores reais v1 e v2\nAssegura: v1 &lt;= v2\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite dois valores reais: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double v1, v2;\n    sscanf(entrada, \"%lf%lf\", &v1, &v2);\n\n    if(v2 &lt; v1) {\n        double temporario = v1;\n        v1 = v2;\n        v2 = temporario;\n    }\n\n    printf(\"Valores em ordem não decrescente: %g e %g.\\n\", v1, v2);\n    \n    return 0;\n}\n\n\n\n\n\n\n\n\nDica\n\n\n\nVáriáveis com uso localizado devem ser declaradas apenas dentro do bloco onde são úteis, evitando que tenham validade fora dessa abrangência.\n\n\n\n9.1.1 Duplicidade de identificadores\nNão é possível o uso do mesmo identificador no mesmo escopo de abrangência. Segue um exemplo simples que ilustra o problema.\n/*\nExemplo de declaração repetida de um identificador no mesmo escopo\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int valor = 10;\n    printf(\"valor: %d.\\n\", valor);\n    \n    int valor = 100;\n    printf(\"valor: %d.\\n\", valor);\n    \n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:10:9: error: redefinition of ‘valor’\n   10 |     int valor = 100;\n      |         ^~~~~\nmain.c:7:9: note: previous definition of ‘valor’ with type ‘int’\n    7 |     int valor = 10;\n      |         ^~~~~\nHá, porém, a possibilidade de que um mesmo identificador seja usado em um novo escopo, valendo a regra que sempre a declaração “mais local” é a válida.\n/*\nExemplo de declaração repetida de um identificador em escopos diferentes\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int valor = 10;\n    printf(\"valor: %d (antes do if).\\n\", valor);\n    \n    if (valor == 10){\n        int valor = 100;\n        printf(\"valor: %d (dentro do if).\\n\", valor);\n    }\n\n    printf(\"valor: %d (depois do if).\\n\", valor);\n\n    return 0;\n}\nvalor: 10 (antes do if).\nvalor: 100 (dentro do if).\nvalor: 10 (depois do if).\nNesse programa, uma variável chamada valor é criada dentro do bloco de comandos do condicional if e sua validade é apenas local, apesar de uma declaração mais externa de valor existir. Dentro do bloco, apenas a variável valor interna pode ser utilizada, apesar de valor externo continuar existindo. Declarações mais locais obscurecem a visão de identificadores mais externos com mesmo nome.\nApesar de isso ser possível de ser feito, não é uma boa prática redeclarar identificadores, visto que a clareza fica severamente comprometida.\n\n\n\n\n\n\nDica\n\n\n\nO uso não justificado de um mesmo identificador em escopos diferentes, porém próximos, dificulta a compreensão do código e pode levar a erros difíceis de serem localizados e corrigidos.\nO uso de identificadores iguais, porém, é válido e será usado em contextos nos quais a multiplicidade de um mesmo nome seja favorável à clareza ao invés de prejudicial.\n\n\nComo outro exemplo, o programa seguinte replica a necessidade de escrever dois valores em ordem não decrescente, porém havendo dois valores inteiros e dois valores reais.\n/*\nApresentação de dois valores em ordem não decrescente\nRequer:  dois valores inteiros vi1 e vi2 e dois valores reais vr1 e vr2\nAssegura: vi1 &lt;= vi2 e vr1 &lt;= vr2\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Obtenção dos valores\n    printf(\"Digite dois valores inteiros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int v_int_1, v_int_2;\n    sscanf(entrada, \"%d%d\", &v_int_1, &v_int_2);\n\n    printf(\"Digite dois valores reais: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double v_real_1, v_real_2;\n    sscanf(entrada, \"%lf%lf\", &v_real_1, &v_real_2);\n\n    // Verificação da ordem\n    if (v_int_2 &lt; v_int_1) {\n        int temporario = v_int_1;\n        v_int_1 = v_int_2;\n        v_int_2 = temporario;\n    }\n\n    if (v_real_2 &lt; v_real_1) {\n        double temporario = v_real_1;\n        v_real_1 = v_real_2;\n        v_real_2 = temporario;\n    }\n\n    // Apresentação de resultados\n    printf(\"Valores inteiros em ordem não decrescente: %d e %d.\\n\",\n           v_int_1, v_int_2);\n    printf(\"Valores reais em ordem não decrescente: %g e %g.\\n\",\n           v_real_1, v_real_2);\n\n    return 0;\n}\nDigite dois valores inteiros: 300 200\nDigite dois valores reais: 118.2 302.75\nValores inteiros em ordem não decrescente: 200 e 300.\nValores reais em ordem não decrescente: 118.2 e 302.75.\nÉ interessante observar que há duas variáveis chamadas temporario existindo em momentos distintos do programa. Não há, porém, problemas com essa duplicidade de uso, uma vez que suas existências são muito localizadas e não se misturam. Naturalmente cabe ao programador optar ou não por usar nomes distintos.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Escopo básico de declarações</span>"
    ]
  },
  {
    "objectID": "c-escopo-basico-de-declaracoes.html#outras-declarações-da-linguagem",
    "href": "c-escopo-basico-de-declaracoes.html#outras-declarações-da-linguagem",
    "title": "9  Escopo básico de declarações",
    "section": "9.2 Outras declarações da linguagem",
    "text": "9.2 Outras declarações da linguagem\nUm programa não declara apenas variáveis. A própria linha int main(void) dos programas é uma declaração da função main. Sem essa declaração, o sistema operacional não teria como saber por qual instrução começar a execução. Além disso, dentro de stdio.h, por exemplo, estão declarados protótipos das funções printf, sscanf, fgets e etc. Desta forma, depois do #include essas funções passam a ser conhecidas e podem ser corretamente usadas.\nUma visão completa de declarações e regras de escopo é tratada no Capítulo 19.\nEste programa seguinte ilustra uma das grandes vantagens das declarações locais suplantarem as declarações mais externas existentes.\n/*\nExemplo de declaração de uma variável lógica\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    bool remove = false;\n    printf(\"Vai remover? %s!\\n\", remove ? \"SIM\" : \"NÃO\");\n\n    return 0;\n}\nVai remover? NÃO!\nA declaração deste código cria uma variável lógica chamada remove, a qual é usada sem erros. Porém, em stdlib.h é declarada uma função remove (em inglês, do verbo to remove) que pode ser usada para apagar um arquivo. A sobreposição dos identificadores permite ter um código simples, funcional e claro sem conflito com outras declarações preexistentes.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Escopo básico de declarações</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html",
    "href": "c-organizacao-do-codigo-fonte.html",
    "title": "10  Organização do código fonte",
    "section": "",
    "text": "10.1 Documentação\nAbelson e Sussman (1996) escreveram uma vez que “programas devem ser escritos para que humanos os leiam e para que, somente como consequência, máquinas os executem”1. Em outras palavras, compiladores não ligam para como os programas são escritos, para os nomes das variáveis nem para o bom ou mau gosto do programador. Programas apenas são compilados e executados.\nA primeira etapa para se ter um bom código fonte passa longe do código C em si. Ela consiste em ter, no início do código, um comentário com a descrição do conteúdo do arquivo.\nEsse comentário estabelece a documentação do código e deve conter uma descrição de seu propósito e de seu contexto, bem como as condições necessárias para sua utilização e execução. Seguem, a título de exemplo, documentações encontradas no Github2.\nArquivo sysctl.c3:\nArquivo ubsan.c4\nArquivo seg6.py5:\nArquivo writing_a_custom_training_loop_in_tensorflow.py6 (em Python):\nO conteúdo e o nível de detalhe de cada comentário depende do programador, das regras da empresa em que trabalha ou da equipe envolvida, entre outros muitos fatores.\nNeste livro, os programas são sempre precedidos por um comentário contendo:\nSegue um exemplo simples desta forma de documentação.\nCom base nessa descrição, que é relativamente simples, não é necessário olhar os comandos do programa para se saber a que ele se propõe, o que ele requer para ser executado e qual o resultado que apresentará ao final.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#documentação",
    "href": "c-organizacao-do-codigo-fonte.html#documentação",
    "title": "10  Organização do código fonte",
    "section": "",
    "text": "/*\n * sysctl wrapper for library version of Linux kernel\n * Copyright (c) 2015 INRIA, Hajime Tazaki\n *\n * Author: Mathieu Lacage &lt;mathieu.lacage@gmail.com&gt;\n *         Hajime Tazaki &lt;tazaki@sfc.wide.ad.jp&gt;\n */\n\n// SPDX-License-Identifier: GPL-2.0-only\n/*\n * UBSAN error reporting functions\n *\n * Copyright (c) 2014 Samsung Electronics Co., Ltd.\n * Author: Andrey Ryabinin &lt;ryabinin.a.a@gmail.com&gt;\n */\n\n/*\n *  SR-IPv6 implementation\n *\n *  Author:\n *  David Lebrun &lt;david.lebrun@uclouvain.be&gt;\n *\n *\n *  This program is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU General Public License\n *    as published by the Free Software Foundation; either version\n *    2 of the License, or (at your option) any later version.\n */\n\n\"\"\"\nTitle: Writing a training loop from scratch in TensorFlow\nAuthor: [fchollet](https://twitter.com/fchollet)\nDate created: 2019/03/01\nLast modified: 2023/06/25\nDescription: Writing low-level training & evaluation loops in TensorFlow.\nAccelerator: None\n\"\"\"\n\n\n\nO propósito do programa;\nAs pré e pós-condições a que o código atende.\n\n\n/*\nCálculo de juros compostos\nRequer: o capital investido, a taxa de juros (a.m.) e o tempo\n    de investimento em meses\nAssegura: o montante final da transação\n*/",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#organização-visual",
    "href": "c-organizacao-do-codigo-fonte.html#organização-visual",
    "title": "10  Organização do código fonte",
    "section": "10.2 Organização visual",
    "text": "10.2 Organização visual\nO código fonte de um programa é escrito para que outros programadores (ou seja, pessoas) leiam e entendam os comandos e a intenção do programador.\nSegue um programa em C válido. Sua qualidade, entretanto, é discutível e é apenas uma nova versão do código que implementa o Algoritmo 1.1.\n/*\nCálculo e apresentação das raízes reais de uma equação de segundo grau na\n    forma ax^2 + bx + c = 0\nRequer: Os coeficientes a, b e c da equação\nAssegura: as raízes reais da equação; ou mensagem que a equação é\n    inválida; ou mensagem que não há raízes reais\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint main(void) { char entrada[160];printf(\n\"Digite os valores de a, b e c da equação: \"); fgets(entrada, sizeof\nentrada\n\n, stdin); double a, b,           c; sscanf(entrada\n,    \"%lf%lf%lf\" , &    a, &b, &\nc);\nif(a == 0) printf(             \"Não é equação do segundo grau (a = 0).\\n\"    )\n\n; else { double discriminante = pow\n(\nb\n                                                                             ,\n2) - 4 * a * c; if(discriminante &lt;\n0) printf(\"A equação não possui raízes reais.\\n\");\nelse\nif\n(discriminante &lt; 1.0e-10) {  double x = -b / (2*    a\n            ); printf(\"Uma raiz: %g.\\n\", x); } else { double x1 = (-b -\n            sqrt(discriminante)) / (2 * a); double x2 = (-b + \nsqrt(discriminante))\n            / (2 * a); printf(\"Raízes reais: %g e %g.\\n\", x1\n\n,\n \n x2);}}return\n 0;}\nDigite os valores de a, b e c da equação: -2 10 13\nRaízes reais: 6.07071 e -1.07071.\nPara ilustrar a dificuldade que o código, mesmo correto na sua lógica e sintaxe, proporciona quando é mal escrito, considere o problema de localizar a vírgula na expressão pow(b, 2) que calcula \\(b^2\\) para o discriminante.\nSe a ordem dos comandos estiver correta, o compilador entende o que tem que ser feito e gera o código executável sem problemas ou dificuldades. Porém, caso o compilador aponte um erro como seguinte, qual seria a dificuldade de encontrar o problema?\nmain.c: In function ‘main’:\nmain.c:28:62: warning: unused variable ‘x1’ [-Wunused-variable]\n   28 |             ); printf(\"Uma raiz: %g.\\n\", x); } else { double x1 = (-b -\n      |                                                              ^~\nmain.c:31:59: error: ‘x1’ undeclared (first use in this function);\n      |              did you mean ‘x2’?\n   31 |             / (2 * a); printf(\"Raízes reais: %g e %g.\\n\", x1\n      |                                                           ^~\n      |                                                           x2\nmain.c:31:59: note: each undeclared identifier is reported only once for each\n                    function it appears in\nmain.c: At top level:\nmain.c:35:8: error: expected identifier or ‘(’ before ‘return’\n   35 |  x2);}}return\n      |        ^~~~~~\nmain.c:36:4: error: expected identifier or ‘(’ before ‘}’ token\n   36 |  0;}\n      |    ^\nO erro acima foi causado apenas por um } inserido no lugar errado. Todas as outras mensagens são decorrentes desta falha na interpretação, a qual impede a sequência da análise e gera uma cascata de erros.\nEm suma, os programas são para as pessoas lerem.\nNo ?sec-guia-de-estilo são apresentadas as orientações de escrita seguidas neste livro, mas as seções seguintes introduzem os pontos iniciais, justificando suas importâncias.\nA escrita de um bom programa em C recai, necessariamente, na organização visual do código, ou seja, pela disposição espacial dos comandos, instruções e pontuações ao longo do código.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#indentação",
    "href": "c-organizacao-do-codigo-fonte.html#indentação",
    "title": "10  Organização do código fonte",
    "section": "10.3 Indentação",
    "text": "10.3 Indentação\nA indentação é o espaço dado da margem esquerda até o comando e ela serve para indicar a hierarquia dos comandos. Esse recurso visual é essencial para um bom programa e tem sido consistentemente usado em todos os exemplos de programas dados.\nSegue o exemplo simples de um programa que faz conversões de unidades de distância.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\nint main(void) {\nchar entrada[160];\nprintf(\"Digite uma distância em metros: \");\nfgets(entrada, sizeof entrada, stdin);\ndouble em_metros;\nsscanf(entrada, \"%lf\", &em_metros);\ndouble em_centimetros = em_metros * 100;\nprintf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\ndouble em_pes = em_metros * 3.281;\nprintf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\ndouble em_jardas = em_metros * 1.094;\nprintf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\ndouble em_polegadas = em_metros * 39.37;\nprintf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\nreturn 0;\n}\nO código acima é apresentando sem indentações e isso dificulta enxergar os comandos e até a abrangência do main. O acréscimo da indentação indica um nível para os comandos contidos no bloco da função principal e isso leva à versão seguinte do programa.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\nint main(void) {\n    char entrada[160];\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n    double em_centimetros = em_metros * 100;\n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n    double em_pes = em_metros * 3.281;\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n    double em_jardas = em_metros * 1.094;\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n    double em_polegadas = em_metros * 39.37;\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n    return 0;\n}\nA indentação tem que ser constante para um mesmo nível de comandos, o que leva a que comandos de mesmo nível sempre se iniciem na mesma coluna.\nNo exemplo seguinte há problemas com a declaração da variável entrada, que deveria estar indentada, e também com o conjunto de comandos que realizam as conversões. Neste último caso, estes comandos parecem estar de alguma forma “subordinados” aos comandos anteriores, o que não o caso.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\nint main(void) {\nchar entrada[160];\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n        double em_centimetros = em_metros * 100;\n        printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n        double em_pes = em_metros * 3.281;\n        printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n        double em_jardas = em_metros * 1.094;\n        printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n        double em_polegadas = em_metros * 39.37;\n        printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n    return 0;\n}\nSegue, por fim, um último péssimo exemplo de indentação, no qual transparece o desleixo do programador.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\nint main(void) {\n char entrada[160];\n    printf(\"Digite uma distância em metros: \");\n   fgets(entrada, sizeof entrada, stdin);\n  double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n        double em_centimetros = em_metros * 100;\n       printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n       double em_pes = em_metros * 3.281;\n       printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n          double em_jardas = em_metros * 1.094;\n        printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n     double em_polegadas = em_metros * 39.37;\n        printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n  return 0;\n}",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#linhas-de-espaçamento",
    "href": "c-organizacao-do-codigo-fonte.html#linhas-de-espaçamento",
    "title": "10  Organização do código fonte",
    "section": "10.4 Linhas de espaçamento",
    "text": "10.4 Linhas de espaçamento\nOutro ponto que auxilia uma melhor visualização do código é o uso de linhas em branco, cuja função é separar as diferentes tarefas que o programa tem que cumprir.\nÉ apresentado na sequência o programa de conversão de unidades de distância com o acréscimo de linhas em branco.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n\n    double em_centimetros = em_metros * 100;\n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n\n    double em_pes = em_metros * 3.281;\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n\n    double em_jardas = em_metros * 1.094;\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n\n    double em_polegadas = em_metros * 39.37;\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\nUma linha em branco deve ser incluída para separar as linhas com #include do início da função main, o que dá destaque a esta função.\nForam introduzidas linhas em branco dentro do main para isolar, primeiramente, os comandos que fazem a leitura da distância em metros, incluindo mensagem, leitura, declaração da variável e conversão para double. Todos estes comandos são, em essência, “obtenha a distância em metros”.\nOutros blocos que são agrupados são os de cada uma das conversões, com declaração de variável e a escrita do resultado.\nPor último aparece o indicador de sucesso da execução: return 0, também destacado dos demais comandos.\n\n\n\n\n\n\nDica\n\n\n\nAs linhas em branco devem ser, via de regra, apenas uma, devendo ser evitadas duas ou mais linhas separando os grupos de comandos.\n\n\nO agrupamento de comandos depende do programador, de forma que o mesmo código possa ter sua organização conforme o exemplo seguinte.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n\n    double em_centimetros = em_metros * 100;\n    double em_pes = em_metros * 3.281;\n    double em_jardas = em_metros * 1.094;\n    double em_polegadas = em_metros * 39.37;\n \n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\nNeste caso, o agrupamento se refere à leitura, seguida pelos cálculos e finalizada pelas apresentações dos resultados.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#um-comando-por-linha",
    "href": "c-organizacao-do-codigo-fonte.html#um-comando-por-linha",
    "title": "10  Organização do código fonte",
    "section": "10.5 Um comando por linha",
    "text": "10.5 Um comando por linha\nUma regra básica de clareza é separar os comandos de forma que cada um fique em sua própria linha.\nComo exemplo, o programa de conversão de distâncias foi reescrito de forma a violar essa regra e é apresentado na sequência.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite uma distância em metros: \"); fgets(entrada,\n          sizeof entrada, stdin);\n    double em_metros; sscanf(entrada, \"%lf\", &em_metros);\n\n    double em_centimetros = em_metros * 100; double em_pes = em_metros *\n        3.281; double em_jardas = em_metros * 1.094; double em_polegadas\n        = em_metros * 39.37;\n\n    printf(\"&gt; %.1lfm = %.1fcm\\n&gt; %.1lfm = %.1f pés\\n\", em_metros,\n           em_centimetros, em_metros, em_pes);\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas); printf(\n        \"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\nEssa versão coloca alguns comandos e declarações individuas em uma mesma linha, o que está sintaticamente correto, mas dificulta a visão dos limites entre os diversos elementos.\nÉ importante lembrar que quando os problemas se tornam mais complexos, o código será mais longo e com mais nuances, assim como terá maior número de variáveis. Nesta situação, mais preciosa essa recomendação se torna.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#padronização-de-identificadores",
    "href": "c-organizacao-do-codigo-fonte.html#padronização-de-identificadores",
    "title": "10  Organização do código fonte",
    "section": "10.6 Padronização de identificadores",
    "text": "10.6 Padronização de identificadores\nOs identificadores usados para as variáveis e demais elementos da linguagem devem ser significativos. Além disso, também devem seguir um mesmo padrão ao longo do código.\nO entendimento de um programa pode ser prejudicado se houver uma variável chamada salario_inicial e o salário final for indicado por outra com nome s_final. O uso de salario_final é, sem dúvidas, mais consistente.\nDa mesma forma, em um mesmo programa há variáveis como taxa_juros, montante_final e saldo_atual juntamente com outras como tx_br, tx_liq, sf e p, por exemplo. As abreviações excessivas não estabelecem um padrão minimamente compatível em contraposição aos nomes mais explícitos.\nNada disso implica em que não possa haver abreviações, desde que atendem à legibilidade. Se em um aplicação há variáveis para diversas taxas diferentes, o uso de tx_inicial e tx_inercial são razoáveis para o contexto. Porém todas devem prefixadas com tx_, sem misturas o prefixo taxas_.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#localização-da-declaração-de-variáveis",
    "href": "c-organizacao-do-codigo-fonte.html#localização-da-declaração-de-variáveis",
    "title": "10  Organização do código fonte",
    "section": "10.7 Localização da declaração de variáveis",
    "text": "10.7 Localização da declaração de variáveis\nEmbora uma variável possa ser declarada em inúmeras localizações dentro de um código fonte e ainda mantê-lo correto e coerente, é preciso reforçar que o local em que as declarações ocorrem favorecem o entendimento do propósito do programa e de sua lógica. Este tema é abordado de maneira rápida na Seção 9.1.\nPor hábitos “ancestrais”, de quando a linguagem C não admitia a mistura entre declarações e código, ainda persiste a prática de declarar todas as variáveis juntas no início do bloco. Assim, nas versões iniciais da linguagem os programas deveriam necessariamente declarar todas suas variáveis antes da primeira linha que tivesse um comando ou chamada de função. Segue um exemplo.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n    double em_metros, em_centimetros, em_pes, em_jardas, em_polegadas;\n\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%lf\", &em_metros);\n\n    em_centimetros = em_metros * 100;\n    em_pes = em_metros * 3.281;\n    em_jardas = em_metros * 1.094;\n    em_polegadas = em_metros * 39.37;\n\n \n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\nDigite uma distância em metros: 1.0\n&gt; 1.0m = 100.0cm\n&gt; 1.0m = 3.3 pés\n&gt; 1.0m = 1.1 jardas\n&gt; 1.0m = 39.4 polegadas\nO impacto para programas simples não é, em geral, grande. À medida que o número de linhas cresce, juntamente à complexidade da solução implementada, o “amontoado” de declarações no começo do programa prejudica a legibilidade. Muitas vezes, por exemplo, é preciso verificar se uma variável tem o tipo necessário e fazer as adequações pode trazer impactos não previstos. Por exemplo, ao alterar uma declaração de int para long int pode afetar não somente a variável de interesse, mas outras declaradas juntas.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#alinhamento-dos-finais-de-bloco",
    "href": "c-organizacao-do-codigo-fonte.html#alinhamento-dos-finais-de-bloco",
    "title": "10  Organização do código fonte",
    "section": "10.8 Alinhamento dos finais de bloco",
    "text": "10.8 Alinhamento dos finais de bloco\nAs chaves da função main estabelecem o bloco da função principal e inclui as declarações e os comandos que formam o programa. Um bloco de comandos, na forma de um comando composto, é muitas vezes necessário para incluir mais que um comando dentro de um condicional, por exemplo.\nNão é incomum que, em programas em C, venha uma sequência de vários fechamentos de bloco, ou seja, vários }. Segue um programa que calcula as raízes de uma equação \\({ax^2 + bx + c = 0}\\) (\\({\\forall a, b, c}\\)), mesmo que a equação se reduza a forma linear.\n/*\nDeterminação das raízes reais de uma equação ax^2 + bx + c = 0, sem restrições\n    aos coeficientes a, b, ou c\nPré-condições: Os valores dos coeficientes a, b e C\nPós-condições: uma ou duas raízes reais ou mensagem indicando que não há\n    raízes reais\n\nQuando a é zero, a equação é tratada como linear; caso contrário, é\nquadrática. Divisões por zero são tratadas pela divisão de double, ou\nseja, podendo resultar em 'not a number' ou +-inf.\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Considere uma equação ax^2 + bx + c = 0.\\n\"\n           \"Digite os valores a, b e c da equação: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double a, b, c;\n    sscanf(entrada, \"%lf%lf%lf\", &a, &b, &c);\n\n    if (a == 0) {\n        // Equação do primeiro grau\n        double x = -c / b;  \n        printf(\"Raiz: %g.\\n\", x);\n    }\n    else {\n        // Equação do segundo grau\n        double discriminante = pow(b, 2) - 4 * a * c;\n\n        // Determina o número de raízes reais\n        if (discriminante &lt; 0)\n            printf(\"Não há raízes reais.\\n\");\n        else if (discriminante &lt; 1e-5) {  // quase zero\n            // Raíz única\n            double x = -b / (2 * a);\n            printf(\"Raíz: %g.\\n\", x);\n        }\n        else {\n            // Duas raízes distintas\n            double x1 = (-b - sqrt(discriminante)) / (2 * a);\n            double x2 = (-b + sqrt(discriminante)) / (2 * a);\n            if (x2 &lt; x1) { // ordem não decrescente\n                double temporario = x1;\n                x1 = x2;\n                x2 = temporario;\n            }\n            printf(\"Raízes: %g e %g.\\n\", x1, x2);\n        }\n    }\n\n    return 0;\n}\nConsidere uma equação ax^2 + bx + c = 0.\nDigite os valores a, b e c da equação: -6 5 28\nRaízes: -1.7834 e 2.61673.\nÉ necessário que todos os fechamentos de bloco sejam, de alguma forma, alinhados a sua abertura. Esse alinhamento é essencial para localizar, por exemplo, um } que foi esquecido.\nNos programas apresentados neste livro, os blocos de comandos compostos são sempre iniciados na linha da estrutura que o utiliza, como um if, por exemplo.\nif(a &gt; 0) {\n    // Instruções...\n}\nelse {\n    // Outras instruções...\n}\nDesta forma, o fim do bloco fica com a mesma indentação da estrutura que o iniciou.\nPor questões de estilo (?sec-guia-de-estilo), há programadores que preferem que as chaves sejam abertas na linha consecutiva. Isso naturalmente não é um problema, desde que o padrão seja mantido para todo o código. Na sequência são apresentadas variações do posicionamento das chaves, porém em todas o alinhamento de indentação é mantido.\nif(a &gt; 0)\n{\n    // Instruções...\n}\nelse\n{\n    // Outras instruções...\n}\nif(a &gt; 0) {\n    // Instruções...\n} else {\n    // Outras instruções...\n}\nComo contra exemplo, na sequência é apresentado o programa anterior usando uma “indentação alternativa”, que alinha o } com seu respectivo }, qualquer que seja sua posição. É preciso observer que o resultado quebra a visualização do código e dificulta exatamente saber onde termina cada bloco.\n/*\nDeterminação das raízes reais de uma equação ax^2 + bx + c = 0, sem restrições\n    aos coeficientes a, b, ou c\nPré-condições: Os valores dos coeficientes a, b e C\nPós-condições: uma ou duas raízes reais ou mensagem indicando que não há\n    raízes reais\n\nQuando a é zero, a equação é tratada como linear; caso contrário, é\nquadrática. Divisões por zero são tratadas pela divisão de double, ou\nseja, podendo resultar em 'not a number' ou +-inf.\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Considere uma equação ax^2 + bx + c = 0.\\n\"\n           \"Digite os valores a, b e c da equação: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double a, b, c;\n    sscanf(entrada, \"%lf%lf%lf\", &a, &b, &c);\n\n    if (a == 0) {\n        // Equação do primeiro grau\n        double x = -c / b;  \n        printf(\"Raiz: %g.\\n\", x);\n                }\n    else {\n        // Equação do segundo grau\n        double discriminante = pow(b, 2) - 4 * a * c;\n\n        // Determina o número de raízes reais\n        if (discriminante &lt; 0) \n            printf(\"Não há raízes reais.\\n\");\n        else if (discriminante &lt; 1e-5) {  // quase zero\n            // Raíz única\n            double x = -b / (2 * a);\n            printf(\"Raíz: %g.\\n\", x);\n                                       }\n        else {\n            // Duas raízes distintas\n            double x1 = (-b - sqrt(discriminante)) / (2 * a);\n            double x2 = (-b + sqrt(discriminante)) / (2 * a);\n            if (x2 &lt; x1) { // ordem não decrescente\n                double temporario = x1;\n                x1 = x2;\n                x2 = temporario;\n                         }\n            printf(\"Raízes: %g e %g.\\n\", x1, x2);\n             }\n         }\n\n    return 0;\n               }\nConsidere uma equação ax^2 + bx + c = 0.\nDigite os valores a, b e c da equação: -6 5 28\nRaízes: -1.7834 e 2.61673.\n\n\n\n\n\n\nDica\n\n\n\nA maioria dos editores de programas atualmente já provê, ao digitar, uma alinhamento adequado das chaves, o que facilita a digitação. É preciso cuidar para que a própria edição do código não acabe com o alinhamento inadvertidamente.\n\n\n\n\n\n\n\n\nDica\n\n\n\nO auto-formatador é um recurso muito comum aos IDEs de programação. O uso desse recurso pode ser amplamente empregado!",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#comentários",
    "href": "c-organizacao-do-codigo-fonte.html#comentários",
    "title": "10  Organização do código fonte",
    "section": "10.9 Comentários",
    "text": "10.9 Comentários\nComentários devem ser esparsos e minimalistas no programa. Um programa que precisa de muitos comentário é porque o código não está bem escrito. A versão seguinte do programa do peso ideal inclui apenas dois comentários considerados pertinentes. Eles apenas guiam o humano que lê o código para que localize facilmente o significado dos dois cálculos.\n/*\nCálculo estimado da massa ideal de uma pessoa baseada em seu sexo biológico\ne sua altura\nRequer: o sexo biológico (masculino ou feminino) e a altura em metros\nAssegura: a massa ideal da pessoa apresentada (kg)\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite o sexo (M ou F) e a altura em quilogramas: \");\n    fgets(entrada, sizeof entrada, stdin);\n    char sexo;\n    double altura;\n    sscanf(entrada, \"%c%lf\", &sexo, &altura);\n\n    double massa_ideal;\n    if(sexo == 'F')\n        massa_ideal = 62.1 * altura - 44.7;  // feminino\n    else\n        massa_ideal = 72.7 * altura - 58;  // masculino\n\n    printf(\"Massa ideal: %.1fkg.\", massa_ideal);\n\n    return 0;\n}\nEmbora a comparação sexo == 'F' seja suficiente, não custa nem atrapalha indicar a diferença entre as duas fórmulas.\nEm nível próximo ao exagero, considerando-se um programa curto como esse, ainda é possível ter comentários indicando a razão dos agrupamentos de comandos.\n/*\nCálculo estimado da massa ideal de uma pessoa baseada em seu sexo biológico\ne sua altura\nRequer: o sexo biológico (masculino ou feminino) e a altura em metros\nAssegura: a massa ideal da pessoa apresentada (kg)\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Obtenção de sexo biológico e altura\n    printf(\"Digite o sexo (M ou F) e a altura em quilogramas: \");\n    fgets(entrada, sizeof entrada, stdin);\n    char sexo;\n    double altura;\n    sscanf(entrada, \"%c%lf\", &sexo, &altura);\n\n    // Cálculo da massa ideal\n    double massa_ideal;\n    if(sexo == 'F')\n        massa_ideal = 62.1 * altura - 44.7;  // feminino\n    else\n        massa_ideal = 72.7 * altura - 58;  // masculino\n\n    // Apresentação do resultado\n    printf(\"Massa ideal: %.1fkg.\", massa_ideal);\n\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nÉ importante não “supercomentar” um programa. O excesso de comentários tende a tornar o código ilegível.\nO exemplo seguinte pertence à classe “não faça assim”.\n/*\nCálculo estimado da massa ideal de uma pessoa baseada em seu sexo biológico\ne sua altura\nRequer: o sexo biológico (masculino ou feminino) e a altura em metros\nAssegura: a massa ideal da pessoa apresentada (kg)\n*/\n\n// Inclusão dos arquivos de cabeçalho\n#include &lt;stdio.h&gt;  // funções de entrada e saída\n\n// Programa principal\nint main(void) {\n    // Variável para a leitura da linha\n    char entrada[160];\n\n    // Obtenção de sexo biológico e altura\n    printf(\"Digite o sexo (M ou F) e a altura em quilogramas: \");\n    fgets(entrada, sizeof entrada, stdin);  // leitura da linha digitada\n    // Declaração das variáveis de entrada\n    char sexo;  // para o sexo biológico\n    double altura;  // para a altura da pessoa\n    // Conversão da linha para obtenção dos valores\n    sscanf(entrada, \"%c%lf\", &sexo, &altura);\n\n    // Declaração da massa ideal\n    double massa_ideal;\n\n    // Verificação do cálculo conforme feminino ou masculino\n    // (se o sexo for diferente de 'F', assume que seja 'M')\n    if(sexo == 'F')\n        // Realização do cálculo para o sexo feminino\n        massa_ideal = 62.1 * altura - 44.7;\n    else\n        // Realização do cálculo para o sexto masculino\n        massa_ideal = 72.7 * altura - 58;\n\n    // Apresentação do resultado\n    printf(\"Massa ideal: %.1fkg.\", massa_ideal);  // massa ideal em kg\n\n    // Indicação de término do programa com sucesso\n    return 0;\n}\nNesta versão, há comentários óbvios (como em double altura;  // para a altura da pessoa) e até a visualização da estrutura do if, que é simples, fica um tanto comprometida com o excesso de informações.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#organização-consistente-do-código",
    "href": "c-organizacao-do-codigo-fonte.html#organização-consistente-do-código",
    "title": "10  Organização do código fonte",
    "section": "10.10 Organização consistente do código",
    "text": "10.10 Organização consistente do código\nA organização do código deve ser consistente. As conversões de distância podem usar um programa correto, porém inconsistente quanto a sua organização. Essa é uma situação que deve ser firmemente evitada.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    double em_centimetros;\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n\n    em_centimetros = em_metros * 100;\n    double em_pes = em_metros * 3.281;\n \n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n\n    double em_jardas = em_metros * 1.094, em_polegadas;\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n\n    em_polegadas = em_metros * 39.37;\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\nDigite uma distância em metros: 10\n&gt; 10.0m = 1000.0cm\n&gt; 10.0m = 32.8 pés\n&gt; 10.0m = 10.9 jardas\n&gt; 10.0m = 393.7 polegadas\nNeste programa pode ser até complicado localizar em que momento houve a declaração da variável em_polegadas, por exemplo.\n\n\n\n\nAbelson, Harold, e Gerald Jay Sussman. 1996. Structure and interpretation of computer programs. The MIT Press.",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-organizacao-do-codigo-fonte.html#footnotes",
    "href": "c-organizacao-do-codigo-fonte.html#footnotes",
    "title": "10  Organização do código fonte",
    "section": "",
    "text": "Tradução livre de “programs must be written for people to read, and only incidentally for machines to execute”.↩︎\nGithub: https://github.com.↩︎\nhttps://github.com/libos-nuse/net-next-nuse/blob/46e2206969943ba3fb87441dee0b433624daf35c/arch/lib/sysctl.c.↩︎\nhttps://github.com/KSPP/linux/blob/e0756cfc7d7cd08c98a53b6009c091a3f6a50be6/lib/ubsan.c.↩︎\nhttps://github.com/linux-wpan/linux-wpan-next/blob/107bc0aa95ca572df42da43c30a2079266e992e4/net/ipv6/seg6.c.↩︎\nhttps://github.com/keras-team/keras/blob/419973ee15ecd0e2d085e077399ce3bd5437df15/guides/writing_a_custom_training_loop_in_tensorflow.py.↩︎",
    "crumbs": [
      "Organização geral do código",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Organização do código fonte</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-while.html",
    "href": "c-repeticoes-com-while.html",
    "title": "11  Repetições com while",
    "section": "",
    "text": "11.1 A estrutura de repetição while\nA linguagem C permite laços de repetição usando while, for e do while. Neste capítulo a estrutura e aspectos lógicos do while são apresentados. O for é abordado no Capítulo 12 e o do while, no Capítulo 13.\nA estrutura de repetição que o while implementa pode ser chamada de indefinida, pois o número de repetições depende de uma condição que se altera ao longo do tempo. Sua estrutura é apresentada na sequência.\nO uso dessa estrutura é intuitivo: enquanto a expressão_lógica for avaliada como verdadeira, o comando é executado. Este último pode ser um comando simples terminado em ponto e vírgula ou um comando composto delimitado por chaves.\nO while sempre testa a condição antes de iniciar cada execução, o que leva à possibilidade que nada seja repetido se a condição já for falsa previamente. Caso a condição seja verdadeira, todo os comandos condicionados são executados antes de ser feita nova verificação.\nPara que a estrutura de repetição em si faça sentido, em comando deve haver alguma alteração que leve a condição a se tornar falsa em algum momento.\nSegue um exemplo simples de uso do while na forma de um programa que implementa o Algoritmo 11.1.\nA implementação desse algoritmo em C pode ser dada como o código seguinte.\nO mapeamento do Algoritmo 11.1 para C é bastante direto. Inicialmente é feita a primeira leitura, que pode ser tanto um valor válido quanto o valor sentinela e, em seguida, é feito o teste. Sendo bem sucedida a verificação (i.e, não é o sentinela), é feita apresentado o resultado da conversão de unidade e solicitado o próximo valor da sequência. Este ciclo de verificação e execução é repetido, sendo encerrado quando a verificação se torna falsa e return 0 é finalmente executado.\nSe a sequência for vazia e na entrada de dados constar apenas o valor sentinela, a condição do while falha já na primeira tentativa e o programa se encerra sem que nenhuma conversão seja feita.\nOutro ponto curioso sobre a implementação é a verificação de igualdade feita com um valor double. Neste caso, a tolerância não é necessária, pois pressao_mmhg não é o resultado calculado e, portanto, quando for digitado o valor nulo, a conversão será exata.\nPara outro exemplo, segue um algoritmo para contabilização do resultado de uma pesquisa, que considera",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Repetições com `while`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-while.html#a-estrutura-de-repetição-while",
    "href": "c-repeticoes-com-while.html#a-estrutura-de-repetição-while",
    "title": "11  Repetições com while",
    "section": "",
    "text": "Estrutura do while\n\n\n\nwhile ( expressão_lógica ) comando\n\n\n\n\n\n\n\n\nAlgoritmo 11.1: Conversão de unidades de pressão para uma sequência de valores.\n\n\n\n\n/*\nConversão de uma sequência de valores de pressão dadas em mmHg para atm,\n    usando um valor nulo como sentinela\nRequer: Uma sequência potencialmente vazia de valores de pressão (mmHg)\n    não nulos seguidos por um valor sentinela nulo\nAssegura: O valor de cada medida de pressão convertido para atm\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite o valor da pressão (mmHg) ou 0 para terminar: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double pressao_mmhg;\n    sscanf(entrada, \"%lf\", &pressao_mmhg);\n\n    while (pressao_mmhg != 0) {\n        double pressao_atm = pressao_mmhg / 760;\n        printf(\"Pressão em ATM: %.2f.\\n\", pressao_atm);\n\n        printf(\"Digite o valor da pressão (mmHg) ou 0 para terminar: \");\n        fgets(entrada, sizeof entrada, stdin);\n        sscanf(entrada, \"%lf\", &pressao_mmhg);\n    }\n\n    return 0;\n}\nDigite o valor da pressão (mmHg) ou 0 para terminar: 500\nPressão em ATM: 0.66.\nDigite o valor da pressão (mmHg) ou 0 para terminar: 1000\nPressão em ATM: 1.32.\nDigite o valor da pressão (mmHg) ou 0 para terminar: 2565.26\nPressão em ATM: 3.38.\nDigite o valor da pressão (mmHg) ou 0 para terminar: 760.0\nPressão em ATM: 1.00.\nDigite o valor da pressão (mmHg) ou 0 para terminar: 0",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Repetições com `while`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-while.html#o-double-nas-verificações-do-while",
    "href": "c-repeticoes-com-while.html#o-double-nas-verificações-do-while",
    "title": "11  Repetições com while",
    "section": "11.2 O double nas verificações do while",
    "text": "11.2 O double nas verificações do while\nUm cuidado essencial ao programador são as verificações que, embora façam sentido no código, falham por conta da precisão dos tipos numéricos reais, como double ou float.\nPara exemplificar essa questão, o trecho de código seguinte pode ser considerado.\ndouble a = 0;\nwhile (a != 1) {\n    printf(\"a = %g.\\n\", a);\n    a += 0.1;\n}\nEssa repetição nunca termina, pois a nunca será igual a 1. Na precisão dupla que o double proporciona, o valor mais próximo de 0,1 é, na realidade, 0.100000000000000005551115123126. Assim, quando se espera que a variável tenha valor 1, ha uma diferença de 1,11022 \\(\\times\\) 10-6 pelos erros acumulados.\nAssim, salvaguardas devem ser adotadas para evitar essas ocorrências.\nNo exemplo dado, uma solução seria interromper a repetição caso o valor de a ultrapassasse 1.\ndouble a = 0;\nwhile (a &lt;= 1) {  // garantia de não ultrapassar o limite\n    printf(\"a = %g.\\n\", a);\n    a += 0.1;\n}\nOutra alternativa é o estabelecimento de uma tolerância.\ndouble a = 0;\nwhile (fabs(a - 1) &lt; 0.00001) {  // considera próximo o suficiente\n    printf(\"a = %g.\\n\", a);\n    a += 0.1;\n}\n\n\n\n\n\n\nCuriosidade\n\n\n\nNo exemplo de incremento desta seção foi destacado que 0,1 não tem representação exata em um double. O valor 0,25, porém, é exato. Nesse caso, o código seguinte funcionaria conforme o esperado.\ndouble a = 0;\nwhile (a != 1) {\n    printf(\"a = %g.\\n\", a);\n    a += 0.25;\n}\nMesmo assim, recomenda-se fortemente que a igualdade ou desigualdade não seja empregada. O uso de while (a &lt;= 1) deve ser usado mesmo neste caso.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Repetições com `while`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-while.html#repetições-baseadas-na-entrada",
    "href": "c-repeticoes-com-while.html#repetições-baseadas-na-entrada",
    "title": "11  Repetições com while",
    "section": "11.3 Repetições baseadas na entrada",
    "text": "11.3 Repetições baseadas na entrada\nMuitas das repetições nos programas são necessárias para processar uma sequência de dados de entrada. De forma geral, o while é usado quando não se conhece a quantidade de repetições que serão executadas, relacionadas neste caso ao número de dados que servirão como entrada para o programa.\nNesse contexto, há duas formas importantes para a entrada, uma usando um valor sentinela (que indica o fim dos dados) e outra que reconhece que os dados acabaram por si, em um indicador explícito.\n\n11.3.1 Entrada com sentinela\nUma forma comum de entrada de dados é o uso de um valor sentinela que indica o fim dos dados. O programa seguinte apresenta uma sequência de leituras para a soma de valores inteiros maiores que zero, usando o valor nulo como sentinela para indicar o fim dos dados.\n/*\nExemplo de leitura de valores inteiros positivos, usando o zero como sentinela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor inteiro positivo ou zero para terminar: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor;\n    sscanf(entrada, \"%d\", &valor);\n\n    while (valor != 0) {\n        printf(\"Valor digitado: %d.\\n\", valor);\n\n        printf(\"Digite um valor inteiro positivo ou zero para terminar: \");\n        fgets(entrada, sizeof entrada, stdin);\n        sscanf(entrada, \"%d\", &valor);\n    }\n    printf(\"Encerrado!\\n\");\n\n    return 0;\n}\nDigite um valor inteiro positivo ou zero para terminar: 12\nValor digitado: 12.\nDigite um valor inteiro positivo ou zero para terminar: 26\nValor digitado: 26.\nDigite um valor inteiro positivo ou zero para terminar: 13\nValor digitado: 13.\nDigite um valor inteiro positivo ou zero para terminar: 3\nValor digitado: 3.\nDigite um valor inteiro positivo ou zero para terminar: 20\nValor digitado: 20.\nDigite um valor inteiro positivo ou zero para terminar: 0\nEncerrado!\nNão é incomum o programador optar por expandir o conceito do valor sentinela. Sem prejuízo aos propósitos do programa original, o programador poderia usar na condição do while a a expressão valor &gt; 0, o que incluiria qualquer valor negativo como sentinela.\n\n\n11.3.2 Detecção do encerramento do fluxo de entrada\nOutra alternativa para indicar o fim da sequência de dados é o encerramento da entrada em si. Em sistemas Linux, ao se digitar Ctrl-D em uma linha vazia é indicado ao programa que a entrada de dados foi encerrada. No Windows, o equivalente é digitar Ctrl-Z seguido de ENTER.\nUma leitura com função fgets é capaz de entender o encerramento dos dados. Essa função, como outras funções, retorna um valor resultante, o qual tem sido sistematicamente ignorado. Como exemplo, os comandos seguintes fazem uma leitura e apresentam o resultado lido. Neste caso, o valor de retorno do fgets é ignorado.\nchar entrada[160];\nfgets(entrada, sizeof entrada, stdin);\nprintf(\"%s\", entrada);\nEntretanto, essa função retorna um valor que pode ser verificado. O valor NULL é retornado em caso de erro. Assim, com uma verificação extra, a leitura da linha poderia ser escrita conforme apresentado na sequência.\nchar entrada[160];\nif (fgets(entrada, sizeof entrada, stdin) != NULL)\n    printf(\"%s\", entrada);\nelse\n    printf(\"Houve algum problema com a leitura.\\n\");\nO “problema” mais comum da falha na leitura é o fim do fluxo de entrada. Assim, um programa pode usar essa verificação para repetir a leitura condicionalmente. O programa seguinte exemplifica leituras de linha de texto e contagem do número de linhas1.\n/*\nContagem do número de linhas no fluxo de entrada\nRequer: uma sequência de linhas de texto\nAssegura: a apresentação do número de linhas desse texto\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite seu texto linha a linha (Ctrl-D) para terminar.\\n\");\n    int contador_linhas = 0;\n    while (fgets(entrada, sizeof entrada, stdin) != NULL)\n        contador_linhas++;\n\n    printf(\"Número de linhas: %d.\\n\", contador_linhas);\n\n    return 0;\n}\nDigite seu texto linha a linha (Ctrl-D) para terminar.\nCAPITULO V \nO AGREGADO \n\nNem sempre ia naquele passo vagaroso e rígido. Também se descompunha em \nacionados, era muita vez rápido e lépido nos movimentos, tao natural nesta como \nnaquela maneira. Outrossim, ria largo, se era preciso, de um grande riso sem \nvontade, mas comunicativo, a tal ponto as bochechas, os dentes, os olhos, toda a \ncara, toda a pessoa, todo o mundo pareciam rir nele. Nos lances graves, \ngravíssimo.\nNúmero de linhas: 9.\n\n\n\n\n\n\nDica\n\n\n\nAs funções de leitura, quando detectam o fim do fluxo de entrada associado a stdin, ignoram entradas subsequentes. Assim, depois de terminada uma sequência com Ctrl-D, outras chamadas a fgets são ignoradas. Isso acontece devido a um controle do fluxo feito pelo sistema operacional. Entretanto, é possível retomar a leitura com clearerr, que limpa o indicador de fim de fluxo.\n/*\nContagem do número de linhas no fluxo de entrada\nRequer: uma sequência de linhas de texto\nAssegura: a apresentação do número de linhas desse texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite seu texto linha a linha (Ctrl-D) para terminar.\\n\");\n    int contador_linhas = 0;\n    while (fgets(entrada, sizeof entrada, stdin) != NULL)\n        contador_linhas++;\n\n    printf(\"Número de linhas: %d.\\n\", contador_linhas);\n\n    // Reassumindo a leitura de stdin\n    clearerr(stdin);\n    printf(\"Digite seu nome: \");\n    char nome[80];\n    fgets(nome, sizeof nome, stdin);\n    nome[strlen(nome) - 1] = '\\0';  // eliminação do \\n\n    printf(\"Obrigado, %s, por sua digitação!\\n\", nome);\n\n    return 0;\n}\nSem a chamada a clearerr, a leitura do nome é ignorada.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Repetições com `while`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-while.html#exemplos",
    "href": "c-repeticoes-com-while.html#exemplos",
    "title": "11  Repetições com while",
    "section": "11.4 Exemplos",
    "text": "11.4 Exemplos\nEsta seção apresenta alguns exemplos mais realistas do uso do while na codificação de alguns algoritmos.\n\n11.4.1 Contagem regressiva\nUm exemplo simples de repetição com while é apresentado na sequência. O programa implementa um cronômetro regressivo simples e segue o Algoritmo 11.2.\n\n\nAlgoritmo 11.2: Contagem regressiva segundo a segundo\n\n\n\n/*\nRealiza a contagem regressiva para um tempo determinado\nRequer: o tempo para contagem (inteiro)\nAssegura: a apresentação de uma contagem regressiva e mensagem de finalização\n*/\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite o tempo para contagem.\\n\"\n           \"Exemplos: '10' ou '10s' para 10s, '3m' para 3 minutos \"\n           \"ou '5h' para 5 horas.\\n\"\n           \"Tempo: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int tempo_restante;\n    char unidade_tempo = 's';  // padrão: segundos\n    sscanf(entrada, \"%d%c\", &tempo_restante, &unidade_tempo);\n\n    // Conversão de unidades se necessário; senão considera segundos\n    switch (unidade_tempo) {\n        case 'h':  // horas\n            tempo_restante = tempo_restante * 3600;\n            break;\n        case 'm':  // minutos\n            tempo_restante = tempo_restante * 60;\n            break;\n    }\n\n    // Contagem\n    printf(\"Contagem para %d segundo(s):\\n\", tempo_restante);\n    while (tempo_restante &gt;= 0) {\n        int tempo_horas = tempo_restante / 3600;\n        int tempo_minutos = (tempo_restante - tempo_horas * 3600) / 60;\n        int tempo_segundos = tempo_restante % 60;\n        printf(\"&gt; Tempo restante: %02dh %02dmin %02ds\\r\", tempo_horas,\n               tempo_minutos, tempo_segundos);\n        fflush(stdout);\n\n        sleep(1);  // aguarda 1 segundo\n        tempo_restante--;\n    }\n    printf(\"\\nObrigado pela paciência!\\n\");\n\n    return 0;\n}\nEste código usa o while para a contagem regressiva. A cada execução, é apresentando o valor do cronômetro (dado por tempo_restante) e esse tempo é decrescido de um segundo. A chamada sleep(1) (declarada em unistd.h) suspende a execução do processo por um segundo antes de retomar a contagem.\nValem ainda dois comentários sobre esse programa. O primeiro é sobre o uso de \\r ao apresentar o cronômetro. Esse caractere faz com que o cursor do terminal volte para o início da linha sem passar para a linha de baixo e, assim, o próximo printf sobrescreve o horário anterior, atualizando-o. O outro ponto é o uso da função fflush(stdout) (incluído via stdio.h), a qual faz com que o texto escrito pelo programa seja imediatamente colocado no terminal. Sem ele, há atrasos na escrita e o contador parece irregular.\nO programa de contagem regressiva não é preciso. Ele se baseia em intervalos de um segundo, mas a cada repetição outras operações são feitas. A longo prazo, o cronômetro ficará atrasado em relação ao tempo real. Este programa é para ser um mero exemplo da repetição e não tem maiores pretensões.\n\n\n11.4.2 Atualização de saldo\nUm saldo bancário tem um valor inicial e, dependendo de uma série de transações de crédito ou débito, o montante é modificado. Esta é a proposta do Algoritmo 11.3.\n\n\nAlgoritmo 11.3: Atualização de saldo bancário a partir de créditos e débitos.\n\n\n\nA implementação em C apresentada na sequência considera que cada transação é entrada expressando o tipo da transação com C para crédito ou D para débito em uma linha e o valor monetário em outra. Não há valor sentinela para finalizar a entrada e o programa assume que o encerramento do fluxo de entrada implica no fim dos dados.\n/*\nAtualização de um saldo bancário a partir de uma sequência de movimentações de crédito ou débito ocorridas em um período\nRequer: o saldo inicial e uma sequência de transações, cada um fazendo indicando separadamente o tipo 'C' ou 'D' (crédito ou débito) e o valor\nAssegura: a apresentação do saldo atualizado\n\nTransações não reconhecidas são rejeitadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Obtenção do saldo inicial\n    printf(\"Digite o saldo inicial: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double saldo;\n    sscanf(entrada, \"%lf\", &saldo);\n\n    // Atualização do saldo de acordo com as transações\n    printf(\"Digite Ctrl-D (Linux) ou Ctrl-Z (Windows) para encerrar.\\n\\n\"\n           \"Tipo (C ou D): \");\n    while (fgets(entrada, sizeof entrada, stdin) != NULL) {  // leitura do tipo\n        char tipo_transacao = '*';  // '*' = inválido\n        sscanf(entrada, \"%c\", &tipo_transacao);\n\n        printf(\"Valor: R$ \");\n        double valor_transacao;\n        fgets(entrada, sizeof entrada, stdin);  // leitura do valor\n        sscanf(entrada, \"%lf\", &valor_transacao);\n\n        switch (tipo_transacao) {\n            case 'C':\n                saldo += valor_transacao;\n                break;\n            case 'D':\n                saldo -= valor_transacao;\n                break;\n            default:\n                printf(\"Transação não reconhecida (%c).\\n\", tipo_transacao);\n        }\n\n        printf(\"Tipo (C ou D): \");  // próxima transação\n    }\n\n    // Apresentação do saldo atualizado\n    printf(\"\\nSaldo final: R$ %.2f.\\n\", saldo);\n\n    return 0;\n}\nDigite o saldo inicial: 5800.00\nDigite Ctrl-D (Linux) ou Ctrl-Z (Windows) para encerrar.\n\nTipo (C ou D): D\nValor: R$ 300.00\nTipo (C ou D): C\nValor: R$ 82.50\nTipo (C ou D): C\nValor: R$ 181.00\nTipo (C ou D): D\nValor: R$ 1.25\nTipo (C ou D): D\nValor: R$ 789.42\nTipo (C ou D): \nSaldo final: R$ 4972.83.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Repetições com `while`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-while.html#footnotes",
    "href": "c-repeticoes-com-while.html#footnotes",
    "title": "11  Repetições com while",
    "section": "",
    "text": "O texto digitado como exemplo foi extraído de Dom Casmurro, de Machado de Assis, obtido em http://www.educadores.diaadia.pr.gov.br/arquivos/File/2010/literatura/obras_completas_literatura_brasileira_e_portuguesa/MACHADO_ASSIS/DCASMURRO/CASMURRO5.HTM.↩︎",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Repetições com `while`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-for.html",
    "href": "c-repeticoes-com-for.html",
    "title": "12  Repetições com for",
    "section": "",
    "text": "12.1 A estrutura de repetição for\nA linguagem C permite laços de repetição, sendo um deles dado pelo for. Neste capítulo essa estrutura é abordada.\nO for é um comando usado para repetições definidas, ou seja, para as quais o número de vezes que os comandos serão executados já é conhecida. Por exemplo, se houver um dado disponível para cada hora do dia, sabe-se de antemão que há 24 dados e uma repetição com esse número de vezes pode ser empregado.\nNa linha das demais estruturas de fluxo, também o for admite a repetição de um único comando, que pode ser simples ou composto. Suas demais partes são:\nO seguinte trecho de código pode ser usado como exemplo.\nEle pode ser considerado como “para i variando de 0 até 9” em um total de 10 repetições. A variável i é declarada dentro do for e, como tal, possui validade apenas nesse escopo. Seu valor inicial é zero e essa atribuição é feita antes das repetições. Antes de qualquer repetição, a condição i &lt; 10 é avaliada e o printf somente é executado se a condição for verdadeira. Terminada a execução do comando do for, o incremento i++ é executado, alterando o valor de i antes da próxima verificação de continuidade.\nEm termos gerais, o for exemplificado é absolutamente equivalente trecho seguinte.\nObservar que todo o código está dentro de um comando composto (entre chaves) é importante, visto que i tem validade exclusiva dentro do bloco de comandos.\nOutros exemplos de repetição com for são apresentados na sequência.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Repetições com `for`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-for.html#a-estrutura-de-repetição-for",
    "href": "c-repeticoes-com-for.html#a-estrutura-de-repetição-for",
    "title": "12  Repetições com for",
    "section": "",
    "text": "Estrutura do for\n\n\n\nfor ( iniciação ; condição_de_continuidade ; incremento ) comando\n\n\n\n\nA iniciação, a qual é composta pela atribuição inicial e é executada uma única vez antes das repetições;\nA condição_de_continuidade, cujo valor verdadeiro é condição para iniciar uma execução de comando;\nO incremento, o qual é usado para atualizar o valor da variável usada no laço.\n\n\nfor (int i = 0; i &lt; 10; i++)\n    printf(\"%d \", i);\n\n\n{\n    int i = 0;  // iniciação\n    while (i &lt; 10) {  // condição de continuidade\n        printf(\"%d \", i);  // comando\n        i++;  // incremento\n    }\n}\n\n\n// contagem de 10 até 1\nfor (int i = 10; i &gt; 0; i--)\n    printf(\"%d \", i);\n// contagem de 1 até 100\nfor (int i = 1; i &lt;= 100; i++)\n    printf(\"%d \", i);\n// contagem de 0 a 1 de 0,1 em 0,1\nfor (double i = 0; i &lt;= 1; i += 0.1)\n    printf(\"%d \", i);",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Repetições com `for`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-for.html#for-versus-while",
    "href": "c-repeticoes-com-for.html#for-versus-while",
    "title": "12  Repetições com for",
    "section": "12.2 for versus while",
    "text": "12.2 for versus while\nConforme apresentado na seção anterior, a estrutura do for equivale à de um while. A questão, então, é porque usar o for?\nA estrutura do for é um recurso vastamente utilizada nas linguagens de programação e comum também no pseudocódigo. Como ela é indicada para repetições já previsíveis, ter todas as informações necessárias logo no início do comando ajuda a compreensão do propósito do trecho de código.\nEm princípio, ao se olhar a linha em que está o for já se tem ideia de como começa e como termina. O uso do while, por sua vez, indica uma imprevisibilidade do término, o que leva um eventual leitor do programa a procurar como os dados são modificados e como isso afeta a condição da repetição.\n\n\n\n\n\n\nDica\n\n\n\nNão se deve usar um for para substituir um while nem um whilepara substituir um for.\nQuando o número de repetições é conhecido, o for deve ser empregado; se esse número estiver em aberto, a melhor opção é o while.\nPorém, não é incomum o uso do while em repetições definidas.\nUm discussão mais ampla sobre o uso do for, complementando esta dica, está na seção Capítulo 15.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Repetições com `for`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-for.html#repetições-baseadas-na-entrada",
    "href": "c-repeticoes-com-for.html#repetições-baseadas-na-entrada",
    "title": "12  Repetições com for",
    "section": "12.3 Repetições baseadas na entrada",
    "text": "12.3 Repetições baseadas na entrada\nUma forma de se processar uma sequência de valores é prefixá-la com a quantidade de valores de entrada. Assim, se existirem 25 dados para serem processados, o valor 25 é introduzido antes dos dados, o que viabiliza ter, antes da repetição, o número de vezes de execução e, assim, usar o for adequadamente e com clareza.\nSegue um exemplo simples de um programa que apresenta os primeiros \\(n\\) números ímpares naturais.\n/*\nApresentação dos n primeiros números naturais ímpares\nRequer: a quantidade n\nAssegura: a apresentação dos n primeiros números ímpares\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite a quantidade desejada de ímpares: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int quantidade;\n    sscanf(entrada, \"%d\", &quantidade);\n\n    for(int i = 0; i &lt; quantidade; i++)\n        printf(\"%d \", 2 * i + 1);\n    printf(\"\\n\");\n\n    return 0;\n}\nDigite a quantidade desejada de ímpares: 12\n1 3 5 7 9 11 13 15 17 19 21 23",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Repetições com `for`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-for.html#exemplos",
    "href": "c-repeticoes-com-for.html#exemplos",
    "title": "12  Repetições com for",
    "section": "12.4 Exemplos",
    "text": "12.4 Exemplos\nNesta seção são apresentados alguns exemplos de programas simples com repetições para as quais o for é a escolha mais direta.\n\n12.4.1 Média de 24 temperaturas\nNa linha do exemplo das temperaturas hora a hora é apresentado o Algoritmo 12.1, o qual determina a média das temperaturas colhidas a cada hora de um dia.\n\n\nAlgoritmo 12.1: Cálculo da média das temperaturas horárias de um dia\n\n\n\nSegue, agora, a implementação desse algoritmo.\n/*\nCálculo da média de 24 medidas de temperatura colhidas hora a hora durante um dia\nRequer: uma sequência de 24 temperaturas em Celsius\nAssegura: a média dessas temperaturas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Digite as temperaturas.\\n\");\n\n    double soma_temperaturas = 0;\n    for (int hora = 0; hora &lt; 24; hora++) {\n        char entrada[160];\n        printf(\"Temperatura de %2dh: \", hora);\n        fgets(entrada, sizeof entrada, stdin);\n        double temperatura;\n        sscanf(entrada, \"%lf\", &temperatura);\n\n        soma_temperaturas += temperatura;\n    }\n\n    printf(\"Média diária: %.1fºC.\\n\", soma_temperaturas / 24);\n\n    return 0;\n}\nDigite as temperaturas.\nTemperatura de  0h: 9.7\nTemperatura de  1h: 9.6\nTemperatura de  2h: 10.6\nTemperatura de  3h: 8.1\nTemperatura de  4h: 14.1\nTemperatura de  5h: 14.5\nTemperatura de  6h: 12.1\nTemperatura de  7h: 18.2\nTemperatura de  8h: 19.2\nTemperatura de  9h: 20.7\nTemperatura de 10h: 24.2\nTemperatura de 11h: 24.5\nTemperatura de 12h: 18.4\nTemperatura de 13h: 23.1\nTemperatura de 14h: 21.5\nTemperatura de 15h: 21.9\nTemperatura de 16h: 23.9\nTemperatura de 17h: 23.7\nTemperatura de 18h: 18.7\nTemperatura de 19h: 20.4\nTemperatura de 20h: 16.6\nTemperatura de 21h: 14.2\nTemperatura de 22h: 8.0\nTemperatura de 23h: 9.5\nMédia diária: 16.9ºC.\n\n\n12.4.2 Áreas de triângulos\nO Algoritmo 12.2 é uma proposta de nível alto para a determinação da área de uma dada quantidade de triângulos. A quantidade de áreas a serem calculadas é a primeira entrada esperada pela solução.\n\n\nAlgoritmo 12.2: Cálculo da área de uma sequência de triângulos.\n\n\n\nPara mais detalhes, segue a versão do Algoritmo 12.2 com menor grau de abstração. Nesta versão optou-se por fazer o cálculo da área por semiperímetro.\n\n\nAlgoritmo 12.3: Cálculo da área de uma sequência de triângulos usando o semiperímetro.\n\n\n\nUma implementação do Algoritmo 12.3 em C é apresentada na sequência.\n/*\nCálculo da área de diversos triângulos definidos pelas coordenadas em R^2\n    de seus vértices\nRequer: a quantidade de triângulos seguida pelas coordenadas $(x,y)$ de\n    cada vértice do triângulo\nAssegura: a apresentação de cada área calculada\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite a quantidade de triângulos: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int quantidade;\n    sscanf(entrada, \"%d\", &quantidade);\n\n    for (int i = 1; i &lt;= quantidade; i++) {\n        printf(\"Triângulo %d:\\n\"\n               \"Digite x e y do vértice 1: \", i);\n        fgets(entrada, sizeof entrada, stdin);\n        double x1, y1;\n        sscanf(entrada, \"%lf%lf\", &x1, &y1);  // (x1, y1)\n        printf(\"Digite x e y do vértice 2: \");\n        fgets(entrada, sizeof entrada, stdin);\n        double x2, y2;\n        sscanf(entrada, \"%lf%lf\", &x2, &y2);  // (x2, y2)\n        printf(\"Digite x e y do vértice 3: \");\n        fgets(entrada, sizeof entrada, stdin);\n        double x3, y3;\n        sscanf(entrada, \"%lf%lf\", &x3, &y3);  // (x3, y3)\n\n        double lado1 = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n        double lado2 = sqrt(pow(x1 - x3, 2) + pow(y1 - y3, 2));\n        double lado3 = sqrt(pow(x2 - x3, 2) + pow(y2 - y3, 2));\n        double semiperimetro = (lado1 + lado2 + lado3) / 2;\n\n        double area = sqrt(semiperimetro * (semiperimetro - lado1) *\n                           (semiperimetro - lado2) * (semiperimetro - lado3));\n\n        printf(\"Área do triângulo %d: %.2f.\\n\\n\", i, area);\n    }\n\n    return 0;\n}\nDigite a quantidade de triângulos: 2\nTriângulo 1:\nDigite x e y do vértice 1: 0 0\nDigite x e y do vértice 2: 0 1\nDigite x e y do vértice 3: 1 0\nÁrea do triângulo 1: 0.50.\n\nTriângulo 2:\nDigite x e y do vértice 1: -1.5 -1\nDigite x e y do vértice 2: 1.5 -1\nDigite x e y do vértice 3: 0 3.8\nÁrea do triângulo 2: 7.20.\n\n\n12.4.3 Desenho de um “círculo”\nO programa seguinte mostra o aninhamento de dois laços for. Cada um deles vai de -10 a 10 e a saída é um * caso a distância ao “centro” seja menor que 10. No programa, ao invés de calcular \\({\\sqrt{x^2 + y^2} \\leq 10}\\), optou-se por usar a expressão equivalente \\({x^2 + y^2 \\leq 10^2}\\), que não requer calcular a raiz quadrada.\n/*\nDesenho de um círculo usando caracteres\nAssegura: apresentação de um círculo tão razoável quanto possível\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    for (int x = -10; x &lt;= 10; x++) {\n        for (int y = -10; y &lt;= 10; y++)\n            if (x * x + y * y &lt;= 100)  // distância &lt; 10\n                printf(\"XXX\");  // no círculo\n            else\n                printf(\"   \");  // fora do círculo\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n                              XXX                              \n                  XXXXXXXXXXXXXXXXXXXXXXXXXXX                  \n            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX            \n         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX         \n      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \n      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \n      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \n         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX         \n            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX            \n                  XXXXXXXXXXXXXXXXXXXXXXXXXXX                  \n                              XXX                              \nComo cada caractere escrito sempre tem altura maior que a largura, optou-se por usar três caracteres para cada posição para tentar compensar essa diferença e obter o “círculo” com menor distorção. A escolha por três caracteres foi feita por tentativa e erro.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Repetições com `for`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-do-while.html",
    "href": "c-repeticoes-com-do-while.html",
    "title": "13  Repetições com do while",
    "section": "",
    "text": "13.1 A estrutura de repetição do while\nEste capítulo contempla a estrutura e aspectos lógicos do do while, cuja função é executar comandos repetitivamente.\nO do while é uma estrutura de repetição condicional e, assim, depende de uma dada condição para determinar se haverá ou não outra repetição. Em oposição ao while (Capítulo 11) e ao for (Capítulo 12), o teste de continuidade é feito depois da execução do comando.\nNessa estrutura de repetição, o primeiro passo é a execução de comando que, como nas demais estruturas, pode ser um comando simples ou um bloco de comandos. Terminada a execução, a condição_de_continuidade é avaliada, seguindo para nova repetição se for verdadeira ou encerrando do while se não for.\nAssim, esta estrutura executa comando pelo menos uma vez.\nPara exemplificar, o trecho de código seguinte ilustra uma leitura de um valor real garantindo que esteja no intervalo de 0 a 10 (inclusive).\nA lógica da leitura é direta: faz a leitura e, caso não esteja no intervalo especificado, faz a leitura novamente. Neste caso, a primeira leitura é necessária e seu valor sempre é relevante.\nUm detalhe relevante é o escopo das declaraçoes de variáveis: como entrada é usada apenas localmente, é declarada dentro do bloco de comandos do do while; valor, por sua vez, tem que ser declarada fora (antes) do bloco, caso contrário não existiria para ser escrita depois da repetição.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Repetições com `do while`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-do-while.html#a-estrutura-de-repetição-do-while",
    "href": "c-repeticoes-com-do-while.html#a-estrutura-de-repetição-do-while",
    "title": "13  Repetições com do while",
    "section": "",
    "text": "do comando while ( condição_de_continuidade ) ;\n\n\n\n\n\n\n/*\nLeitura de valor com garantia de estar no intervalo [0, 10], com releitura\n    se necessário\nRequer: uma sequência de valores terminada por um no intervalo [0, 10]\nAssegura: apresentação do último valores\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double valor;\n    do {\n        char entrada[160];\n        printf(\"Digite um valor: \");\n        fgets(entrada, sizeof entrada, stdin);\n        sscanf(entrada, \"%lf\", &valor);\n    } while (valor &lt; 0 || valor &gt; 10);\n\n    printf(\"\\nValor aceito: %g.\\n\", valor);\n\n    return 0;\n}\nDigite um valor: 12.2\nDigite um valor: -3.05\nDigite um valor: 7.4\n\nValor aceito: 7.4.\n\n\n\n\n\n\n\n\nCuriosidade\n\n\n\nEm um laço do while, as variáveis declaradas dentro do bloco de comandos ficam tão restritas ao próprio bloco que não podem nem ser acessadas na condição da repetição.\ndo {\n    bool eh_valido;  // declaração interna\n\n    ...\n} while (eh_valido);  // `eh_valido` não existe aqui...",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Repetições com `do while`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-do-while.html#exemplos",
    "href": "c-repeticoes-com-do-while.html#exemplos",
    "title": "13  Repetições com do while",
    "section": "13.2 Exemplos",
    "text": "13.2 Exemplos\nNesta seção há alguns exemplos de programas que utilizam a estrutura de repetição do while.\n\n13.2.1 Leitura de senha\nEste exemplo é de um programa que solicita uma senha para autorizar ou não a execução. A senha é hardcoded (i.e., fixa no código e nada versátil) e há um limite de três tentativas.\n/*\nProcessamento somente mediante senha\nRequer: uma sequência de tentativas de senha terminada com a senha correta\n    ou com comprimento máximo de três tentativas\nAssegura: apresentação de mensagem autorizando ou negando acesso conforme a\n    a senha esteja ou não correta\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    bool validou_senha = false;\n    int numero_tentativas = 0;\n    do {\n        numero_tentativas++;\n        printf(\"Digite a senha: \");\n        char senha[160];\n        fgets(senha, sizeof senha, stdin);\n\n        validou_senha = strcmp(senha, \"12345678\\n\") == 0; // é igual?\n    } while (!validou_senha && numero_tentativas &lt; 3);\n\n    if (validou_senha)\n        printf(\"\\nAcesso autorizado.\\n\");\n    else\n        printf(\"\\nAcesso negado.\\n*** Este problema será reportado.\\n\");\n\n    return 0;\n}\nDigite a senha: senha\nDigite a senha: senha123\nDigite a senha: 123456\n\nAcesso negado.\n*** Este problema será reportado.\nNeste código há o uso da função strcmp, declarada no arquivo de cabeçalho string.h. Ela retorna zero se as duas cadeias de caracteres passadas como parâmetro forem iguais1. Uma observação interessante é que senha é declarada dentro do bloco do do while, uma vez que ela não é necessária fora dele; o mesmo comentário não é válido para validou_senha.\n\n\n13.2.2 Pense em um número de 1 a 15.000!\nO programa deste exemplo se propõe a adivinhar um número pensado pelo usuário em no máximo 13 tentativas.\n/*\nPense em um número de 1 até 15.000 para eu adivinhar qual é!\nRequer: respostas do usuário dizendo se o valor é maior (+) ou menor (-)\n    que o número pensado\nAssegura: a apresentação do número pensado pelo usuário em até 14 tentativas\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(void) {\n    printf(\"Pense em um número de 1 a 15000 e responda...\\n\");\n    sleep(8);  // 8s para pensar!\n\n    int inicio_intervalo = 1;\n    int fim_intervalo = 15000;\n    int numero_tentativas = 0;\n    int tentativa;\n    bool acertei = false;\n    do {\n        numero_tentativas++;\n        tentativa = (inicio_intervalo + fim_intervalo) / 2;\n\n        printf(\"É o %d?\\n\", tentativa);\n        printf(\"Responda + se o número for maior, - se for menor \"\n               \"ou = se eu acertei: \");\n        char resposta[160];\n        fgets(resposta, sizeof resposta, stdin);\n        switch (resposta[0]) {\n            case '+':\n                inicio_intervalo = tentativa + 1;  // tentarei número maior\n                break;\n            case '-':\n                fim_intervalo = tentativa - 1;  // tentarei número menor\n                break;\n            case '=':\n                acertei = true;  // UFA!\n                break;\n            default:\n                printf(\"Não entendi a resposta... tente de novo.\\n\");\n                numero_tentativas--;  // essa tentativa não conta!\n        }\n\n        if (!acertei) {\n            if (numero_tentativas == 13)\n                printf(\"Minha ÚLTIMA CHANCE!!!\\n\");\n            else if (numero_tentativas &gt; 10)\n                printf(\"Só tenho mais %d chances.. :-(\\n\",\n                       14 - numero_tentativas);\n            sleep(0.7);  // pausa leve de dramaticidade\n        }\n    } while (!acertei && fim_intervalo &gt;= inicio_intervalo);\n\n    if (acertei)\n        printf(\"\\n\\nBeleza! Acertei em %d tentativas!\\n\", numero_tentativas);\n    else\n        printf(\"\\n\\nHummmm! Algo de errado não está certo aqui...\\n\"\n               \"Suas respostas foram corretas?\\n\");\n\n    return 0;\n}\nPense em um número de 1 a 15000 e responda...\nÉ o 7500?\nResponda + se o número for maior, - se for menor ou = se eu acertei: +\nÉ o 11250?\nResponda + se o número for maior, - se for menor ou = se eu acertei: +\nÉ o 13125?\nResponda + se o número for maior, - se for menor ou = se eu acertei: +\nÉ o 14063?\nResponda + se o número for maior, - se for menor ou = se eu acertei: -\nÉ o 13594?\nResponda + se o número for maior, - se for menor ou = se eu acertei: -\nÉ o 13359?\nResponda + se o número for maior, - se for menor ou = se eu acertei: +\nÉ o 13476?\nResponda + se o número for maior, - se for menor ou = se eu acertei: =\n\n\nBeleza! Acertei em 7 tentativas!",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Repetições com `do while`</span>"
    ]
  },
  {
    "objectID": "c-repeticoes-com-do-while.html#footnotes",
    "href": "c-repeticoes-com-do-while.html#footnotes",
    "title": "13  Repetições com do while",
    "section": "",
    "text": "Manipulações de cadeias de caracteres são tratadas em detalhes no Capítulo 16.↩︎",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Repetições com `do while`</span>"
    ]
  },
  {
    "objectID": "c-arquivos-texto.html",
    "href": "c-arquivos-texto.html",
    "title": "14  Arquivos texto",
    "section": "",
    "text": "14.1 Fluxos de entrada e saída\nTodos os programas apresentados até o momento escrevem e leem texto, usando o terminal como interface: tela para a apresentação de informações e teclado para receber caracteres digitados.\nNa escrita de um programa em C usando a função printf, a saída é sempre um texto. Este texto pode ser explícito e direto, como o do comando seguinte.\nPor outro lado, o texto escrito pode ser o resultante de uma conversão do valor de uma variável, exemplificado na sequência.\nNeste último printf, a variável d contém um dado valor representado internamente com o tipo double, mas a escrita é uma representação textual desse valor. De acordo com o formato %.2f, a transformação do valor para texto gera a sequência de caracteres 1, ., 3 e 2. A saída, portanto, é texto.\nA questão uso de texto também ocorre nas leituras. Os programas recebem uma sequência de caracteres (texto) obtidas por fgets, mas um eventual valor numérico digitado deve ser convertido para um tipo int ou double, por exemplo. Assim, toda entrada para os programas também tem sido exclusivamente no formato textual. Segue um exemplo destacando a conversão.\nUm programa em C recebe os caracteres digitados no terminal e produz suas saídas também na tela do terminal. A sequencia de caracteres digitados é denominada fluxo de entrada e o texto gerado é o fluxo de saída.\nEsta seção abordada os fluxos usuais do programa e introduz novos fluxos, estes associados a arquivos.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Arquivos texto</span>"
    ]
  },
  {
    "objectID": "c-arquivos-texto.html#fluxos-de-entrada-e-saída",
    "href": "c-arquivos-texto.html#fluxos-de-entrada-e-saída",
    "title": "14  Arquivos texto",
    "section": "",
    "text": "14.1.1 Entrada e saída padrão\nDurante a execução de um programa, ele é capaz de escrever e ler de um terminal. O sistema operacional automaticamente associa as leituras a um fluxo chamado de entrada padrão, conhecido por stdin (de standard input). A saída, por seu turno, é associada à chamada saída padrão, que é o fluxo stdout (standard output).\nAo executar um programa, stdout é associada ao terminal e, assim, todos as chamadas a printf produzem textos nesse terminal. De forma similar, stdin é também associada a esse terminal, de forma que as digitações realizadas são transferidas para o programa (daí o último argumento de fgets ser stdin).\n\n\n\n\n\n\nCuriosidade\n\n\n\nExiste, ainda, um segundo fluxo de saída chamado stderr (standard error), que também é associado ao terminal e funciona praticamente da mesma forma que stdout.\n\n\nPara concluir, o programa em execução pega dados de um fluxo de entrada e gera dados um fluxo de saída.\n\n\n14.1.2 Texto plano e outros fluxos de entrada e saída\nNos fluxos de entrada e saída padrão, via de regra, são produzidos o que se convencionou chamar de texto plano (ou texto simples). Esse texto plano se refere apenas ao fluxo de caracteres convencionais, sem atributos associados. Em outras palavras, o nem fgets nem printf lidam com itálicos, negritos, espaçamento de linhas entre parágrafos ou linhas centralizadas, para citar alguns exemplos de formatação.\nQuando um programa em C é escrito em um editor, ele é um texto plano. A maioria dos IDEs coloca cores e negritos para destacar palavras chaves e comentários, mas esse recurso é apenas visual e automático; essas características não são salvas junto como o código fonte. Textos planos são os produzidos em IDEs ou editores simples, como o GEdit ou o Notepad.\nProgramas em C são capazes de gerenciar outros fluxos além de stdin e stdout, os quais são manipulados como textos planos. Esses novos fluxos são usualmente associados a arquivos, o que permite que as leituras sejam feitas usando-se os caracteres armazenados em um arquivo e, adicionalmente, que as saídas produzam textos direcionados para outro arquivo.\nO termo geral arquivo é usado para qualquer fluxo de dados de entrada ou saída de um programa. Estranhamente, stdin e stdout são tratados internamente também como arquivos.\n A função de escrita printf escreve na saída padrão. Há uma outra função similar, a fprintf, esta última permitindo especificar o fluxo para o qual texto será enviado.\n/*\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    // Duas saídas equivalente\n    printf(\"Hello, world!\\n\");  // implicitamente envia para stdout\n    fprintf(stdout, \"Hello, world!\\n\"); // explícito para stdout\n\n    return 0;\n}\nHello, world!\nHello, world!\nA função fprintf possui um novo parâmetro obrigatório, que é o fluxo que será usado. Neste programa em particular, as duas instruções possuem o mesmo efeito, pois ambas as funções estão associadas a stdout.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Arquivos texto</span>"
    ]
  },
  {
    "objectID": "c-arquivos-texto.html#fluxo-de-escrita-para-arquivo",
    "href": "c-arquivos-texto.html#fluxo-de-escrita-para-arquivo",
    "title": "14  Arquivos texto",
    "section": "14.2 Fluxo de escrita para arquivo",
    "text": "14.2 Fluxo de escrita para arquivo\nPara a criação de um novo fluxo existe uma função em stdio.h chamada fopen. Esta é uma função de chamada ao sistema operacional, solicitando o acesso a um determinado arquivo.\nPara entender mais facilmente a criação de um novo fluxo dados, o programa seguinte parte do uso do fluxo convencional, ou seja, saída na tela. O programa lê uma sequência de coordenadas em \\(\\mathbb{R}^2\\) e apresenta as coordenadas e sua distância à origem. Segue o programa com entradas e saídas convencionais.\n/*\nCriação de um novo arquivo contendo dados digitados pelo usuário\nRequer: uma sequência de pares de pontos (x, y), usando o ponto (0, 0) como\n    valor sentinela\nEnsure: a apresentação de cada ponto e de sua distância à origem\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite x e y do ponto (ou 0 0  para terminar): \");\n    fgets(entrada, sizeof entrada, stdin);\n    double x, y;\n    sscanf(entrada, \"%lf%lf\", &x, &y);\n    while (x != 0 || y != 0) {\n        // Cálculo da distância à origem\n        double distancia_origem = sqrt(x * x + y * y);\n\n        // Escrita das informações no arquivo\n        fprintf(stdout, \"(%.1f, %.1f) --&gt; %.1f\\n\", x, y, distancia_origem);\n\n        // Próximo (x, y)\n        printf(\"Digite x e y do ponto (ou 0 0  para terminar): \");\n        fgets(entrada, sizeof entrada, stdin);\n        sscanf(entrada, \"%lf%lf\", &x, &y);\n    }\n\n    return 0;\n}\nDigite x e y do ponto (ou 0 0  para terminar): 3 -2\n(3.0, -2.0) --&gt; 3.6\nDigite x e y do ponto (ou 0 0  para terminar): 1 -2\n(1.0, -2.0) --&gt; 2.2\nDigite x e y do ponto (ou 0 0  para terminar): 10 5\n(10.0, 5.0) --&gt; 11.2\nDigite x e y do ponto (ou 0 0  para terminar): 14.2 -14.2\n(14.2, -14.2) --&gt; 20.1\nDigite x e y do ponto (ou 0 0  para terminar): 0 0\nUm ponto a se notar nesse programa é o uso da função fprintf para realizar a escrita, mesmo quando o printf poderia ser usado. Esse uso é proposital para identificar as alterações para mudar o fluxo para um arquivo.\n\nA nova versão do programa é apresentada na sequência, sendo que a saída produzida pelo programa é gravada em um arquivo chamado distancias.txt.\n/*\nCriação de um novo arquivo contendo dados digitados pelo usuário\nRequer: Uma sequência de pares de pontos (x, y), usando o ponto (0, 0) como\n    valor sentinela\nEnsure: um arquivo texto contendo, linha a linha, as coordenadas do ponto e\n    suas distâncias à origem\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Criação do arquivo de saída\n    FILE *arquivo_destino = fopen(\"distancias.txt\", \"w\");\n\n    if (arquivo_destino == NULL)\n        printf(\"Erro ao criar novo arquivo.\\n\");\n    else {\n        printf(\"Digite x e y do ponto (ou 0 0  para terminar): \");\n        fgets(entrada, sizeof entrada, stdin);\n        double x, y;\n        sscanf(entrada, \"%lf%lf\", &x, &y);\n        while (x != 0 || y != 0) {\n            // Cálculo da distância à origem\n            double distancia_origem = sqrt(x * x + y * y);\n\n            // Escrita das informações no arquivo\n            fprintf(arquivo_destino, \"(%.1f, %.1f) --&gt; %.1f\\n\", x, y, distancia_origem);\n\n            // Próximo (x, y)\n            printf(\"Digite x e y do ponto (ou 0 0  para terminar): \");\n            fgets(entrada, sizeof entrada, stdin);\n            sscanf(entrada, \"%lf%lf\", &x, &y);\n        }\n\n        // Encerramento do acesso ao arquivo\n        fclose(arquivo_destino);\n    }\n\n    return 0;\n}\nDigite x e y do ponto (ou 0 0  para terminar): 3 -2\nDigite x e y do ponto (ou 0 0  para terminar): 1 -2\nDigite x e y do ponto (ou 0 0  para terminar): 10 5\nDigite x e y do ponto (ou 0 0  para terminar): 14.2 -14.2\nDigite x e y do ponto (ou 0 0  para terminar): 0 0\nA primeira diferença entre essa versão e a original é especificação de um arquivo, ou seja, um novo fluxo de dados. Essa especificação é feita usando-se uma variável arquivo_destino cujo tipo é FILE *. A essa variável é atribuído o valor retornado pela função fopen.\nFILE *arquivo_destino = fopen(\"distancias.txt\", \"w\");\nConforme apresentada no programa, essa função solicita ao sistema operacional para criar um novo arquivo, o qual usará o nome distancias.txt. Essa função não é infalível e o sistema operacional pode, assim, negar a criação. Entre as razões para a criação falhar podem ser citadas, a título de exemplo, que o programa tenha autorização de criar um arquivo no diretório corrente ou que já exista um arquivo com esse nome e ele seja protegido para não ser reescrito. No caso de falha, a função retorno o valor NULL. O segundo parâmetro, \"w\", indica que o arquivo deve ser criado.\nAssim, essa possibilidade de falha é tratada no programa, que verifica se o valor retornado foi ou não NULL.\nif (arquivo_destino == NULL)\n    printf(\"Erro ao criar novo arquivo.\\n\");  // aqui houve erro\nelse {\n    // Aqui o arquivo foi criado com sucesso\n    ...\n}\nA relação entre o arquivo real (armazenado em um disco rígido, por exemplo) e o programa em C se dá por meio do valor retornado pela função fopen e armazenado na variável arquivo_destino. O programa usa essa variável para indicar o que é feito e o sistema operacional se encarrega de refletir os efeitos dos comandos no arquivo real.\n O arquivo real é chamado usualmente de arquivo físico, enquanto a variável associada a esse arquivo é conhecida como arquivo lógico.\nSe o arquivo de saída foi criado com sucesso, o programa segue para o else, cujos comandos reproduzem as mesmas leituras do programa original, incluindo as mesmas verificações e conversões. Nessa parte, a primeira diferença está no comando fprintf, cujo primeiro argumento é arquivo_destino.\nfprintf(arquivo_destino, \"(%.1f, %.1f) --&gt; %.1f\\n\", x, y, distancia_origem);\nO texto que seria escrito no terminal é, agora, gravado no arquivo distancias.txt, incluindo as formatações (%.f) e mudanças de linha (\\n).\nDessa forma, o arquivo de saída fica com o conteúdo apresentado na sequência.\n(3.0, -2.0) --&gt; 3.6\n(1.0, -2.0) --&gt; 2.2\n(10.0, 5.0) --&gt; 11.2\n(14.2, -14.2) --&gt; 20.1\nHá, finalmente, ainda uma diferença importante: depois de encerrada a sequência de entrada, o arquivo é fechado com fclose.\nfclose(arquivo_destino);\nFechar um arquivo faz com que o sistema operacional grave todos os bytes enviados para o arquivo, atualize suas informações de armazenamento (tamanho, data de gravação etc.) e libere os recursos que o sistema estava usando para controlar o acesso ao arquivo.\nÉ importante notar que o arquivo somente é fechado caso tenha sido aberto com sucesso. É por essa razão que o fclose está no bloco de comandos condicionados no else.\n\n\n\n\n\n\n\n\nDica\n\n\n\nEm geral, quando um programa tem sua execução terminada, os arquivos abertos por ele são automaticamente fechados.\nEntretanto, é uma péssima prática não deixar o fechamento dos arquivos explicitamente indicados no código. O uso do fclose, portanto, é mandatório para um código de boa qualidade.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Arquivos texto</span>"
    ]
  },
  {
    "objectID": "c-arquivos-texto.html#sec-fluxo-de-leitura",
    "href": "c-arquivos-texto.html#sec-fluxo-de-leitura",
    "title": "14  Arquivos texto",
    "section": "14.3 Fluxo de leitura",
    "text": "14.3 Fluxo de leitura\nDa mesma forma que a saída textual de um programa pode ser direcionada a um arquivo, criando um fluxo de escrita, também a entrada pode ser feita de um arquivo, criando-se um fluxo de entrada.\nPara exemplificar um fluxo de entrada, será considerado um arquivo textual contendo dados sobre triângulos e retângulos. O arquivo conterá, em sua primeira linha, um valor com a quantidade de figuras contidas no arquivo. Para os triângulos há uma linha contendo o caractere T e seis valores reais, cada par deles correspondendo às coordenadas \\((x, y)\\) dos vértices do triângulo; para os retângulos, o caractere será R e há apenas dois pontos (quatro valores) para referenciá-lo, correspondendo a dois vértices opostos (os lados do retângulo são sempre considerados paralelos aos eixos).\n\nPara um exemplo inicial, pode ser considerado o arquivo seguinte, cujo nome é figuras.txt. Esse arquivo pode ser criado com qualquer editor de texto plano.\n3\nR 0.0 0.0 5.5 2.0\nT -1.0 1.0 3.0 4.5 4 -0.5\nR -1.2 5.2 2.2 3.1\nNeste exemplo, o 3 indica que há três formas. A primeira é o retângulo \\(R_1\\) da Figura 14.1; segue-se o triângulo \\(T\\) e a última é o retângulo \\(R_2\\).\n\n\n\n\n\n\nFigura 14.1: Três formas armazenadas em arquivo segundo seus vértices.\n\n\n\nUma solução para processar os dados desse arquivo e apresentar as áreas de cada figura é o Algoritmo 14.1, apresentado com nível alto de abstração.\n\n\nAlgoritmo 14.1: Processamento de formas em arquivo com apresentação das suas áreas, com prefixação do número de formas.\n\n\n\nA implementação desse algoritmo em C pode ser feita conforme o programa seguinte. Nessa codificação, o arquivo lógico é dado pela variável arquivo_formas, associado ao arquivo físico figuras.txt.\n/*\nProcessamento de um arquivo de formas (triângulos e retângulos) para cálculo\n    das áreas\nRequer: arquivo texto com nome 'figuras.txt':\n    na linha 1: número de formas\n    nas linhas restantes, conforme a quantidade da linha 1:\n        - OU a letra T mais coordenadas dos vértices do triângulo\n        - OU a letra R e as coordenadas de dois vértices opostos do\n            retângulo\nAssegura: a apresentação da área de cada forma\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    FILE *arquivo_formas = fopen(\"figuras.txt\", \"r\");\n\n    if (arquivo_formas == NULL) {\n        printf(\"Falha ao abrir arquivo de formas.\\n\");\n    }\n    else {\n        char entrada[160];\n        fgets(entrada, sizeof entrada, arquivo_formas);\n        int numero_formas;\n        sscanf(entrada, \"%d\", &numero_formas);\n\n        // Processamento das formas\n        for (int i = 0; i &lt; numero_formas; i++) {\n            // Obtenção da linha com a forma\n            fgets(entrada, sizeof entrada, arquivo_formas);\n            double area;\n            if (entrada[0] == 'T') {\n                // Triângulo: área por semiperímetro\n                double x1, y1, x2, y2, x3, y3;\n                sscanf(entrada, \"%*c%lf%lf%lf%lf%lf%lf\",\n                       &x1, &y1, &x2, &y2, &x3, &y3);\n                double lado1 = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n                double lado2 = sqrt(pow(x1 - x3, 2) + pow(y1 - y3, 2));\n                double lado3 = sqrt(pow(x2 - x3, 2) + pow(y2 - y3, 2));\n                double semiperimetro = (lado1 + lado2 + lado3) / 2;\n\n                area = sqrt(semiperimetro * (semiperimetro - lado1) *\n                            (semiperimetro - lado2) * (semiperimetro - lado3));\n            }\n            else {\n                // Retângulo: ára por base x altura\n                double x1, y1, x2, y2;\n                sscanf(entrada, \"%*c%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n\n                area = fabs(x2 - x1) * fabs(y2 - y1);\n            }\n\n            printf(\"%.2f\\n\", area);\n        }\n\n        fclose(arquivo_formas);\n    }\n\n    return 0;\n}\n11.00\n11.75\n7.14\nA função fopen usa como parâmetros o nome do arquivo de formas e o modo \"r\", que indica acesso para leitura. Todas as leituras são feitas linha a linha, usando a variável genérica entrada para armazenamento temporário. Para o caso da primeira linha, a qual contém apenas a quantidade de formas do arquivo, esse valor é obtido pelo sscanf usando-se o formato %d.\nNo caso das linhas de cada forma, cada uma delas é armazenada em entrada, porém analisadas de forma diferente. Como o primeiro caractere da linha indica sua forma, a decisão entre triângulo e retângulo é feita com base em entrada[0], que será T ou R.\nCom base no tipo da forma, a linha é analisada de forma separada. No caso do triângulo, são esperados seis valores que formam as três coordenadas dos vértices e, desse modo, o sscanf usa o padrão de formato %*c%lf%lf%lf%lf, que ignora o primeiro caractere e faz a varredura procurando seis valores reais. Para o caso do retângulo, no qual há apenas dois pontos, o padrão usado é %*c%lf%lf%lf%lf, o qual ignora o R e obtém os quatro valores que formam as duas coordenadas dos vértices opostos.\nNaturalmente, terminado o processamento do arquivo, fclose é usado para liberar o sistema operacional de gerenciar o arquivo de dados.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Arquivos texto</span>"
    ]
  },
  {
    "objectID": "c-arquivos-texto.html#mais-sobre-a-abertura-e-o-fechamento-de-arquivos-texto",
    "href": "c-arquivos-texto.html#mais-sobre-a-abertura-e-o-fechamento-de-arquivos-texto",
    "title": "14  Arquivos texto",
    "section": "14.4 Mais sobre a abertura e o fechamento de arquivos texto",
    "text": "14.4 Mais sobre a abertura e o fechamento de arquivos texto\nNesta seção são reapresentadas as funções de manipulação de arquivos com mais detalhamento sobre seu funcionamento e uso dos parâmetros.\n\n14.4.1 A função fopen\nA função de associação entre o programa e o arquivo real é a fopen. Ela sempre possui dois parâmetros, sendo o primeiro a indicação do nome do arquivo e o segundo, o modo de abertura.\nO nome do arquivo é uma cadeia de caracteres que pode ser somente o nome do arquivo, como \"figuras.txt\", por exemplo. Nesse caso, o arquivo físico é considerado em relação ao diretório corrente. O nome pode indicar também o caminho: \"../figuras.txt\" indica o arquivo no diretório pai (isto é, um acima do atual) e \"/home/user/dados/figuras.txt\" dá o caminho absoluto e independe do diretório corrente1.\nEm relação aos modos, como \"w\" ou \"r\" usados nos exemplos, a Tabela 14.1 sumariza como funcionam.\n\n\n\nTabela 14.1: Modos do fopen para manipulação de arquivos texto.\n\n\n\n\n\n\n\n\n\n  Modo  \nSignificado\n\n\n\n\n\"w\"\nPrepara um arquivo somente para escrita, criando um arquivo novo ou truncando o existente para tamanho zero. A posição corrente é ajustada para o início do arquivo.\n\n\n\"r\"\nPrepara um arquivo somente para leitura. A posição corrente é ajustada para o início do arquivo.\n\n\n\"a\"\nPrepara um arquivo somente para escrita. Se o arquivo já existir, a posição corrente é ajustada para o final do arquivo; senão, um novo arquivo é criado.\n\n\n\n\n\n\nArquivos texto são, via de regra, processados sequencialmente, do início ao fim ou do início até um ponto de interesse qualquer. Raramente são abertos para leitura e escrita, de forma que essa opção foi omitida da lista apresentada.\nA Tabela 14.1 também introduz um elemento importante, embora intuitivamente fácil de compreender: a posição corrente. Esse termo é aplicado ao local no arquivo onde as operações de leitura e escrita serão realizadas. Por exemplo, quando um arquivo é aberto em modo \"r\", a posição corrente está no início do arquivo, que é o byte zero. A cada leitura, a posição corrente é ajustada para o próximo byte que será lido.\nEmbora a posição corrente não seja diretamente usada pelo programador no processamento sequencial do arquivo, um exemplo simples de programa ilustra esse conceito.\n\n/*\nEscrita de algumas linhas de texto em um arquivo com acompanhamento da\n    posição corrente de Escrita\nAssegura: criação de arquivo 'texto.txt' com algum texto e apresentação\n    dos bytes usados em cada linha durante a escrita\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE *arquivo_numeros = fopen(\"texto.txt\", \"w\");\n\n    if (arquivo_numeros == NULL)\n        printf(\"Falha ao criar arquivo de saída.\\n\");\n    else {\n        printf(\"Primeira linha: bytes de %ld\", ftell(arquivo_numeros));\n        fprintf(arquivo_numeros, \"Primeira linha deste arquivo.\\n\");\n        printf(\" a %ld.\\n\", ftell(arquivo_numeros) - 1);\n\n        printf(\"Segunda linha: bytes de %ld\", ftell(arquivo_numeros));\n        fprintf(arquivo_numeros, \"Linha 2\");  // escrita em duas etapas\n        fprintf(arquivo_numeros, \" segue aqui...\\n\");\n        printf(\" a %ld.\\n\", ftell(arquivo_numeros) - 1);\n\n        printf(\"Terceira linha: bytes de %ld\", ftell(arquivo_numeros));\n        fprintf(arquivo_numeros, \"Finalmente o fim do texto! (linha 3)\");\n        printf(\" a %ld.\\n\", ftell(arquivo_numeros) - 1);\n\n        fclose(arquivo_numeros);\n    }\n\n    return 0;\n}\nPrimeira linha: bytes de 0 a 29.\nSegunda linha: bytes de 30 a 51.\nTerceira linha: bytes de 52 a 87.\nO conteúdo de texto.txt ficou como se segue.\nPrimeira linha deste arquivo.\nLinha 2 segue aqui...\nFinalmente o fim do texto! (linha 3)\nPara visualização, a seguir é apresentado o conteúdo do arquivo com 16 bytes por linha. A primeira coluna é a contagem de caracteres (primeira linha do od são os bytes de zero a 15), o que ajuda a identificar a posição de cada caractere relativo a sua posição do arquivo. Os valores \\n são as mudanças de linha usuais2. Vale a pena confrontar os valores escritos pelo programa anterior com as posições reais do arquivo.\n$ od -Ad -tc texto.txt\n0000000   P   r   i   m   e   i   r   a       l   i   n   h   a       d\n0000016   e   s   t   e       a   r   q   u   i   v   o   .  \\n   L   i\n0000032   n   h   a       2       s   e   g   u   e       a   q   u   i\n0000048   .   .   .  \\n   F   i   n   a   l   m   e   n   t   e       o\n0000064       f   i   m       d   o       t   e   x   t   o   !       (\n0000080   l   i   n   h   a       3   )\n0000088\n\n\nO conceito da posição corrente também é válido para as leituras, que se iniciam na posição zero (início do arquivo) e, após cada leitura, é atualizada para o próximo byte que será lido em um próximo fgets.\nA ideia da posição em que ocorre a próxima operação de entrada ou saída é a usada quando o modo \"a\" é usado no fopen. Nesse caso, o arquivo é aberto para escrita, seu conteúdo (se existir) é preservado e a posição corrente é colocada depois do último byte do arquivo. Com isso, uma nova escrita no arquivo acrescentará texto ao seu final.\nUm log é um arquivo usado para registrar eventos. Por exemplo, sempre que um usuário entra no sistema ou quando um trabalho de impressão é iniciado, cada evento é registrado no log. O programa seguinte, cada vez que executado, solicita uma linha de informação e a grava em um arquivo de log.\n\n/*\nInserção de uma linha no arquivo de log 'registro.log'\nRequer: a digitação da linha de informação\nAssegura: o acréscimo dessa linha no final do arquivo\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE *arquivo_log = fopen(\"registro.log\", \"a\");\n\n    if (arquivo_log == NULL)\n        printf(\"Falha ao criar ou abrir arquivo de log.\\n\");\n    else {\n        printf(\"Digite a informação a ser registrada:\\n&gt; \");\n        char linha_de_log[160];\n        fgets(linha_de_log, sizeof linha_de_log, stdin);\n\n        fprintf(arquivo_log, \"%s\", linha_de_log);\n\n        fclose(arquivo_log);\n    }\n\n    return 0;\n}\nDigite a informação a ser registrada:\n&gt; Primeiro registro do log.\nNa primeira execução, o arquivo registro.log ainda não existe, o que faz com que ele seja criado vazio. Então o programa solicita o primeiro registro e o grava no arquivo.\nA cada nova execução, uma linha é solicitada e adicionada ao final do arquivo.\n\n\n\n\n\n\n\n\nCuriosidade\n\n\n\nQuando um arquivo é aberto apenas para escrita (\"w\" e \"a\"), tentativas de leitura desse arquivo são apenas ignoradas sem gerar qualquer erro. De forma similar, ao se tentar escrever em um arquivo aberto com \"r\", a escrita não é feita e nenhum erro é indicado.\n\n\n\n\n14.4.2 A função fclose\nO encerramento do acesso ao arquivo é feito pela função fclose, para a qual é preciso passar como parâmetro a variável correspondente a um arquivo aberto com sucesso. Uma vez fechado, nenhuma operação de entrada ou saída para o arquivo é possível.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Arquivos texto</span>"
    ]
  },
  {
    "objectID": "c-arquivos-texto.html#a-função-fprintf",
    "href": "c-arquivos-texto.html#a-função-fprintf",
    "title": "14  Arquivos texto",
    "section": "14.5 A função fprintf",
    "text": "14.5 A função fprintf\n A escrita em um arquivo texto com o fprint funciona de forma similar ao print na tela. A função, inicialmente, processa a cadeia de caracteres de formato e faz as conversões de formato, gerando o texto final. Então, esse texto é gravado no arquivo. Enquanto print é sempre direcionado para stdout, fprintf permite escolher a qual fluxo de saída o texto será enviado.\n\nComo exemplo, pode ser considerado o programa seguinte, que cria um arquivo com algumas operações com raiz quadrada.\n/*\nCriação de arquivo com valores de raízes quadradas\nAssegura: criação de arquivo texto contendo valores de raízes\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    FILE *arquivo_raizes = fopen(\"raizes.txt\", \"w\");\n\n    if (arquivo_raizes == NULL)\n        printf(\"Falha ao criar arquivo.\\n\");\n    else {\n        for (double x = 0.0; x &lt;= 100; x += 0.5)\n            fprintf(arquivo_raizes, \"raiz(%.1f) = %.3f\\n\", x, sqrt(x));\n\n        fclose(arquivo_raizes);\n    }\n\n    return 0;\n}\nO arquivo resultante da execução, raizes.txt, segue.\nraiz(0.0) = 0.000\nraiz(0.5) = 0.707\nraiz(1.0) = 1.000\nraiz(1.5) = 1.225\nraiz(2.0) = 1.414\n\n... [191 linhas omitidas]\n\nraiz(98.0) = 9.899\nraiz(98.5) = 9.925\nraiz(99.0) = 9.950\nraiz(99.5) = 9.975\nraiz(100.0) = 10.000\n\nExecutada uma chamada de fprint, a escrita é feita a partir da posição corrente, a qual é atualizada para o próximo byte depois do último byte escrito.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Arquivos texto</span>"
    ]
  },
  {
    "objectID": "c-arquivos-texto.html#leitura-até-o-fim-do-arquivo",
    "href": "c-arquivos-texto.html#leitura-até-o-fim-do-arquivo",
    "title": "14  Arquivos texto",
    "section": "14.6 Leitura até o fim do arquivo",
    "text": "14.6 Leitura até o fim do arquivo\nQuando um arquivo contém dados, além da estratégia de prefixar os dados com a quantidade (estratégia usada no Algoritmo 14.1), é também possível varrer o arquivo até encontrar seu final. O Algoritmo 14.2 aborda esse novo problema, ainda no contexto de um arquivo com formas triangulares e retangulares.\n\n\nAlgoritmo 14.2: Processamento de formas em arquivo com apresentação das suas áreas, com uma forma por linha.\n\n\n\nA função fgets opera da mesma forma para um arquivo aberto quanto para stdin, ou seja, os dados do arquivo são lidos para uma variável do programa até que seja encontrado um final de linha (\\n). O efeito prático é a leitura de uma linha por vez.\nQuando não há mais dados no arquivo para serem lidos, situação em que o fim do arquivo foi atingido, o valor de retorno de fgets é NULL. Assim, pela verificação do valor de retorno, é possível verificar se se chegou ao fim dos dados.\n\nO programa em C seguinte implementa do Algoritmo 14.2, verificando se ainda há formas do arquivo analisando o valor de retorno de fgets.\n/*\nProcessamento de um arquivo de formas (triângulos e retângulos) para cálculo\n    das áreas\nRequer: arquivo texto com nome 'figuras.txt' com cada linha contendo:\n        - OU a letra T mais coordenadas dos vértices do triângulo\n        - OU a letra R e as coordenadas de dois vértices opostos do\n            retângulo\nAssegura: a apresentação da área de cada forma\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    FILE *arquivo_formas = fopen(\"figuras.txt\", \"r\");\n\n    if (arquivo_formas == NULL) {\n        printf(\"Falha ao abrir arquivo de formas.\\n\");\n    }\n    else {\n        char forma[160];\n        // Obtenção do número de formas\n        while (fgets(forma, sizeof forma, arquivo_formas) != NULL) {\n            double area;\n            if (forma[0] == 'T') {\n                // Triângulo: área por semiperímetro\n                double x1, y1, x2, y2, x3, y3;\n                sscanf(forma, \"%*c%lf%lf%lf%lf%lf%lf\",\n                       &x1, &y1, &x2, &y2, &x3, &y3);\n                double lado1 = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n                double lado2 = sqrt(pow(x1 - x3, 2) + pow(y1 - y3, 2));\n                double lado3 = sqrt(pow(x2 - x3, 2) + pow(y2 - y3, 2));\n                double semiperimetro = (lado1 + lado2 + lado3) / 2;\n\n                area = sqrt(semiperimetro * (semiperimetro - lado1) *\n                            (semiperimetro - lado2) * (semiperimetro - lado3));\n            }\n            else {\n                // Retângulo: ára por base x altura\n                double x1, y1, x2, y2;\n                sscanf(forma, \"%*c%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n\n                area = fabs(x2 - x1) * fabs(y2 - y1);\n            }\n\n            printf(\"%.2f\\n\", area);\n        }\n\n        fclose(arquivo_formas);\n    }\n\n    return 0;\n}\n11.00\n11.75\n7.14\n1.00\n4.00\n0.50\nO arquivo figuras.txt processado por esse programa contém o conteúdo seguinte. Comparativamente ao usado na Seção 14.3, o formado de descrição de cada forma é o mesmo, sendo que apenas a primeira linha contendo o número de formas não existe.\nR 0.0 0.0 5.5 2.0\nT -1.0 1.0 3.0 4.5 4 -0.5\nR -1.2 5.2 2.2 3.1\nR 0 0 1 1\nR -1 -1 1 1\nT 0 0 0 1 1 0\nDurante a execução, o resultado de fgets é checado a cada início do while, até que retorne NULL e encerre a repetição. A cada retorno válido, a área correspondente é calculada.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Arquivos texto</span>"
    ]
  },
  {
    "objectID": "c-arquivos-texto.html#a-função-rewind",
    "href": "c-arquivos-texto.html#a-função-rewind",
    "title": "14  Arquivos texto",
    "section": "14.7 A função rewind",
    "text": "14.7 A função rewind\nA palavra rewind tem aqui o sentido de rebobinar e vem do tempo em que os arquivos eram mantidos em fitas magnéticas e, para voltar para o início do arquivo, era necessário retroceder fisicamente o carretel. Para o contexto atual, rebobinar significa apenas retornar a posição corrente para o byte zero, ou seja, o primeiro byte do arquivo.\n\nA função rewind tem o significado de retornar o arquivo para a primeira posição. Isso significa, por exemplo, que se um arquivo tem que ser processado mais que uma vez, é possível fazer uma varredura até o final e, então, retornar ao início e fazer nova leitura.\nUm uso interessante de rewind é apresentado no Algoritmo 14.3.\n\n\nAlgoritmo 14.3: Processamento de arquivo de notas.\n\n\n\nEsse problema requer duas passadas pelos valores das notas, uma vez que a contagem dos valores maiores que a média precisa que a média já tenha sido calculada e, para calcular a média, é preciso ter passado por todos as notas. Assim, o arquivo é varrido sequencialmente somando-se as notas e contando quantas são para, em seguida, calcular a média. Em um segundo passo, o arquivo é varrido novamente desde o início, para, então, contar a quantidade de notas maiores que a média.\n\nComo arquivo de notas, segue uma possível versão de notas.txt.\n5.4\n3.4\n5.6\n9.8\n5.0\n3.8\n4.4\n4.9\n2.5\n4.8\n4.9\nA implementação em C para o processamento do arquivo é apresentada na sequência.\n/*\nDeterminação da quantidade de notas maiores que a média geral das notas\n    em um arquivo de dados\nRequer: arquivo texto com uma nota por linha\nAssegura: a apresentação da quantidade notas maiores que a média geral\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE *arquivo_notas = fopen(\"notas.txt\", \"r\");\n\n    if (arquivo_notas == NULL) {\n        printf(\"Falha ao abrir arquivo de notas.\\n\");\n    }\n    else {\n        // Cálculo da média geral das notas\n        char entrada[160];\n        double soma_notas = 0;\n        int contador_notas = 0;\n        while (fgets(entrada, sizeof entrada, arquivo_notas) != NULL) {\n            double nota;\n            sscanf(entrada, \"%lf\", &nota);\n            soma_notas += nota;\n            contador_notas++;\n        }\n        double media = soma_notas / contador_notas;\n\n        // Contagem da quantidade de notas acima da média calculada\n        rewind(arquivo_notas);  // retorna ao início do arquivo\n        int contador_maiores = 0;\n        while (fgets(entrada, sizeof entrada, arquivo_notas) != NULL) {\n            double nota;\n            sscanf(entrada, \"%lf\", &nota);\n            if (nota &gt; media)\n                contador_maiores++;\n        }\n\n        fclose(arquivo_notas);\n\n        // Resultado\n        printf(\"%d notas maiores que %.1f.\\n\", contador_maiores, media);\n    }\n\n    return 0;\n}\n4 notas maiores que 5.0.\nSem o uso de rewind, o segundo while terminaria de imediato, visto que a posição corrente já está no fim do arquivo e qualquer nova leitura retornará NULL como resultado.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Arquivos texto</span>"
    ]
  },
  {
    "objectID": "c-arquivos-texto.html#a-traiçoeira-função-feof",
    "href": "c-arquivos-texto.html#a-traiçoeira-função-feof",
    "title": "14  Arquivos texto",
    "section": "14.8 A traiçoeira função feof",
    "text": "14.8 A traiçoeira função feof\n O nome “feof” é composto pelo f inicial, como (quase) todas as funções que trabalham com arquivos (files), seguido de eof, que significa end of file, ou fim de arquivo.\nPorém, o uso correto dessa função requer entender tanto o que ela faz e o que ela não faz. Apesar do nome, feof não verifica se o arquivo chegou ao fim. Isso é o que ela não faz.\nA função feof deve ser usada depois que uma operação de leitura (fgets, por exemplo) tenta ser executada mas falha. Somente depois dessa falha é que feof pode ser usada para verificar porquê a função não foi bem sucedida. Assim, feof volta verdadeiro quando a razão da falha foi tentar ler além do último dado do arquivo.\n\nA diferença parece sutil, mas não é. Para entender esse mecanismo, um programa simples é usado para mostrar o que acontece na leitura de um arquivo texto e como feof se comporta.\nO arquivo usado para exemplo possui apenas duas linhas e é apresentado a seguir.\nTexto da primeira linha\nE material para a segunda linha!\nEsse arquivo possui duas linhas, ambas terminadas com \\n, como pode ser observado ao se analisar mais detalhadamente o conteúdo do arquivo.\n$ od -tc -Ad texto.txt\n0000000   T   e   x   t   o       d   a       p   r   i   m   e   i   r\n0000016   a       l   i   n   h   a  \\n   E       m   a   t   e   r   i\n0000032   a   l       p   a   r   a       a       s   e   g   u   n   d\n0000048   a       l   i   n   h   a   !  \\n\n0000057\nO programa usado para processar esse arquivo está apresentado na sequência.\n/*\nPrograma exemplo do comportamento da função feof\nAssegura: a apresentação de informações relevantes ao longo da execução\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE *arquivo = fopen(\"texto.txt\", \"r\");\n\n    if (arquivo == NULL)\n        printf(\"Falha ao abrir arquivo com texto.\");\n    else {\n        char linha[160];\n\n        // Situação inicial\n        printf(\"Ao abrir o arquivo: feof = %c.\\n\\n\", feof(arquivo) ? 'V' : 'F');\n\n        // Primeira leitura\n        fgets(linha, sizeof linha, arquivo);\n        printf(\"Primeira leitura: %s\", linha);\n        printf(\"Depois da 1ª leitura: feof = %c.\\n\\n\",\n               feof(arquivo) ? 'V' : 'F');\n\n        // Segunda leitura\n        fgets(linha, sizeof linha, arquivo);\n        printf(\"Segunda leitura: %s\", linha);\n        printf(\"Depois da 2ª leitura: feof = %c.\\n\\n\",\n               feof(arquivo) ? 'V' : 'F');\n\n        // Terceira leitura, que deve falhar\n        fgets(linha, sizeof linha, arquivo);\n        printf(\"Terceira leitura: %s\", linha);\n        printf(\"Depois da 3ª leitura: feof = %c.\\n\\n\",\n               feof(arquivo) ? 'V' : 'F');\n\n        fclose(arquivo);\n    }\n    return 0;\n}\nAo abrir o arquivo: feof = F.\n\nPrimeira leitura: Texto da primeira linha\nDepois da 1ª leitura: feof = F.\n\nSegunda leitura: E material para a segunda linha!\nDepois da 2ª leitura: feof = F.\n\nTerceira leitura: E material para a segunda linha!\nDepois da 3ª leitura: feof = V.\nComo esperado, as duas primeiras execuções de fgets fazem as leituras das duas primeiras linhas do arquivo e apresentam seu conteúdo na tela. Como o arquivo texto.txt possui apenas essas duas linhas, a terceira chamada a fgets falha, sendo o NULL retornado ignorado no programa. Como a leitura falha, a variável linha não é modificada e é por essa razão que a mensagem de conteúdo da terceira leitura aparece igual ao da segunda.\nQuanto à função feof, ela retorna falso (zero) logo ao abrir o arquivo e também depois da primeira leitura. Na segunda execução de fgets, a segunda linha é copiada para a variável linha e efetivamente a posição corrente está no fim do arquivo. Entretanto, como a leitura não foi além do fim do arquivo, feof ainda retorna falso. Na terceira leitura, que é mal sucedida por não haver mais o que ler do arquivo, o fgets não faz a leitura e, a partir desse momento, feof começa a retornar verdadeiro (valor não nulo), indicando que o problema foi tentar ler de um arquivo que já havia terminado.\n\n\n\n\n\n\nCuidado\n\n\n\nPor uma tendência em interpretar erroneamente o que feof realmente verifica, não é incomum programas como o seguinte, que produz um resultado insatisfatório.\nSupondo a existência de um arquvio inteiros.txt com o conteúdo seguinte, um programa se propõe a fazer a soma dos valores inteiros contidos nele. Para este arquivo específico, o resultado esperado é 120.\n20\n50\n30\n20\nEste arquivo possui um \\n no final de cada linha. Como ilustra o comando seguinte.\n$ od -tc -Ad inteiros.txt\n0000000   2   0  \\n   5   0  \\n   3   0  \\n   2   0  \\n\n0000012\nSegue, agora, o programa que tenta processar esse arquivo.\n/*\nTentativa incorreta de somar os valores de um arquivo de inteiros\nRequer: um arquivo com valores inteiros, um por linha\nAssegura: a soma incorreta dos valores\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE *arquivo_inteiros = fopen(\"inteiros.txt\", \"r\");\n\n    if (arquivo_inteiros == NULL)\n        printf(\"Falha ao abrir arquivo_inteiros com os valores inteiros.\");\n    else {\n        int soma = 0;\n        while (!feof(arquivo_inteiros)) {\n            // Obtenção do inteiro\n            char entrada[160];\n            fgets(entrada, sizeof entrada, arquivo_inteiros);\n            int valor;\n            sscanf(entrada, \"%d\", &valor);\n\n            // Acumulação do valor\n            soma += valor;\n        }\n\n        fclose(arquivo_inteiros);\n\n        printf(\"Soma dos valores no arquivo: %d.\\n\", soma);\n    }\n    \n    return 0;\n}\nSoma dos valores no arquivo: 140.\nO laço de repetição é baseado na verificação de feof. Porém, essa função ainda retorna verdadeiro depois da leitura da última linha, pois o fgets não tentou ler depois do fim do arquivo. A consequência disso é que o while faz uma repetição a mais e o último valor lido é somado mais uma vez.\nUma alternativa interessante é evitar o uso do feof, baseando as decisões no resultado da função de leitura. Segue, assim, uma versão robusta do programa para a soma dos valores do arquivo.\n/*\nTentativa incorreta de somar os valores de um arquivo de inteiros\nRequer: um arquivo com valores inteiros, um por linha\nAssegura: a soma incorreta dos valores\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE *arquivo_inteiros = fopen(\"inteiros.txt\", \"r\");\n\n    if (arquivo_inteiros == NULL)\n        printf(\"Falha ao abrir arquivo_inteiros com os valores inteiros.\");\n    else {\n        char entrada[160];\n        \n        int soma = 0;\n        while (fgets(entrada, sizeof entrada, arquivo_inteiros) != NULL) {\n            int valor;\n            sscanf(entrada, \"%d\", &valor);\n\n            soma += valor;\n        }\n\n        fclose(arquivo_inteiros);\n\n        printf(\"Soma dos valores no arquivo: %d.\\n\", soma);\n    }\n\n    return 0;\n}\nSoma dos valores no arquivo: 120.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Arquivos texto</span>"
    ]
  },
  {
    "objectID": "c-arquivos-texto.html#footnotes",
    "href": "c-arquivos-texto.html#footnotes",
    "title": "14  Arquivos texto",
    "section": "",
    "text": "No Linux, usado como plataforma para este livro, o separador de diretórios é a barra /. O mesmo ocorre para o MacOS. Em sistemas Windows, os caminhos usam a barra reversa \\ e, como essa barra tem significado especial em C, é preciso indicar o caminho com o escape \\\\: \"..\\\\figuras.txt\" ou C:\\\\User\\\\Documentos\\\\Dados\\\\figuras.txt.↩︎\nNo Windows, a mudança de linha costuma ser indicada pela sequência \\r\\n, de modo que o conteúdo do arquivo pode diferir um pouco caso seja essa a plataforma usada para execução do programa.↩︎",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Arquivos texto</span>"
    ]
  },
  {
    "objectID": "c-desvirtuacao-das-repeticoes.html",
    "href": "c-desvirtuacao-das-repeticoes.html",
    "title": "15  Desvirtuação das repetições",
    "section": "",
    "text": "15.0.1 Laços infinitos\nA estrutura do for, embora seja bem objetiva indicando iniciação, condição e incremento (seus três elementos de operação), ela é bastante flexível do ponto de vista de seu uso pelo programador.\nUm indicador dessa liberdade dada ao programador é que todos os elementos são opcionais, além de permitirem outros elementos.\nEm termos de argumentos opcionais, o trecho de código seguinte pode ser considerado.\nPara esta repetição, não há iniciação, nem condição, nem incremento. Seu comportamento, assim, funciona como um “repita o comando para sempre”, ou seja, um laço infinito.\nNa prática, basta não ter a condição de continuidade especificada para se ter a repetição infinita. Segue outro exemplo simples com repetições infinitas usando o for, que faz a contagem cíclica de 0 a 9 (contagem modular).",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Desvirtuação das repetições</span>"
    ]
  },
  {
    "objectID": "c-desvirtuacao-das-repeticoes.html#sec-while-infinito",
    "href": "c-desvirtuacao-das-repeticoes.html#sec-while-infinito",
    "title": "15  Desvirtuação das repetições",
    "section": "15.1 Laços while infinitos, mas nem tanto",
    "text": "15.1 Laços while infinitos, mas nem tanto\nNão é incomum encontrar códigos em repositórios que utilizem falsos laços infinitos. Segue um programa exemplo desse recurso.\n/*\nLeitura e apresentação de valores não negativos\nRequer: uma sequência de 0 ou mais de inteiros não negativos seguida\n    por um valor negativo usado como sentinela\nAssegura: a apresentação de cada valor da sequência na tela\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    while (true) {\n        char entrada[160];\n        printf(\"&gt; \");\n        int valor;\n        fgets(entrada, sizeof entrada, stdin);\n        sscanf(entrada, \"%d\", &valor);\n        if (valor &lt; 0)\n            break;\n\n        printf(\"  +-- digitado %d.\\n\", valor);\n    }\n\n    return 0;\n}\n&gt; 12\n  +-- digitado 12.\n&gt; 100\n  +-- digitado 100.\n&gt; 18\n  +-- digitado 18.\n&gt; 1\n  +-- digitado 1.\n&gt; -5\nEmbora o while (true) seja um indicador sutil de que talvez não se espere uma repetição infinita, ele requer que o código seja analisado para identificar onde a condição de parada ocorre. No contexto, o comando break interrompe sumariamente a repetição, desestruturando o código.\n\n\n\n\n\n\nDica\n\n\n\nSomente se deve usar o brake para interromper repetições quando essa for realmente a melhor opção, ou seja, quando for uma exceção! Caso contrário, o emprego de while e do while são opções melhores.\n\n\nO programa seguinte é uma versão estruturado com a mesma funcionalidade usando uma condição explícita no while.\n/*\nLeitura e apresentação de valores não negativos\nRequer: uma sequência de 0 ou mais de inteiros não negativos seguida\n    por um valor negativo usado como sentinela\nAssegura: a apresentação de cada valor da sequência na tela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Primeira leitura\n    printf(\"&gt; \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor;\n    sscanf(entrada, \"%d\", &valor);\n\n    while (valor &gt;= 0) {\n        printf(\"  +-- digitado %d.\\n\", valor);\n\n        // Próxima leitura\n        printf(\"&gt; \");\n        fgets(entrada, sizeof entrada, stdin);\n        sscanf(entrada, \"%d\", &valor);\n    }\n\n    return 0;\n}\n&gt; 12\n  +-- digitado 12.\n&gt; 100\n  +-- digitado 100.\n&gt; 18\n  +-- digitado 18.\n&gt; 1\n  +-- digitado 1.\n&gt; -5\nUma versão com do while é apresentada na sequência, com destaque de que a apresentação do valor na tela é feita somente para valores não negativos.\n/*\nLeitura e apresentação de valores não negativos\nRequer: uma sequência de 0 ou mais de inteiros não negativos seguida\n    por um valor negativo usado como sentinela\nAssegura: a apresentação de cada valor da sequência na tela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    int valor;\n    do {\n        printf(\"&gt; \");\n        fgets(entrada, sizeof entrada, stdin);\n        sscanf(entrada, \"%d\", &valor);\n\n        if (valor &gt;= 0)\n            printf(\"  +-- digitado %d.\\n\", valor);\n    } while (valor &gt;= 0);\n\n    return 0;\n}\n&gt; 12\n  +-- digitado 12.\n&gt; 100\n  +-- digitado 100.\n&gt; 18\n  +-- digitado 18.\n&gt; 1\n  +-- digitado 1.\n&gt; -5",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Desvirtuação das repetições</span>"
    ]
  },
  {
    "objectID": "c-desvirtuacao-das-repeticoes.html#o-comando-break-nas-repetições",
    "href": "c-desvirtuacao-das-repeticoes.html#o-comando-break-nas-repetições",
    "title": "15  Desvirtuação das repetições",
    "section": "15.2 O comando break nas repetições",
    "text": "15.2 O comando break nas repetições\nO uso do break para encerrar repetições não é, em si, um erro de programação ou uma falha em si. Em programas mais complexos, com aninhamento de repetições, a indicação explícita de todas as condições que mantém ou encerram uma repetição pode tornar o código difícil de entender.\nO impacto no código das interrupções sumárias com break podem ser atenuadas usando-se um recurso de programação interessante: variáveis lógicas. As variáveis lógicas acrescentam ao código uma informação importante, que é o significado da variável dado por seu nome.\nUma versão de um programa para a leitura de inteiros até encontrar um valor negativo como o usado na Seção 15.1 é apresentado na sequência.\n/*\nLeitura e apresentação de valores não negativos\nRequer: uma sequência de 0 ou mais de inteiros não negativos seguida\n    por um valor negativo usado como sentinela\nAssegura: a apresentação de cada valor da sequência na tela\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    int valor;\n    bool encontrou_sentinela = false;\n    do {\n        printf(\"&gt; \");\n        fgets(entrada, sizeof entrada, stdin);\n        sscanf(entrada, \"%d\", &valor);\n\n        if (valor &lt; 0)\n            encontrou_sentinela = true;\n        else\n            printf(\"  +-- digitado %d.\\n\", valor);\n    } while (!encontrou_sentinela);\n\n    return 0;\n}\n&gt; 12\n  +-- digitado 12.\n&gt; 100\n  +-- digitado 100.\n&gt; 18\n  +-- digitado 18.\n&gt; 1\n  +-- digitado 1.\n&gt; -5\nCom o nome adequado, uma variável lógica somente acrescenta significado ao código: o do while, por exemplo, pode ler entendido como “faça a leitura e apresentação enquanto não encontrar sentinela”.\nPara os programadores que evitam novas variáveis para economizar memória (preocupação legítima!), sempre se deve também considerar a clareza do código. Além disso, uma variável bool em uma máquina com 8GiB de memória principal consome 0,0000002% do total disponível1.",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Desvirtuação das repetições</span>"
    ]
  },
  {
    "objectID": "c-desvirtuacao-das-repeticoes.html#footnotes",
    "href": "c-desvirtuacao-das-repeticoes.html#footnotes",
    "title": "15  Desvirtuação das repetições",
    "section": "",
    "text": "O cálculo considera que sizeof (bool) é um byte, valor usado pelo compilador durante a escrita desse livro.↩︎",
    "crumbs": [
      "Controle de repetição do fluxo",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Desvirtuação das repetições</span>"
    ]
  },
  {
    "objectID": "c-dados-textuais.html",
    "href": "c-dados-textuais.html",
    "title": "16  Dados textuais em C",
    "section": "",
    "text": "16.1 Revisitando as constantes textuais\nA linguagem C não é uma linguagem simples para trabalhar com cadeias de caracteres, as chamadas strings. O suporte para textos na linguagem é feito por constantes inseridas diretamente no código ou manipuladas em variáveis simples ou compostas do tipo char.\nEste capítulo apresenta uma visão inicial das constantes textuais da linguagem e como fazer referências a essas constantes.\nNo Capítulo 3 foram apresentados os principais tipos de dados da linguagem C, incluindo os dados textuais, mas ainda é preciso complementar as informações sobre os tipos literais.\nA linguagem C apresenta duas notações para especificar valores textuais. A primeira é para caracteres únicos, como uma letra ou um símbolo de pontuação, e é expressa usando aspas simples, como 'A' ou '@', por exemplo.\nO programa seguinte ilustra três escritas usando o formato %c (caractere) para apresentar cada valor.\nA segunda forma de expressar constantes literais usa aspas duplas e indica uma sequência de caracteres, como \"linguagem\" e \"compilador gcc\". O printf usa a especificação de formato %s para substituir cadeias de caracteres.\nA principal diferença entre um caractere simples e uma cadeia de caracteres é, além do evidente número de caracteres em si, é a representação. Enquanto caracteres simples apenas são representados apenas por um valor, a cadeia usa uma sequência de caracteres simples seguida pelo terminador \\0, chamado caractere nulo e que é representado com todos os bits iguais a zero. Na prática, quando o compilador encontra uma constante como \"programa\" em um código, ele armazena esse valor como programa\\0, ou seja, sempre com um byte nulo depois do texto em si. Para explicitar um pouco mais, 'Y' é só o Y, enquanto \"Y\" é Y\\0.",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-dados-textuais.html#revisitando-as-constantes-textuais",
    "href": "c-dados-textuais.html#revisitando-as-constantes-textuais",
    "title": "16  Dados textuais em C",
    "section": "",
    "text": "/*\nApresentação de caracteres simples\nAssegura: escrita de caracteres únicos\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Uma letra simples: %c.\\n\", 'f');\n    printf(\"Um símbolo de pontuação: %c.\\n\", ';');\n    printf(\"O espaço: %c.\\n\", ' ');\n\n    return 0;\n}\nUma letra simples: f.\nUm símbolo de pontuação: ;.\nO espaço:  .\n\n/*\nApresentação de cadeias de caracteres\nAssegura: escrita de sequências de caracteres\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Um texto: %s.\\n\", \"Era uma vez...\");\n    printf(\"Texto com uma tabulação: %s\\n\", \"n =\\t20\");\n\n    return 0;\n}\nUm texto: Era uma vez....\nTexto com uma tabulação: n =\t20",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-dados-textuais.html#armazenamento-de-caracteres-simples-o-tipo-char",
    "href": "c-dados-textuais.html#armazenamento-de-caracteres-simples-o-tipo-char",
    "title": "16  Dados textuais em C",
    "section": "16.2 Armazenamento de caracteres simples: o tipo char",
    "text": "16.2 Armazenamento de caracteres simples: o tipo char\nPara criar uma variável para armazenar um único caractere deve ser usado o tipo char. Segue um programa simples ilustrando o conceito.\n/*\nArmazenamento em um char\nAssegura: escrita dos valores armazenados\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char pontuacao = '?';\n    char letra = 'A';\n\n    printf(\"Qual é a letra%c Resposta: %c!\\n\", pontuacao, letra);\n\n    printf(\"Quantidade de bytes em um char: %zu.\\n\", sizeof letra);\n\n    return 0;\n}\nQual é a letra? Resposta: A!\nQuantidade de bytes em um char: 1.\nA linguagem C usa o tipo char para caracteres mas, na prática, trata esse valor como um valor inteiro. Apenas a apresentação com o printf é que escolhe usar o caractere como valor apresentado.\nSeguem dois programas para mostrar que char e int são muito próximos (mas não iguais!).\n/*\nApresentação do char como caractere e como inteiro\nAssegura: apresentação de um char e seu valor associado\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char letra = 'Z';\n    printf(\"O caractere %c é armazenado usando o valor decimal %d.\\n\",\n           letra, letra);\n\n    int valor = 90;\n    printf(\"O valor decimal %d pode ser visto como o caractere %c.\\n\",\n            valor, valor);\n\n    return 0;\n}\nO caractere Z é armazenado usando o valor decimal 90.\nO valor decimal 90 pode ser visto como o caractere Z.\nNesse programa, o valor de letra, que é do tipo char, é apresentado usando-se tanto a interpretação como um caractere, com %c, quanto como um valor decimal, com %d. O mesmo é feito para a variável inteira valor. Nenhum erro ou aviso é emitido pelo compilador.\n/*\nApresentação de manipulações curiosas com char\nAssegura: apresentação de resultados de manipulação\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char letra = 'A';\n    printf(\"A letra atual é %c. \", letra);\n    printf(\"Depois dela vem o %c.\\n\", letra + 1);\n\n    printf(\"\\nAlfabeto minúsculo: \");\n    for (char letra = 'a'; letra &lt;= 'z'; letra++)\n        printf(\"%c\", letra);\n    printf(\"\\n\");\n\n    printf(\"Alfabeto maiúsculo: \");\n    for (char letra = 'A'; letra &lt;= 'Z'; letra++)\n        printf(\"%c\", letra);\n    printf(\"\\n\");\n\n    printf(\"\\nA quantidade de letras de %c até %c é %d.\\n\",\n           'H', 'T', 'T' - 'H' + 1);\n\n    printf(\"\\nA letra que fica no meio de %c e %c é %c.\\n\",\n           'G', 'K', ('G' + 'K') / 2);\n\n    return 0;\n}\nA letra atual é A. Depois dela vem o B.\n\nAlfabeto minúsculo: abcdefghijklmnopqrstuvwxyz\nAlfabeto maiúsculo: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\nA quantidade de letras de H até T é 13.\n\nA letra que fica no meio de G e K é I.\nReforçando a associação de char com um valor inteiro, o programa exemplifica operações como letra + 1 e incrementos como letra++. Adicionalmente há ainda uma expressão interessante: ('G' + 'K') / 2, que soma 'G' (71) com de 'K' (75) e divide o resultado por 2 (divisão inteira), resultando em 73, que é 'I'.\n\n\n\n\n\n\nCuriosidade\n\n\n\nCada letra possui um valor específico associado a ela, assim como cada um dos outros caracteres. Por exemplo, 'A' é o 65, '\\n' é o 10 e ' ' (espaço) é o 32.\nComo esperado, se 'A' é 65, 'B' é 66, 'C' é 67 e assim por diante. Portanto, é possível verificar se letra1 &lt;= letra2, pois uma comparação de inteiros é feita.\nHá um “porém” nessa história: 'Z' é 90, mas 'a' é 97. Na realidade, as minúsculas se iniciam no 97 e vão até o 122. Isso gera uma situação confusa, pois C tem certeza que 'a' &gt; 'Z' é verdadeiro.\n\n\n\n\n\n\n\n\nDica\n\n\n\nEmbora haja um prejuízo quanto á clareza, o tipo char pode ser usado como um “pequeno inteiro” de um byte de comprimento. Dessa forma, usando o primeiro bit para indicar o sinal, uma variável desse tipo guardaria valores de -128 a 127. Caso necessário, pode-se usar a declaração de um unsigned char para ter valores de 0 até 255.\nPara se ter programas mais claros, entretanto, mesmo nesse caso é melhor usar os tipos de comprimento fixo definidos em stdint.h. Assim, para se ter um inteiro com sinal de oito bits, o tipo seria int8_t, e poderia ser usado o uint8_t para o mesmo comprimento sem o sinal. O tipo char deve ser deixado de fato apenas para caracteres. O uso de stdint.h é abordado no ?sec-arquivos-binarios.\n\n\n\n16.2.1 Caracteres acentuados\nNa década de 1960 cada sistema computacional usava sua própria tabela para associar um dado caractere a um valor numérico. Para que os diferentes sistemas pudessem trocar informações, foi elaborada em 1964 uma codificação padronizada denominada American Standard Code for Information Interchange, ou tabela ASCII. Essa tabela definia tanto os caracteres de controle (\\n ou \\t, por exemplo) quanto os caracteres legíveis (letras, dígitos e pontuação).\nNa prática, tanto os caracteres de controle quanto os símbolos legíveis significativos poderiam ser representados com apenas sete bits. Em sistemas com palavras de oito bits, o primeiro bit era usualmente zero, de forma que praticamente metade dos bytes não tinham uso. O ponto em questão é que o conjunto de caracteres era baseado na lingua inglesa, na qual acentuações ou outros símbolos de outras línguas não eram incluídos, como á, ã, Ç, ß (alemão) ou č (esloveno). Os bytes não usados na codificação ASCII (aqueles cujos bits começavam com 1) eram usados para esse fim, cada sistema usando uma codificação específica e particular para atender suas necessidades.\n Em grande parte dos sistemas atuais é empregado o Unicode1, que se propõe a ter representações para todas as línguas do planeta e usa com frequência a codificação UTF-8 para representar os símbolos (letras, ideogramas, emojis) em bytes. Como exemplo, o símbolo monetário do Euro é designado por U+20AC no Unicode e usa a sequência de bytes E282AC para representação em UTF-8.\n\nO problema que surge dessa representação é que UTF-8 usa uma quantidade de bytes variável conforme o símbolo. Os caracteres ASCII usam um único byte e possuem representação igual, o que mantém a compatibilidade. Outros símbolos, porém usam dois, três ou até quatro bytes, o que torna impossível armazená-los em uma variável char.\n/*\nIncompatibilidade de símbolos Unicode/UTF-8\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c = 'é';\n    printf(\"c = %c.\\n\", c);\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:7:14: warning: multi-character character constant [-Wmultichar]\n    7 |     char c = 'é';\n      |              ^~~\nmain.c:7:14: warning: overflow in conversion from ‘int’ to ‘char’ \nchanges value from ‘50089’ to ‘-87’ [-Woverflow]\nc = �.\nA falha na compilação acima é que o caractere é (U+00E9) é codificado em dois bytes, C3 e A9, dos quais apenas o valor A9 (decimal 169) é guardado na variável c. Esse valor 169, sozinho, não representa um caractere UTF-8 válido.\nEsse código fonte, armazenado no arquivo acentuacao.c, está codificado com UTF-8, como se indica com o comando file.\n$ file acentuacao.c\nacentuacao.c: C source, Unicode text, UTF-8 text\nExiste a codificação de caracteres ISO-8859, conhecida como latin1, que inclui os caracteres latinos acentuados e que usa apenas um byte por caractere. O comando iconv pode ser usado para criar um novo arquivo fonte (acentuacao-latin1.c) com essa codificação, conforme segue.\n$ iconv -f utf8 -t latin1 acentuacao.c &gt; acentuacao-latin1.c\n$ file acentuacao-latin1.c\nacentuacao-latin1.c: C source, ISO-8859 text\nComo o caractere é usado no código fonte agora possui um único byte, ele pode ser guardado em um char e a compilação ocorre sem problemas.\n$ gcc -Wall -pedantic -std=c17 acentuacao-latin1.c\nAo executar o programa, como a saída produzida é ISO-8859, ela tem que ser convertida de volta para UTF-8 para que o terminal a exiba corretamente.\n$ ./a.out | iconv -f latin1 -t utf8\nc = é.\n\n\nNos programas exemplificados neste texto, simplesmente são evitados os casos em que um char armazenará um caractere Unicode com mais que um byte, pois todas as codificações de caractere usam UTF-8. Para efetivamente usar caracteres de múltiplos bytes, C disponibiliza uma série de funções em wchar.c, as quais lidam com os “caracteres largos” (wide characters). Porém, o uso dessas funções não é tratado neste livro.",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-dados-textuais.html#sec-ponteiros-para-strings-constantes",
    "href": "c-dados-textuais.html#sec-ponteiros-para-strings-constantes",
    "title": "16  Dados textuais em C",
    "section": "16.3 Acesso às cadeias de caracteres constantes",
    "text": "16.3 Acesso às cadeias de caracteres constantes\nNesta seção é apresentada uma visão básica sobre cadeias de caracteres em C, sendo que a manipulação de variáveis com conteúdo textual é coberta pelo Capítulo 17.\nEm programas escritos em C, cadeias de caracteres são indicadas entre aspas duplas e, internamente, é acrescido um byte nulo para indicar seu fim. Quando uma constante literal é parte de um programa, ela é incluída na seção de dados do arquivo executável.\n\nUm exemplo trivial dessa inclusão pode ser vista com um código simples, como o seguinte.\n/*\nApresentação de mensagens simples\nAssegura: apresentação de duas mensagens na tela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Bom dia!\\n\");\n    printf(\"Boa noite.\\n\");\n\n    return 0;\n}\nBom dia!\nBoa noite.\nEsse programa gera um executável denominado a.out, como observado pelos comandos que seguem.\n$ ls -l a.out\n-rwxrwxr-x 1 jander jander 16136 fev 14 18:16 a.out\n$ file a.out\na.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically \nlinked, interpreter /lib64/ld-linux-x86-64.so.2, \nBuildID[sha1]=a6b3fbd1826fd3417d0b649b1bca180bbeb2aae7, for GNU/Linux 3.2.0, \nnot stripped\nO comando strings usado na sequência mostra as cadeias de caracteres detectadas no arquivo a.out (o egrep é usado para remover outras linhas, de forma a reduzir o tamanho da saída).\n$ strings a.out | egrep -v '(^\\.|^_)'\n/lib64/ld-linux-x86-64.so.2\nputs\nprintf\nlibc.so.6\nGLIBC_2.2.5\nGLIBC_2.34\nPTE1\nu+UH\n%c%s%c\nBom dia!\nBoa noite.\n9*3$\"\nGCC: (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0\nScrt1.o\ncrtstuff.c\nderegister_tm_clones\ncompleted.0\nframe_dummy\nmain.c\nputs@GLIBC_2.2.5\nprintf@GLIBC_2.2.5\nuser_input_time\nprint_user_input\nmain\nComo pode ser observado, \"Bom dia!\" e \"Boa noite.\" fazem parte dos literais fisicamente presentes no arquivo.\n\n\nCom base no fato de que as constantes fazem parte do arquivo executável e que quando o programa é colocado em execução elas são também carregadas para a memória, o programa seguinte mostra como fazer referência a essas cadeias.\n/*\nExemplificação de referência a constantes literais presentes em um programa\nAssegura: apresentação de textos\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    char *texto1 = \"Um primeiro texto\";\n    char *texto2 = \"Texto número 2\";\n\n    char *texto_selecionado;\n    if (rand() % 100 &lt; 50)\n        texto_selecionado = texto1;\n    else\n        texto_selecionado = texto2;\n\n    printf(\"1) %s\\n\", texto1);\n    printf(\"2) %s\\n\", texto2);\n    printf(\"\\nSorteado: %s\\n\", texto_selecionado);\n\n    return 0;\n}\n1) Um primeiro texto\n2) Texto número 2\n\nSorteado: Texto número 2\nNeste programa há dois textos importantes: \"Um primeiro texto\" e \"Texto número 2\". Essas duas constantes textuais ficam em algum lugar do programa. Existem também as duas variáveis texto1 e texto2, que são declaradas como sendo do tipo char *. O asterisco, nesse contexto, indica que as variáveis são referências aos textos e não que sejam um char comum. Dessa forma, texto1 está referenciando a constante \"Um primeiro texto\", por exemplo.\nEssas variáveis que guardam referências às coisas recebem, em programação, o nome de ponteiros2. Como elas são usadas apenas como referência a um texto já existente, não podem ser diretamente usadas para outras manipulações, como para guardar um valor digitado pelo usuário ou tentar modificar a constante referenciada.\nNo jargão computacional, diz-se que “texto1 aponta para a constante \"Um primeiro texto\"”, da mesma forma que texto2 aponta para a constante \"Texto número 2\".\nNo código há ainda a variável texto_selecionado, também do tipo char *, cujo valor inicialmente é indefinido (lixo). A expressão rand() % 100 resulta em um valor (pseudo)aleatório de 0 a 99. Assim, a referência ser guardada em texto_selecionado depende desse valor aleatório, com praticamente 50% de chance para cada caso. Se o valor aleatório for menor que 50, texto_selecionado guarda a mesma referência guardada em texto1, ou seja, ela também aponta para a constante \"Um primeiro texto\"\nNas chamadas a printf, a especificação de formato %s apresenta o texto apontado por cada variável. Desse modo, printf(\"2) %s\\n\", texto2); significa mostre o texto que texto2 está apontando.\nO uso desse recurso é relativamente simples de der feito, porém muito limitado, visto que apenas aceita mudar para qual constante cada variável aponta.\nPara finalizar, é interessante ver que esse recurso foi empregado na implementação do Algoritmo 7.3.",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-dados-textuais.html#footnotes",
    "href": "c-dados-textuais.html#footnotes",
    "title": "16  Dados textuais em C",
    "section": "",
    "text": "Unicode Consortium: https://home.unicode.org.↩︎\nEsse tema é tratado em mais detalhes no Capítulo 20.↩︎",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-manipulacao-de-dados-textuais.html",
    "href": "c-manipulacao-de-dados-textuais.html",
    "title": "17  Manipulação de dados textuais em C",
    "section": "",
    "text": "17.1 As cadeias de caracteres em variáveis\nO uso de variáveis para guardar valores textuais tem sido usado em praticamente todos os programas até o momento e seu uso para leitura está descrito na Seção 4.5.1. Este capítulo apresenta com mais detalhes as cadeias de caracteres e introduz recursos para sua manipulação.\nVariáveis declaradas como char * armazenam, como visto na Seção 16.3, apenas uma referência a uma cadeia de caracteres já existentes. Para que se tenha uma variável para guardar dados textuais de forma genérica, é preciso ter espaço para armazenar tanto os caracteres quanto o terminador \\0.\nComo C não dispões de um tipo nativo para o armazenamento de textos, a alternativa é o uso de um vetor de caracteres. A declaração seguinte ilustra uma declaração para armazenamento de um valor literal. Ela cria um espaço na memória capaz de armazenar 50 valores do tipo char, ou seja, 50 caracteres.\nEsse espaço reservado na declaração é fixo a partir da declaração da variável, ou seja, uma vez escolhido um comprimento, não é possível aumentá-lo ou diminuí-lo.\nO que se faz nos programas é ter um espaço máximo, que é o tamanho declarado para o vetor de caracteres, porém usá-lo apenas parcialmente. Como exemplo, se na variável texto declarada com 50 posições estiver armazenado o texto “grandes responsabilidades”, os caracteres do g inicial até o s final ocupam os primeiros 25 char dela, sendo o 26º caractere necessariamente um \\0. Restam na variável 24 posições sem uso e seu conteúdo é ignorado.\nCom essa estratégia de uso, o conteúdo textual pode ser aumentado pelo uso dos caracteres sobressalentes, deslocando-se o \\0 mais para o final do vetor, ou encolhido, quando o terminador ocupa uma posição mais para o início. O limite evidente é o espaço total reservado para o armazenamento, sempre se lembrando que deve haver um espaço para o terminador. Assim, a variável texto pode ter comprimento máximo de 49 char, pois tem que haver espaço para o \\0 final.\nDesse modo, pelo uso desse mecanismo de armazenamento, mantém-se uma compatibilidade com as constantes usadas no código: se existe uma constante \"bom dia!\" ocupando nove bytes no programa, esse mesmo valor pode ser guardado em uma variável, ocupando as nove primeiras posições do vetor de caracteres.",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Manipulação de dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-manipulacao-de-dados-textuais.html#as-cadeias-de-caracteres-em-variáveis",
    "href": "c-manipulacao-de-dados-textuais.html#as-cadeias-de-caracteres-em-variáveis",
    "title": "17  Manipulação de dados textuais em C",
    "section": "",
    "text": "char texto[50];",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Manipulação de dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-manipulacao-de-dados-textuais.html#manipulação-de-conteúdo",
    "href": "c-manipulacao-de-dados-textuais.html#manipulação-de-conteúdo",
    "title": "17  Manipulação de dados textuais em C",
    "section": "17.2 Manipulação de conteúdo",
    "text": "17.2 Manipulação de conteúdo\nUma dificuldade imediata é que os vetores de caracteres não são uma variável simples, mas uma coleção de variáveis individuais tratadas como uma coisa só. Como não são variáveis como as declaradas como int, double ou mesmo char simples, não admitem atribuições ou manipulações diretas. Para tratar as variáveis textuais C provê uma série de funções, as quais podem ser usadas pela importação do cabeçalho string.h.\n\n\n\n\n\n\nDica\n\n\n\nO arquivo de cabeçalho é string.h.\n#include &lt;string.h&gt;\nExiste, porém, outro arquivo de cabeçalhos chamado strings.h (no plural) e eles não podem ser confundidos.\n\n\nPara que se tenha utilidade prática na manipulação de variáveis textuais, é preciso que se possa ver o comprimento do texto e fazer atribuições de valores, realizar concatenações e comparações.\n\n17.2.1 Comprimento de cadeias de caracteres\nUma função que já foi usada anteriormente em diversos programas é a strlen (string length), que retorna o comprimento da cadeia de caracteres sem o \\0 final.\n/*\nComprimento de cadeias de caracteres\nAssegura: a apresentação de textos e respectivos comprimentos\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char *texto1 = \"C: a linguagem\";\n    printf(\"\\\"%s\\\" tem comprimento %zu.\\n\", texto1, strlen(texto1));\n\n    char *texto2 = \"\";\n    printf(\"\\\"%s\\\" tem comprimento %zu.\\n\", texto2, strlen(texto2));\n\n    char *texto3 = \"Programas estruturados\";\n    printf(\"\\\"%s\\\" tem comprimento %zu.\\n\", texto3, strlen(texto3));\n\n    return 0;\n}\n\"C: a linguagem\" tem comprimento 14.\n\"\" tem comprimento 0.\n\"Programas estruturados\" tem comprimento 22.\n\n\n17.2.2 Atribuições de cadeias de caracteres\nO programa seguinte foca na questão da atribuição. Porém, esse código serve apenas para mostrar o que não funciona.\n/*\nTentativa malsucedida de atribuir um valor a uma variável\nAssegura: absolutamente nada (infelizmente)\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char texto[50];\n\n    texto = \"Bom dia!\";\n    printf(\"%s\\n\", texto);\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:10:11: error: assignment to expression with array type\n   10 |     texto = \"Bom dia!\";\n      |           ^\nO humilde autor desse texto tem convicção que praticamente a totalidade dos programadores C do planeta desejariam que esse programa funcionasse. A realidade, porém, não é essa: o erro principal do código é exatamente a atribuição. Basicamente, texto é o nome para a coleção de caracteres e, na linguagem, não faz sentido armazenar nela uma constante.\nO programa seguinte mostra como a função strncpy (string copy) pode ser usada para obter o mesmo efeito da atribuição.\n/*\nAtribuição e apresentação de valor textual\nAssegura: apresentação do valor guardado em uma string\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char texto[50];\n\n    strncpy(texto, \"Bom dia!\", sizeof texto - 1);\n    printf(\"%s\\n\", texto);\n\n    return 0;\n}\nBom dia!\nO processo da atribuição é copiar um dado valor para uma variável.\nstrncpy(texto, \"Bom dia!\", sizeof texto - 1);\nO primeiro parâmetro de strncpy é a variável que receberá o valor. O segundo parâmetro é o valor que será atribuído, que pode ser uma constante ou outra variável. Há, ainda, um terceiro parâmetro, que é o tamanho da variável, que é importante para garantir que o limite de espaço reservado para a variável será respeitado. Ultrapassar o tamanho da variável pode trazer consequências imprevisíveis à execução.\n\n\n\n\n\n\nDica\n\n\n\nExistem funções de manipulação de cadeias de caracteres que não verificam o tamanho da variável destino. É importante nunca usá-las.\n\n\n\n\n17.2.3 Concatenação de cadeias de caracteres\nAlém da cópia de uma sequência de caracteres para uma variável, é possível estender seu conteúdo, fazendo a concatenação. A função strncat (string catenation) faz a cópia de uma cadeia anexando-a a outra.\n/*\nCriação de uma única linha a partir de leituras separadas\nRequer: Uma sequência de linhas de texto\nAssegura: apresentação da concatenação de todas as linhas em uma só\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char texto[160];\n    char linha_unica[5000];\n\n    // Inicia uma cadeia vazia\n    strncpy(linha_unica, \"\", sizeof linha_unica - 1);\n\n    // Acrescenta cada linha digitada à linha única\n    printf(\"Digite linhas, usando Ctrl-D para encerrar:\\n\");\n    bool primeira_palavra = true;\n    while (fgets(texto, sizeof texto, stdin) != NULL) {\n\n        texto[strlen(texto) - 1] = '\\0';\n        if (primeira_palavra)\n            primeira_palavra = false;\n        else\n            strncat(linha_unica, \" \",\n                    sizeof linha_unica - strlen(linha_unica) - 1);\n\n        strncat(linha_unica, texto,\n                sizeof linha_unica - strlen(linha_unica) - 1);\n    }\n\n    // Texto total\n    printf(\"\\n\\\"%s\\\"\\n\", linha_unica);\n\n    return 0;\n}\nDigite linhas, usando Ctrl-D para encerrar:\nEra\numa\nvez\numa linda menina\nque possuia uma capa vermelha com\ncapuz.\n\n\"Era uma vez uma linda menina que possuia uma capa vermelha com capuz.\"\nA função de concatenação acrescenta à variável do primeiro parâmetro (linha_unica) uma cópia dos caracteres contidos no segundo parâmetro (texto). O terceiro parâmetro é a quantidade máxima de caracteres a serem copiados, a qual é usada para respeitar o tamanho do espaço da variável destino. No código, a quantidade máxima para cada concatenação corresponde ao cálculo do espaço livre existente em linha_unica, respeitando um byte para ter espaço para o \\0 final.\n\n\n17.2.4 Comparações de cadeias de caracteres\nA comparação entre duas cadeias de caracteres é feita no sentido alfabético usual, sempre comparando os primeiros caracteres das duas cadeias e, sendo iguais, passando para os segundos, terceiros e assim por diante. Nas funções de string.h, a função strncmp (string comparison) tem a finalidade realizar as comparações.\nA função strncmp retorna sempre um valor inteiro, como apresentado na Tabela 17.1.\n\n\n\nTabela 17.1: Resultados possíveis para a função strncmp.\n\n\n\n\n\nResultado\nSignificado\n\n\n\n\nzero\nIguais\n\n\nmenor que zero\nAnterior\n\n\nmaior que zero\nPosterior\n\n\n\n\n\n\nSegue um programa ilustrando o uso de strncmp.\n/*\nComparações de cadeias de caracteres\nRequer: a digitação de pares de palavras em cada linha\nAssegura: a apresentação da comparação entre as palavras de cada par\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char linha[160];\n    printf(\"Digite duas palavras por linha, usando Ctrl-D para encerrar:\\n\");\n    while (fgets(linha, sizeof linha, stdin) != NULL) {\n        char palavra1[80], palavra2[80];\n        sscanf(linha, \"%79s%79s\", palavra1, palavra2);  // palavras simples\n\n        if (strncmp(palavra1, palavra2, sizeof palavra1) == 0)\n            printf(\"%s é igual a %s.\\n\", palavra1, palavra2);\n        else if (strncmp(palavra1, palavra2, sizeof palavra1) &lt; 0)\n            printf(\"%s é anterior a %s.\\n\", palavra1, palavra2);\n        else\n            printf(\"%s é posterior a %s.\\n\", palavra1, palavra2);\n    }\n\n    return 0;\n}\nDigite duas palavras por linha, usando Ctrl-D para encerrar:\nabacaxi abacaxi\nabacaxi é igual a abacaxi.\nmarca marcas\nmarca é anterior a marcas.\nvermelho azul\nvermelho é posterior a azul.\nazul vermelho\nazul é anterior a vermelho.\ncontraponto contraindicado\ncontraponto é posterior a contraindicado.\nUma discussão sobre comparações de palavras acentuadas é apesentada na Seção 17.5.",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Manipulação de dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-manipulacao-de-dados-textuais.html#mais-sobre-declaração-de-variáveis-textuais",
    "href": "c-manipulacao-de-dados-textuais.html#mais-sobre-declaração-de-variáveis-textuais",
    "title": "17  Manipulação de dados textuais em C",
    "section": "17.3 Mais sobre declaração de variáveis textuais",
    "text": "17.3 Mais sobre declaração de variáveis textuais\nAssim como variáveis aritméticas e lógicas, variáveis literais também podem ser iniciadas na declaração. Há formatos diferentes para essa iniciação.\nO programa seguinte ilustra os diferentes formatos, os quais serão abordados individualmente na sequência.\n/*\nExemplificação de declaração de cadeias de caracteres juntamente com iniciação\nAssegura: apresentação dos textos atribuídos e do tamanho de cada variável\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    // Referência a uma constante\n    char *texto1 = \"Um texto constante e fixo\";\n    printf(\"texto1 = '%s'.\\n\", texto1);\n\n    // Variável com comprimento explícito\n    char texto2[100] = \"Uma variável de até 99 posições\";\n    printf(\"texto2 = '%s'.\\n\", texto2);\n\n    // Variável com comprimento automático\n    char texto3[] = \"Variável com comprimento dependente do valor atribuído\";\n    printf(\"texto3 = '%s'.\\n\", texto3);\n\n    // Comprimentos das variáveis\n    printf(\"\\ntexto1: %zu bytes, pois é apenas referência a uma constante.\\n\",\n           sizeof texto1);\n    printf(\"texto2: %zu bytes, conforme tamanho especificado.\\n\",\n           sizeof texto2);\n    printf(\"texto3: %zu bytes, pois depende do texto de iniciação.\\n\",\n           sizeof texto3);\n\n    return 0;\n}\ntexto1 = 'Um texto constante e fixo'.\ntexto2 = 'Uma variável de até 99 posições'.\ntexto3 = 'Variável com comprimento dependente do valor atribuído'.\n\ntexto1: 8 bytes, pois é apenas referência a uma constante.\ntexto2: 100 bytes, conforme tamanho especificado.\ntexto3: 57 bytes, pois depende do texto de iniciação.\nO primeiro formato é o utilizado na Seção 16.3, que declara uma variável que é apenas uma referência a um texto em outro lugar. No caso, esse texto é uma constante que o compilador insere no código fonte. Ao longo do código, a variável texto1 pode ser alterada de forma a apontar para outro texto.\nchar *texto = \"Texto\";  // a variável é uma referência à constante \"Texto\"\nOutra possibilidade é a mais usual, criando-se um vetor de caracteres com um tamanho predeterminado e, juntamente a isso, fazer a cópia de um valor para ele. Para o caso da variável texto2 do programa, há a alocação de um espaço total de 100 bytes, permitindo um texto de até 99 bytes. Ao fazer a declaração, um cópia da constante textual é feita para a variável. Como texto2 recebe uma cópia, os dados da variável podem ser alterados.\nchar *texto[20] = \"Texto\";  // a variável tem 20 posições, usando as 6\n                            // primeiras para guardar \"Texto\" e \\0\nFinalmente, texto3 é uma variável declarada como texto2, porém omitindo seu comprimento. Neste caso, a variável é criada com capacidade para guardar exatamente o valor atribuído, ou seja, o espaço para os caracteres e para o \\0 terminal.\nchar *texto[] = \"Texto\";  // a variável tem exatamente as 6 posições\n                          // necessárias para guardar \"Texto\" e \\0\nÉ importante lembrar que as declarações que usam os colchetes, seja com tamanho explícito ou omitido, o espaço reservado para a variável deve sempre ser respeitado.",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Manipulação de dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-manipulacao-de-dados-textuais.html#acesso-direto-ao-conteúdo",
    "href": "c-manipulacao-de-dados-textuais.html#acesso-direto-ao-conteúdo",
    "title": "17  Manipulação de dados textuais em C",
    "section": "17.4 Acesso direto ao conteúdo",
    "text": "17.4 Acesso direto ao conteúdo\nUma forma prática de usar cadeias de caracteres é fazendo acesso a cada posição individual do vetor. Para isso, é possível indicar um char qualquer armazenado especificando sua posição no vetor.\nO programa seguinte mostra como cada posição de uma cadeia de caracteres pode ser acessada.\n/*\nApresentação de um texto caractere a caractere\nRequer: um texto digitado pelo usuário\nAssegura: apresentação de cada caractere, posição a posição\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    printf(\"Digite um texto qualquer:\\n\");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n\n    for (int posicao = 0; posicao &lt; strlen(texto) - 1; posicao++)\n        printf(\"%2d: '%c'\\n\", posicao, texto[posicao]);\n\n    return 0;\n}\nDigite um texto qualquer:\nSubi no ombro de gigantes!\n 0: 'S'\n 1: 'u'\n 2: 'b'\n 3: 'i'\n 4: ' '\n 5: 'n'\n 6: 'o'\n 7: ' '\n 8: 'o'\n 9: 'm'\n10: 'b'\n11: 'r'\n12: 'o'\n13: ' '\n14: 'd'\n15: 'e'\n16: ' '\n17: 'g'\n18: 'i'\n19: 'g'\n20: 'a'\n21: 'n'\n22: 't'\n23: 'e'\n24: 's'\n25: '!'\nA variável texto possui um espaço de armazenamento para 160 caracteres simples. Cada uma dessas posições pode ser indica por um índice, que vai de zero a 159. Assim, o primeiro caractere do texto está em texto[0], o segundo em texto[1] e o último em texto[strlen(texto) - 1]. No programa, o laço de repetição claramente se inicia na posição zero, mas é relevante ressaltar que a última posição apresentada na tela é a strlen(texto) - 2, o que evita escrever o \\n que está na última posição.\n\n\n\n\n\n\nDica\n\n\n\nUma das grandes fontes de erro no acesso aos índices de uma cadeia de caracteres é errar nos limites dos índices. Não é incomum, em uma repetição, faltar uma posição ou passar uma posição.\nAtenção é sempre necessária nesse ponto.\n\n\nAlém das funções em string.h, há algumas interessantes em ctype.h, que permitem facilmente verificar caracteres. A Tabela 17.2 apresenta uma lista de várias funções interessantes.\n\n\n\nTabela 17.2: Funções para verificação de caracteres simples (ctype.h). Todas as funções retornam um inteiro não nulo em caso de sucesso ou zero, caso contrário.\n\n\n\n\n\n\n\n\n\nFunção\nSignificado\n\n\n\n\nisalpha(c)\nVerifica se c é um caractere alfabético (i.e., uma letra).\n\n\nisdigit(c)\nVerifica se c é um dígito de 0 a 9.\n\n\nisalnum(c)\nVerifica se c é alfanumérico, ou seja se é alfabético ou dígito.\n\n\nisascii(c)\nVerifica se c é um caractere ASCII do escopo de 7 bits.\n\n\niscntrl(c)\nVerifica se c é um caractere de controle.\n\n\nislower(c)\nVerifica se c é uma letra minúscula.\n\n\nisupper(c)\nVerifica se c é uma letra maiúscula.\n\n\nisspace(c)\nVerifica se c é qualquer caractere de “espaço branco” (white-space), ou seja espaço, \\f, \\n, \\r, e \\v.\n\n\nisblank(c)\nVerifica se c é um caractere “branco” (blank), o seja, se é espaço ou tabulação.\n\n\nisprint(c)\nVerifica se c é um caractere imprimível, incluindo o espaço.\n\n\nisgraph(c)\nVerifica se c é um caractere imprimível, exceto o espaço.\n\n\nispunct(c)\nVerifica se c é um caractere imprimível que não seja um espaço ou um caractere alfanumérico.\n\n\nisxdigit(c)\nVerifica se c for hexadecimal digits, that is, one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F.\n\n\n\n\n\n\nPara exemplificar o uso de algumas funções, segue um programa que conta alguns itens de interesse em um texto digitado pelo usuário.\n/*\nContagem de maiúsculas, minúsculas, pontuação, dígitos e caracteres de\n    controle em um texto\nRequer: um texto digitado pelo usuário\nAssegura: apresentação das contagens de maiúsculas, minúsculas, pontuação,\n    dígitos e caracteres de controle presentes no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n\nint main(void) {\n    printf(\"Digite um texto qualquer:\\n\");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n\n    int contador_minusculas = 0;\n    int contador_maiusculas = 0;\n    int contador_pontuacao = 0;\n    int contador_digitos = 0;\n    int contador_controle = 0;\n\n    int i = 0;\n    while (texto[i] != '\\0') {\n        if (islower(texto[i]))\n            contador_minusculas++;\n        else if (isupper(texto[i]))\n            contador_maiusculas++;\n        else if (ispunct(texto[i]))\n            contador_pontuacao++;\n        else if (isdigit(texto[i]))\n            contador_digitos++;\n        else if (iscntrl(texto[i]))\n            contador_controle++;\n\n        i++;\n    }\n\n    printf(\"Maiúsculas: %d.\\n\", contador_maiusculas);\n    printf(\"Minúsculas: %d.\\n\", contador_minusculas);\n    printf(\"Pontuação: %d.\\n\", contador_pontuacao);\n    printf(\"Dígitos: %d.\\n\", contador_digitos);\n    printf(\"Caracteres de controle: %d.\\n\", contador_controle);\n\n    return 0;\n}\nDigite um texto qualquer:\nMoro na rua XV de Novembro, 2605\nMaiúsculas: 4.\nMinúsculas: 17.\nPontuação: 1.\nDígitos: 4.\nCaracteres de controle: 1.\nEsse programa usa algumas das funções da Tabela 17.2 para fazer a contagem de alguns tipos de caracteres. O resultado para o texto Moro na rua XV de Novembro, 2605 pode ser visto diretamente. Um destaque é feito para o número de caracteres de controle, que incluiu o \\n existente no fim do texto de entrada.\n\n17.4.1 A remoção do \\n incluído pelo fgets\nUma ação bastante comum quando a leitura de um valor textual é feito com a função fgets é a remoção do \\n que ela deixa na cadeia de caracteres lida. Essa remoção é importante para ficar somente com o texto digitado. Em mais detalhes, essa remoção parte de dois princípios: primeiro, que a leitura com o fgets sempre terá um \\n no seu final e, segundo, que tudo que estiver na variável a partir do \\0 é ignorado.\nDessa forma, a eliminação do \\n é feita pela simples atribuição do \\0 sobre ele. Como consequência, a cadeia de caracteres contém um novo final.\ntexto[strlen(texto) - 1] = '\\0';  // elimina o último caractere sobrepondo\n                                  // a ele um novo terminador de cadeia\nO programa seguinte tem o objetivo de apresentar essa remoção em detalhes, mostrando o conteúdo da variável antes e depois da eliminação do \\n.\n/*\nApresentação de todos os valores contidos em uma variável literal\nRequer: um texto de até 24 caracteres digitados pelo usuário\nAssegura: apresentação detalhada do texto posição a posição antes e\n    depois da remoção do \\n remanescente do fgets\n*/\n#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    // Leitura do texto\n    char texto[25];\n    printf(\"Digite um texto qualquer:\\n\");\n    fgets(texto, sizeof texto, stdin);\n\n    // Apresentação do vetor inteiro\n    printf(\"\\nAntes:\\n\");\n    for (int i = 0; i &lt; (int)sizeof texto; i++)\n        printf(\"%3d\", i);\n    printf(\"\\n\");\n    for (int i = 0; i &lt; (int)sizeof texto; i++) {\n        if (texto[i] == '\\0')\n            printf(\" \\\\0\");\n        else if (texto[i] == '\\n')\n            printf(\" \\\\n\");\n        else if (texto[i] == ' ')\n            printf(\"   \");\n        else if (isprint(texto[i]))\n            printf(\"%3c\", texto[i]);\n        else\n            printf(\" ??\");\n    }\n    printf(\"\\n\");\n\n    // Remoção do \\n final\n    texto[strlen(texto) - 1] = '\\0';  // remoção do \\n\n\n    // Reapresentação do vetor depois da alteração\n    printf(\"\\nDepois:\\n\");\n    for (int i = 0; i &lt; (int)sizeof texto; i++)\n        printf(\"%3d\", i);\n    printf(\"\\n\");\n    for (int i = 0; i &lt; (int)sizeof texto; i++) {\n        if (texto[i] == '\\0')\n            printf(\" \\\\0\");\n        else if (texto[i] == '\\n')\n            printf(\" \\\\n\");\n        else if (texto[i] == ' ')\n            printf(\"   \");\n        else if (isprint(texto[i]))\n            printf(\"%3c\", texto[i]);\n        else\n            printf(\" ??\");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\nDigite um texto qualquer:\nTeste\n\nAntes:\n  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n  T  e  s  t  e \\n \\0  ~  ) ?? ?? ??  @ ?? ?? \\0  | ??  T ?? ?? \\0 ?? ??  v\n\nDepois:\n  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n  T  e  s  t  e \\0 \\0  ~  ) ?? ?? ??  @ ?? ?? \\0  | ??  T ?? ?? \\0 ?? ??  v\nO objetivo desse programa é apresentar todas as posições da variável, incluindo as inválidas depois do \\0 final. Na saída, os valores \\n e \\0 são verificados para serem apresentados de forma coerente, enquanto quaisquer caracteres não imprimíveis são apresentados como ??. Para visualização, o vetor foi definido com tamanho 25. Tudo que está depois do \\0 é, naturalmente, lixo.\nPode-se observar que depois da leitura, a posição 5 contém o \\n e a 6 o \\0 final. Depois da eliminação do \\n, há um \\0 na posição 5, fazendo com que o conteúdo válido seja somente as posições de 0 a 4.",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Manipulação de dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-manipulacao-de-dados-textuais.html#sec-acentuacao-em-strings",
    "href": "c-manipulacao-de-dados-textuais.html#sec-acentuacao-em-strings",
    "title": "17  Manipulação de dados textuais em C",
    "section": "17.5 Acentuações nas cadeias de caracteres",
    "text": "17.5 Acentuações nas cadeias de caracteres\nComo abordado na Seção 16.2.1, o uso de Unicode como tabela de caracteres e sua a codificação UTF-8 são bastante comuns nos sistemas computacionais atuais e seu suporte em C é muito limitado. Há, entretanto, uma boa notícia. Da forma em que foi desenvolvido o sistema de representação de caracteres com múltiplos bytes, as funções especificadas em string.h continuam funcionando a contento. Há, claro, exceções.\nA função strncpy apenas copia todos os bytes até que o terminador \\0 seja encontrado. Assim, independentemente da codificação adotada, a cópia é fiel ao original. O mesmo raciocínio se aplica a strncat. Na comparação por meio de strncmp, a comparação pela igualdade funciona perfeitamente, pois se o texto é igual, também é sua codificação UTF-8, e a comparação ocorre entre os bytes e não entre os caracteres representados em si.\nA comparação por desigualdade com strncmp, como abordado na Seção 17.2.4, tem suas limitações, uma vez que, por exemplo, Y vem antes de b na ordenação das tabelas de caracteres. Com UTF-8, essas limitações são agravadas. Por exemplo, \"aí\" é codificado para a sequência de bytes 97, 195 e 173 (a usa um byte, enquanto í necessita de dois) e \"abc\" tem codificação 97, 98 e 99 (um byte para cada letra), de modo que na comparação, b é comparado com uma parte de í e c é emparelhado com o seu segundo byte. Nada disso é coerente.\nA pior situação fica com strlen, que retorna sempre o número de bytes e não o de caracteres. Ela é prática para determinar o número de caracteres simples do início até o \\0, mas não considera múltiplos bytes por caractere.\nQuando o espaço total na variável comporta o conteúdo que está sendo atribuído ou concatenado, o comportamento descrito até agora prevalece. O problema ocorre quando não há espaço e somente parte de um caractere de múltiplos bytes é copiada. O resultado, então, é um caractere inválido.\nO programa seguinte ilustra o uso de caracteres acentuados nas strings.\n/*\nIlustração do uso de acentuação em cadeias de caracteres e algumas de suas\n    limitações\nAssegura: apresentação de atribuições bem sucedidas, da incoerência no\n    comprimento da string e falha na atribuição parcial de um caractere\n    longo\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n\nint main(void) {\n    char texto[160];\n\n    // Situação normal\n    strncpy(texto, \"Acentuação e Unicode são assim\", sizeof texto - 1);\n    printf(\"%s.\\n\", texto);\n    strncat(texto, \": hvaða tungumál er þetta?\", sizeof texto - strlen(texto) - 1);\n    printf(\"%s\\n\", texto);\n\n    // Comprimento é infiel ao número de caracteres\n    strncpy(texto, \"Ímã\", sizeof texto - 1);\n    printf(\"'%s' tem comprimento %zu.\\n\", texto, strlen(texto));\n\n    // Problema com espaço insuficiente\n    char texto_pequeno[5];  // cabem 4 bytes\n    strncpy(texto_pequeno, texto, sizeof texto_pequeno - 1);\n    printf(\"Atribuição parcial: '%s'.\\n\", texto_pequeno);\n\n    return 0;\n}\nAcentuação e Unicode são assim.\nAcentuação e Unicode são assim: hvaða tungumál er þetta?\n'Ímã' tem comprimento 5.\nAtribuição parcial: 'Ím�'.\nNesse programa, a atribuição e uso de textos em Unicode funcionam normalmente no geral. O comprimento, como é o número de bytes, pode não corresponder ao número de caracteres. Um problema mais grave ocorre quando um caractere é copiado de forma incompleta, como ocorre quando apenas o primeiro byte que forma o ã é transferido por não haver espaço na variável texto_pequeno.\nA conclusão é que, havendo espaço suficiente para o armazenamento, a codificação de caracteres pode ser usada com as funções convencionais sem uma implicação negativa significativa. Isso ocorre para a maioria dos casos e, em geral, não é uma preocupação muito grande. Ainda vale apontar que wchar.h contém funções específicas para trabalhar com caracteres de múltiplos bytes.\n\n\n\n\n\n\nDica\n\n\n\nDeclarar variáveis texto com espaço um pouco superdimensionado ajuda a evitar problemas, principalmente quando se espera uma variabilidade grande no comprimento dos textos. Esse é o caso de uma variável para guardar um nome.\nVariáveis mais “apertadas” se justificam quando a variabilidade de comprimento é muito pequena. Para exemplificar, o armazenamento de um CPF pode usar comprimento 15, pois o comprimento é sempre fixo com 14 caracteres (dígitos, pontos e hífen). Neste caso, não há necessidade de folga.",
    "crumbs": [
      "Cadeias de caracteres",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Manipulação de dados textuais em C</span>"
    ]
  },
  {
    "objectID": "c-funcoes.html",
    "href": "c-funcoes.html",
    "title": "18  Funções em C",
    "section": "",
    "text": "18.1 O que é uma função\nAs funções são parte essencial do desenvolvimento de qualquer código. Não somente evitam que trabalho extra tenha que ser feito mas também melhoram a qualidade geral do código como um todo. As estruturas e estratégias das funções serão abordadas ao longo deste capítulo.\nO conceito de função nas linguagens de programação é bastante similar ao das funções matemáticas, estas últimas mapeando um conjunto domínio em um conjunto chamado contradomínio. A função \\({y = \\cos x}\\), por exemplo, é usualmente definida para mapear valores \\({x \\in \\mathbb{R}}\\) para \\({y \\in \\mathbb{R}}\\), sendo domínio e contradomínio iguais; a função \\({y = \\lfloor x \\rfloor}\\) (função piso), por sua vez, tem domínio real e contradomínio inteiro.\nBasicamente, uma função é aplicada em um argumento1 do domínio e tem como resultado um valor do contradomínio.\nUm exemplo de programa que inclui uma função matemática é apresentado a seguir.\nEm C, a função sqrt retorna a raiz quadrada de um valor, sendo seu domínio e contradomínio double.\nComo domínio e contradomínios não precisam ser iguais, segue exemplo em C que ilustra uma função nessa condição.\nA função strlen faz o mapeamento de cadeias de caracteres (seu domínio) para valores inteiros (contradomínio).\nAs funções em C podem mapear os mais diferentes tipos de dados para outros tantos tipos, como de double para int, int para double ou cadeias de caracteres para double, por exemplo.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Funções em C</span>"
    ]
  },
  {
    "objectID": "c-funcoes.html#o-que-é-uma-função",
    "href": "c-funcoes.html#o-que-é-uma-função",
    "title": "18  Funções em C",
    "section": "",
    "text": "/*\nApresentação de valores de raiz quadrada\nAssegura: apresentação do valor e sua raiz, de 0 a 1, de 0,1 em 0,1\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    for (double valor = 0; valor &lt;= 1.0; valor += 0.1)\n        printf(\"A raiz quadrada de %g é %g.\\n\", valor, sqrt(valor));\n\n    return 0;\n}\nA raiz quadrada de 0 é 0.\nA raiz quadrada de 0.1 é 0.316228.\nA raiz quadrada de 0.2 é 0.447214.\nA raiz quadrada de 0.3 é 0.547723.\nA raiz quadrada de 0.4 é 0.632456.\nA raiz quadrada de 0.5 é 0.707107.\nA raiz quadrada de 0.6 é 0.774597.\nA raiz quadrada de 0.7 é 0.83666.\nA raiz quadrada de 0.8 é 0.894427.\nA raiz quadrada de 0.9 é 0.948683.\nA raiz quadrada de 1 é 1.\n\n\n/*\nApresentação de uma cadeia de caracteres e seu tamanho em bytes\nAssegura: apresentação de um texto e o número de bytes que ele ocupa\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char *texto = \"Modularização\";\n\n    printf(\"\\\"%s\\\" usa %zu bytes.\\n\", texto, strlen(texto));\n    return 0;\n}\n\"Modularização\" usa 15 bytes.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Funções em C</span>"
    ]
  },
  {
    "objectID": "c-funcoes.html#declaração-e-implementação-das-funções",
    "href": "c-funcoes.html#declaração-e-implementação-das-funções",
    "title": "18  Funções em C",
    "section": "18.2 Declaração e implementação das funções",
    "text": "18.2 Declaração e implementação das funções\nTodo programa em C contém pelo menos uma função. Desde o primeiro código apresentado nesse livro (o programa que não faz nada, na Seção 2.2.1), fica patente que todo executável gerado a partir de um código em C precisa de main, e main é uma função. Como usado em todos os programas até o momento, a função principal tem domínio vazio (indicado por void) e seu contradomínio é o tipo int.\nint main(void) {\n    ...\n    return 0;\n}\nToda função tem um nome. Neste caso, o nome é main, assim como seriam logaritmo (\\(\\log\\)) ou cosseno (\\(\\cos\\)) para citar algumas funções matemáticas. Entre os parênteses estão especificados seus parâmetros e, para main, não há efetivamente nenhum parâmetro. O contradomínio é indicado antes do nome da função: int.\nPara citar um exemplo já conhecido, a função sqrt tem a seguinte declaração em math.h.\ndouble sqrt(double x);\nColocando-se isso mais explicitamente, sqrt aceita um double como parâmetro e, como resultado, devolve um valor também double.\n\n18.2.1 Declaração e implementação de funções próprias\nO programador tem como uma grande vantagem poder escrever suas próprias funções e, para isso, precisa fazer sua declaração.\n\n\n\n\n\n\nDeclaração de função\n\n\n\ntipo_de_retorno nome_da_função ( lista_de_parâmetros) ;\n\n\nAs funções precisam ter um nome_da_função (identificador válido), especificar seu tipo_de_retorno e seus parâmetros (lista_de_parâmetros). Declarações de função nesse formato são conhecidos como protótipos da função.\nOs conceitos envolvidos na escrita de funções podem ser ilustrados por uma sequência de tentativas de escrever um programa que usa uma função. Esse programa tem o objetivo de ler um texto qualquer e apresentar o número de vogais presentes (ignorando acentuações).\nSegue a versão do programa sem nenhuma função.\n/*\nDeterminação da quantidade de vogais em um texto digitado pelo usuário\nRequer: um texto qualquer\nAssegura: apresentação do número de vogais contidas no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    printf(\"Digite um texto: \");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n    texto[strlen(texto) - 1] = '\\0';\n\n    int numero_vogais = 0;\n    for (int i = 0; i &lt; (int)strlen(texto); i++)\n        if (texto[i] == 'a' || texto[i] == 'e' || texto[i] == 'i' ||\n             texto[i] == 'o' || texto[i] == 'u' || texto[i] == 'A' ||\n             texto[i] == 'E' || texto[i] == 'I' || texto[i] == 'O' ||\n             texto[i] == 'U')\n            numero_vogais++;\n\n    printf(\"\\\"%s\\\" possui %d %s.\\n\", texto, numero_vogais,\n           numero_vogais &gt; 1 ? \"vogais\" : \"vogal\");\n\n    return 0;\n}\nDigite um texto: Comece pelo começo, disse a Rainha a Alice\n\"Comece pelo começo, disse a Rainha a Alice\" possui 18 vogais.\nA linguagem provê funções de verificação do tipo dos caracteres, como isdigit ou isspace (Tabela 17.2), entre outras. Porém, entre elas não se inclui uma que verifica as vogais.\nAssim, o objetivo do programa é ter uma função para verificar se um dado caractere é ou não uma vogal. Essa função será nomeada eh_vogal. O código seguinte tenta usar essa função, que até o momento não existe.\n/*\nDeterminação da quantidade de vogais em um texto digitado pelo usuário\nRequer: um texto qualquer\nAssegura: apresentação do número de vogais contidas no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    printf(\"Digite um texto: \");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n    texto[strlen(texto) - 1] = '\\0';\n\n    int numero_vogais = 0;\n    for (int i = 0; i &lt; (int)strlen(texto); i++)\n        if (eh_vogal(texto[i]))\n            numero_vogais++;\n\n    printf(\"\\\"%s\\\" possui %d %s.\\n\", texto, numero_vogais,\n           numero_vogais &gt; 1 ? \"vogais\" : \"vogal\");\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:17:13: warning: implicit declaration of function ‘eh_vogal’ \n[-Wimplicit-function-declaration]\n   17 |         if (eh_vogal(texto[i]))\n      |             ^~~~~~~~\n/usr/bin/ld: /tmp/cc12hv8X.o: na função \"main\":\nmain.c:(.text+0x99): undefined reference to `eh_vogal'\ncollect2: error: ld returned 1 exit status\nHá dois problemas dignos de destaque no resultado da compilação. O primeiro se refere ao uso de eh_vogal, dando um alerta (warning) de declaração implícita, o que significa que a função não possui declaração e o compilador assumiu um formato padrão. O segundo ponto é o que diz “referência não definida para eh_vogal”, que significa que a função não foi implementada e não existe nenhum código para ela.\nO primeiro ponto a se resolver, portanto, é declarar a função antes de ela ser usada, o que é feito antes da função main. Essa nova versão do programa é a que segue.\n/*\nDeterminação da quantidade de vogais em um texto digitado pelo usuário\nRequer: um texto qualquer\nAssegura: apresentação do número de vogais contidas no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n\nbool eh_vogal(char caractere);\n\nint main(void) {\n    printf(\"Digite um texto: \");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n    texto[strlen(texto) - 1] = '\\0';\n\n    int numero_vogais = 0;\n    for (int i = 0; i &lt; (int)strlen(texto); i++)\n        if (eh_vogal(texto[i]))\n            numero_vogais++;\n\n    printf(\"\\\"%s\\\" possui %d %s.\\n\", texto, numero_vogais,\n           numero_vogais &gt; 1 ? \"vogais\" : \"vogal\");\n\n    return 0;\n}\n/usr/bin/ld: /tmp/ccTcvThP.o: na função \"main\":\nmain.c:(.text+0x94): undefined reference to `eh_vogal'\ncollect2: error: ld returned 1 exit status\nA declaração é feita por meio de seu protótipo, que indica o tipo, o nome e os parâmetros que a função possui. A prototipagem da função requereu também incluir stdbool.h para poder especificar o tipo de retorno bool.\nbool eh_vogal(char caractere);  // protótipo da função\nVale observar que a compilação do programa foi bem sucedida e todo o código objeto para ele foi criado com êxito. O problema que persiste é que, ao criar o executável, notou-se a ausência da implementação.\nEsse é o problema que a versão final do programa resolve.\n/*\nDeterminação da quantidade de vogais em um texto digitado pelo usuário\nRequer: um texto qualquer\nAssegura: apresentação do número de vogais contidas no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n\nbool eh_vogal(char caractere);\n\nint main(void) {\n    printf(\"Digite um texto: \");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n    texto[strlen(texto) - 1] = '\\0';\n\n    int numero_vogais = 0;\n    for (int i = 0; i &lt; (int)strlen(texto); i++)\n        if (eh_vogal(texto[i]))\n            numero_vogais++;\n\n    printf(\"\\\"%s\\\" possui %d %s.\\n\", texto, numero_vogais,\n           numero_vogais &gt; 1 ? \"vogais\" : \"vogal\");\n\n    return 0;\n}\n\n/*!\n * Verificação se um caractere é uma vogal (maiúscula ou minúscula).\n * @param caractere: caractere simples a ser verificado\n * @return true se for vogal, false caso contrário\n */\nbool eh_vogal(char caractere) {\n    bool se_eh_vogal =\n            (caractere == 'a' || caractere == 'e' || caractere == 'i' ||\n             caractere == 'o' || caractere == 'u' || caractere == 'A' ||\n             caractere == 'E' || caractere == 'I' || caractere == 'O' ||\n             caractere == 'U');\n\n    return se_eh_vogal;\n}\nDigite um texto: Comece pelo começo, disse a Rainha a Alice\n\"Comece pelo começo, disse a Rainha a Alice\" possui 18 vogais.\nA função declarada é lógica, retornando um valor bool, o nome escolhido para ela é eh_vogal e ela tem um único parâmetro que é um char denominado caractere.\nPara sua implementação, a função define uma variável booliana local se_eh_vogal que recebe true ou false conforme o resultado da comparação. O valor resultante da função é determinado pela instrução return que, nesse caso, volta o valor booliano. Sempre que return é executado, a função é encerrada e comandos escritos depois dele nunca serão executados.\nO uso da variável local se_eh_vogal é meramente didático pois estabelece dois passos: o cálculo do resultado da função e o retorno desse resultado. Na prática, é mais interessante escrever essa função conforme se segue, sem o uso da variável local e já retornando o valor da expressão.\n/*!\n * Verificação se um caractere é uma vogal (maiúscula ou minúscula).\n * @param caractere: (char) caractere a ser verificado\n * @return true se for vogal, false caso contrário\n */\nbool eh_vogal(char caractere) {\n    return (caractere == 'a' || caractere == 'e' || caractere == 'i' ||\n            caractere == 'o' || caractere == 'u' || caractere == 'A' ||\n            caractere == 'E' || caractere == 'I' || caractere == 'O' ||\n            caractere == 'U');\n}\nPara concluir esta seção é preciso rever dois pontos importantes:\n\nToda função tem que ser declarada antes de ser usada;\nA implementação da função (seu código) tem que ter sido escrito para que executável possa ser criado.\n\nAssim, para o exemplo do contador de vogais, a declaração foi feita na forma de um protótipo, o qual indica para o compilador o tipo de retorno e os parâmetros e respectivos tipos. Com essas informações, as devidas verificações de consistência podem ser realizadas durante a compilação, como verificar se o tipo do parâmetro passado é compatível com o tipo indicado na declaração. A implementação, por sua vez, foi inserida no código fonte logo abaixo de main, fornecendo condições para que eh_vogal possuísse sua implementação e viabilizasse o que se deseja: o executável completo.\n\n\n18.2.2 Onde declarar a função?\nHá duas estratégias usuais para declarar funções em C. A primeira é usando protótipos para a declaração e ter a implementação feita posterioriormente. Outra forma é pela inserção direta da implementação, a qual tanto implementa quanto declara a função ao mesmo tempo.\nA segunda forma é apresentada na sequência, como uma versão alternativa do mesmo programa de contagem de vogais.\n/*\nDeterminação da quantidade de vogais em um texto digitado pelo usuário\nRequer: um texto qualquer\nAssegura: apresentação do número de vogais contidas no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n\n/*!\n * Verificação se um caractere é uma vogal (maiúscula ou minúscula).\n * @param caractere: (char) caractere a ser verificado\n * @return true se for vogal, false caso contrário\n */\nbool eh_vogal(char caractere) {\n    return (caractere == 'a' || caractere == 'e' || caractere == 'i' ||\n            caractere == 'o' || caractere == 'u' || caractere == 'A' ||\n            caractere == 'E' || caractere == 'I' || caractere == 'O' ||\n            caractere == 'U');\n}\n\nint main(void) {\n    printf(\"Digite um texto: \");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n    texto[strlen(texto) - 1] = '\\0';\n\n    int numero_vogais = 0;\n    for (int i = 0; i &lt; (int)strlen(texto); i++)\n        if (eh_vogal(texto[i]))\n            numero_vogais++;\n\n    printf(\"\\\"%s\\\" possui %d %s.\\n\", texto, numero_vogais,\n           numero_vogais &gt; 1 ? \"vogais\" : \"vogal\");\n\n    return 0;\n}\nDigite um texto: Comece pelo começo, disse a Rainha a Alice\n\"Comece pelo começo, disse a Rainha a Alice\" possui 18 vogais.\nNão há uma regra para usar uma forma ou outra, sendo assim uma opção pessoal (exceto quando a empresa ou o cliente possuírem regras específicas).\n\nComo regra geral, este livro adota o uso das declarações de função com protótipos e cuja implementação fica posterior à função main quando estiverem no mesmo arquivo.\n\n\n\n\n\n\nCuriosidade\n\n\n\nÉ interessante notar que, embora a implementação da função eh_vogal tenha sido feita no mesmo arquivo em que estava a função main, ela poderia estar em outro arquivo.\nQuando programas se tornam maiores, é uma prática comum e muito positiva separar as implementações de funções em arquivos separados. Assim, se um programa deve lidar com o processamento de um texto, pode haver um arquivo para as funções que manipulam arquivos, outro para as que manipulam as cadeias de caracteres e assim por diante. Tudo se reflete em organização.\nEsse assunto é abordado no ?sec-organizacao-do-codigo-separado.\n\n\n\n\n18.2.3 Escopo da declaração das funções\nUma discussão prévia sobre declarações e escopo está apresentada na Seção 9.1, tratando da validade de cada variável em um programa. Com a introdução do assunto da modularização, o conceito de escopo se amplia. Qualquer variável usada nos diversos programas possuem sua validade definida internamente a main, ou seja, são locais à função principal e não existem fora dela.\nAo se criar uma nova função, ela é declarada fora da função main e não é, portanto, local. As declarações das funções são sempre globais. A consequência para esse tipo de declaração é que ela é válida da linha do protótipo (ou do cabeçalho de uma função implementada) até o fim do arquivo do código fonte.\nO programa seguinte é apenas um exemplo para o qual comentários pertinentes sobre escopo serão apresentados. Nenhuma função é comentada, visto que são apenas exemplos simples (documentação de funções está na Seção 18.2.5).\n/*\nPrograma exemplo com funções simples\n*/\n#include &lt;stdio.h&gt;\n\ndouble dobro(double valor);\n\ndouble maximo(double valor1, double valor2);\n\nint somatorio(int n);\n\ndouble um_double(void);\n\nint um_int(void);\n\nint main(void) {\n    printf(\"Quádruplo de 1.77 = %.2lf.\\n\", dobro(dobro(1.77)));\n    printf(\"max(1.2, 7.8) = %.1lf.\\n\", maximo(1.2, 7.8));\n    printf(\"Somatório de 1 até 100 = %d.\\n\", somatorio(100));\n    printf(\"Um: %d e %.1f.\\n\", um_int(), um_double());\n\n    return 0;\n}\n\ndouble dobro(double valor) {\n    double valor_dobrado = 2 * valor;\n\n    return valor_dobrado;\n}\n\ndouble maximo(double valor1, double valor2) {\n    return (valor1 &gt; valor2) ? valor1 : valor2;\n}\n\nint somatorio(int n) {\n    int soma = 0;\n    for (int i = 1; i &lt;= n; i++)\n        soma += i;\n\n    return soma;\n}\n\ndouble um_double(void) {\n    return (double)um_int();\n}\n\nint um_int(void) {\n    return 1;\n}\nQuádruplo de 1.77 = 7.08.\nmax(1.2, 7.8) = 7.8.\nSomatório de 1 até 100 = 5050.\nUm: 1 e 1.0.\nNo programa exemplificado há cinco funções definidas pelo programador: dobro, maximo, somatorio, um_int e um_double. Cada uma delas é declarada por seu respectivo protótipo e, em consequência, possuem validade da linha em que houve a declaração até o final do arquivo do código fonte. Como exemplos, a função dobro é conhecida e pode ser usada da linha 6 até a 49, enquanto somatorio tem validade a partir da linha 10 e também encerrando na linha 49.\nAssim, toda função pode ser usada a partir da linha de sua declaração. Quando se chega à função main, todas as funções já são conhecidas e seu uso é perfeitamente possível.\nUm destaque relevante vai para as funções um_double e um_int, que apenas retornam o valor unitário, um do tipo double, outro do tipo int. No exemplo, a função um_double retorna uma chamada para um_int, a qual já foi declarada por seu protótipo.\nSegue um exemplo para o caso em que as funções têm suas declarações sem prototipagem, ou seja, são declaradas e implementadas antes da função main. A regra de escopo aqui é a mesma e, a título de exemplo, maximo é declarado na linha 12 e pode ser usado desta linha até a 39.\n/*\nPrograma exemplo com funções simples\n*/\n#include &lt;stdio.h&gt;\n\ndouble dobro(double valor) {\n    double valor_dobrado = 2 * valor;\n\n    return valor_dobrado;\n}\n\ndouble maximo(double valor1, double valor2) {\n    return (valor1 &gt; valor2) ? valor1 : valor2;\n}\n\nint somatorio(int n) {\n    int soma = 0;\n    for (int i = 1; i &lt;= n; i++)\n        soma += i;\n\n    return soma;\n}\n\nint um_int(void) {\n    return 1;\n}\n\ndouble um_double(void) {\n    return (double)um_int();\n}\n\nint main(void) {\n    printf(\"Quádruplo de 1.77 = %.2lf.\\n\", dobro(dobro(1.77)));\n    printf(\"max(1.2, 7.8) = %.1lf.\\n\", maximo(1.2, 7.8));\n    printf(\"Somatório de 1 até 100 = %d.\\n\", somatorio(100));\n    printf(\"Um: %d e %.1f.\\n\", um_int(), um_double());\n\n    return 0;\n}\nQuádruplo de 1.77 = 7.08.\nmax(1.2, 7.8) = 7.8.\nSomatório de 1 até 100 = 5050.\nUm: 1 e 1.0.\nUma ressalva importante é feita à função um_double, a qual necessariamente tem que ser declarada depois de um_int, pois essa inversão implicaria no problema de uma função ser desconhecida antes de ser usada. Nesses casos ou a correta ordenação ou a inclusão de um protótipo são soluções válidas.\n\n\n\n\n\n\nCuidado\n\n\n\nA especificação da linguagem C não admite que funções sejam declaradas dentro de outras funções, o chamado aninhamento de declarações. Uma vantagem dessa estratégia é ter uma função que é reconhecida e usada apenas dentro de outra função.\nMuitos compiladores dão, porém, suporte a esse recurso e, assim, torna-se importante ressaltar que o código fonte pode não ser compatível com outros compiladores, outros sistemas ou mesmo com versões futuras.\nAderir aos recursos padronizados oficiais da linguagem é sempre uma boa opção de conduta.\n\n\n\n\n18.2.4 Funções com vários parâmetros\nNão é incomum que uma função precise de mais que um único parâmetro. Por exemplo, pode-se ter uma função que calcule o peso (massa) ideal de uma pessoa conforme seu sexo biológico e sua altura. Essa função poderia ser escrita com a declaração seguinte.\n/*!\n * Determina a massa ideal a partir do sexo biológico e da altura de um\n * indivíduo.\n * @param sexo: o sexo biológio ('F' para feminino, 'M' para masculino) \n * @param altura: a altura da pessoa em metros\n * @return a massa ideal em quilogramas\n */\ndouble massa_ideal(char sexo, double altura);\nQuando há mais que um parâmetro, eles são separados por vírgulas. Na sequência, são apresentadas declarações genéricas e suas interpretações.\ndouble funcao(int a, double b);  // a é int, b é double; retorna double\ndouble funcao(int a, int b);  // a e b são int; retorna double\nbool funcao(bool a, bool b, bool c);  // a, b e c são bool; retorna bool\nint funcao(char *a, char *b, int c, int d);  // a e b são strings; c e d são\n                                             // int; retorna int\n\n\n\n\n\n\nCuidado\n\n\n\nCada um dos parâmetros devem ter seu tipo especificado. Um exemplo interessante é uma função declarada como na sequência.\ndouble funcao(double a, b, c);\nNessa função, o parâmetro a é do tipo double. Porém b e c não possuem tipo e, em consequência, haverá um erro de compilação.\n\n\n\n\n18.2.5 Documentação\nNeste livro as funções são documentadas usando um padrão de formato aceito pelo Doxygen2, que é uma ferramenta para gerar documentação para grandes projetos. No caso dos programas e funções apresentados como exemplos ao longo do texto, o termo “grande projeto”, entretanto, não se aplica, nem tampouco é necessária uma ferramenta para gerar a documentação. Apesar disso, o formato escolhido para a documentação é simples e atende às necessidades.\nA documentação de uma função envolve:\n\nA descrição do que ela faz;\nA apresentação contextualizada dos parâmetros;\nO que a função retorna como resultado.\n\nComo exemplo, segue a declaração da função para o cálculo do fatorial de um valor inteiro.\n/*!\n * Retorna, para um dado n, o valor de n!\n * @param n: valor para o qual seu fatorial é calculado, n &gt;= 0\n * @return n!\n */\nunsigned long int fatorial(unsigned int n);\nNessa declaração, a descrição cobre o que a função faz: retorna o fatorial de um valor \\(n\\) indicado. na lista de parâmetros há um só, denominado n, além de indicar que a função atende corretamente apenas valores naturais. O retorno da função, por sua vez, é o que a função promete devolver, ou seja, \\(n!\\). Os tipos envolvidos tanto no parâmetro quanto para o retorno estão indicados no cabeçalho da função.\nQuando se escreve a documentação, é importante que esteja indicado o que função faz e não como ela o faz. Por exemplo, a descrição não deve conter algo como “por meio de multiplicações sucessivas”, pois isso já se refere ao como. A descrição pode ser curta ou longa, dependendo da necessidade, sempre com foco de indicar como outro programador poderá usar essa função corretamente. Para os parâmetros formais, ou seja, os que ficam entre os parênteses, todos devem ser elencados dentro do contexto da função (indicados com @param). Assim, para o fatorial de um \\({n \\in \\mathbb{N}}\\), o único parâmetro é o \\(n\\) a ser usado, sendo que n &gt;= 0 deixa claro para quais valores a função funciona corretamente[^ressalva-dominio-incorreto]. Para o retorno da função (@return), é indicado tão claramente quanto possível o que é resultado da função.\nA documentação de uma uma função é sempre um elemento importante. Entretanto, documentar absolutamente todas as funções pode ter um efeito inverso ao de proporcionar clareza a um dado código. Funções extremamente simples, que sejam praticamente autoexplicativas, podem ficar sem uma documentação explícita. O mesmo ocorre para funções que são apenas auxiliares para outras funções e não são destinadas para que outros programadores as usem. Nessa última categoria, é interessante ver que sscanf é uma função importante e, portanto, deva ter sua documentação bem estabelecida (o que é verdade, pois possui sua página de manual), mas é possível supor que ela chame outras funções menores para cada conversão de texto para um determinado tipo; essas funções não requerem, necessariamente, uma documentação, já que não foram feitas para serem usadas abertamente.\nNos exemplos dados ao longo deste texto, é possível que funções simples ou auxiliares deixem de ter documentação explícita.\nOs IDEs em geral reconhecem a documentação das funções e auxiliam o programador durante a codificação. Na Figura 18.1 há um exemplo de como a documentação é mostrada quando se posiciona o mouse sobre o nome da função eh_vogal. Outros auxílios, como verificações dos tipos dos parâmetros também são recursos comuns.\n\n\n\n\n\n\nFigura 18.1: Auxílio ao programador em IDEs quando as funções são devidamente documentadas. IDE: CLion.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Funções em C</span>"
    ]
  },
  {
    "objectID": "c-funcoes.html#criação-de-funções",
    "href": "c-funcoes.html#criação-de-funções",
    "title": "18  Funções em C",
    "section": "18.3 Criação de funções",
    "text": "18.3 Criação de funções\nQuando uma função é escrita em um programa, é importante que se tenha clareza do seu objetivo. A função deve, em consequência, ater-se somente a ele e não realizar outra tarefa qualquer. Por exemplo, se uma função é escrita para converter graus Celsius para Fahrenheit, é somente a conversão que deve ser feita; a função não deve ler nada nem escrever nada.\nSegue um exemplo dessa função.\n/*!\n * Retorna a temperatura em Fahenheit dado seu valor em graus Celsius\n * @param celsius: a temperatura Celsius\n * @return a temperatura em Fahrenheit\n */\ndouble celsius_para_fahrenheit(double celsius) {\n    return 1.8 * celsius + 32;\n}\nTodos os dados necessários devem ser passados como parâmetros e o resultado retornado pela função.\nNão se está dizendo aqui que função não podem nem ler nem escrever. Se uma função tenha como objetivo ler um valor digitado pelo usuário, é isso que ela tem que fazer. O programa exemplo seguinte inclui uma função de interface para ler um valor inteiro digitado pelo usuário, verificando erros e garantindo que um valor válido seja entrado.\n/*\nLeitura da idade de uma pessoa e escrita desse valor na tela\nRequer: digitação de uma idade\nAssegura: apresentação da idade na tela\n*/\n#include &lt;stdio.h&gt;\n\nint leia_inteiro(char *mensagem);\n\nint main(void) {\n    int idade = leia_inteiro(\"Digite sua idade: \");\n    printf(\"Você tem %d anos de idade.\\n\", idade);\n\n    return 0;\n}\n\n/*!\n * Retorna um valor inteiro válido digitado pelo usuário.\n * A leitura é repetida caso o valor digitado não corresponda a\n * um inteiro válido, sendo uma mensagem de aviso apresentada. Qualquer\n * texto depois do inteiro é descartado.\n * @param mensagem: mensagem solicitando a leitura\n * @return um valor inteiro lido\n */\nint leia_inteiro(char *mensagem) {\n    printf(\"%s\", mensagem);\n    int valor_lido, quantidade_itens_lidos;\n    do {\n        char entrada[160];\n        fgets(entrada, sizeof entrada, stdin);\n        quantidade_itens_lidos = sscanf(entrada, \"%d\", &valor_lido);\n        if (quantidade_itens_lidos != 1)\n            printf(\"&gt; Valor inválido. Esperado um inteiro.\\n\"\n                   \"%s\", mensagem);\n    } while (quantidade_itens_lidos != 1);\n\n    return valor_lido;\n}\nDigite sua idade: abc\n&gt; Valor inválido. Esperado um inteiro.\nDigite sua idade: *\n&gt; Valor inválido. Esperado um inteiro.\nDigite sua idade: #10\n&gt; Valor inválido. Esperado um inteiro.\nDigite sua idade: 25\nVocê tem 25 anos de idade.\nHá que se notar que a função deve ler e retornar um valor inteiro e digitações erradas são detectadas e contornadas. Para ser uma função genérica, ela lê inteiros e não idades (tanto que valores negativos seriam aceitos nesse caso). Essa função pode ser usada em qualquer outro programa para a leitura de um inteiro e ela não atende exclusivamente o problema do programa em questão.\nCaso fosse interessante garantir que o valor fosse maior que zero, outra função poderia ser escrita para ler valores apenas em \\(\\mathbb{N}\\). Segue um exemplo de implementação de uma função que atende a esses requisitos, a qual aproveita a já escrita leia_inteiro, apenas repassando a mensagem para o usuário. No programa anterior, bastaria main executar leia_natural no lugar de leia_inteiro.\n/*!\n * Retorna um valor inteiro natural digitado pelo usuário.\n * A leitura é repetida para valores inválidos e o restante da linha\n * depois do inteiro é ignorado\n * @param mensagem: mensagem solicitando a leitura\n * @return valor inteiro lido, maior ou igual a zero\n */\nint leia_natural(char *mensagem) {\n    int valor_lido;\n    do {\n        valor_lido = leia_inteiro(mensagem);\n        if (valor_lido &lt; 0)\n            printf(\"Valor inválido. Esperado maior ou igual a zero.\\n\");\n    } while (valor_lido &lt; 0);\n    return valor_lido;\n}",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Funções em C</span>"
    ]
  },
  {
    "objectID": "c-funcoes.html#escolha-dos-tipos-de-retorno-e-dos-parâmetros",
    "href": "c-funcoes.html#escolha-dos-tipos-de-retorno-e-dos-parâmetros",
    "title": "18  Funções em C",
    "section": "18.4 Escolha dos tipos de retorno e dos parâmetros",
    "text": "18.4 Escolha dos tipos de retorno e dos parâmetros\nOs tipos dos parâmetros devem satisfazer as necessidades das funções. Por exemplo, na conversão de graus Celsius para Fahrenheit é esperado que a temperatura em Celsius seja double, assim como o valor retornado em Fahrenheit.\ndouble celsius_para_fahrenheit(double celsius);\nPara uma função do cálculo do fatorial de um número, entretanto, as escolhas podem não ser tão elementares. Uma primeira tentativa seria, por exemplo, ter a função com o seguinte protótipo.\nint fatorial(int n);\nUm primeiro ponto é que, nos sistemas atuais, um int ocupa geralmente quatro bytes e permite valores de -2.147.483.648 a 2.147.483.647. Metade dos valores representados são negativos e o resultado do fatorial nunca será negativo. Assim, pode-se optar pela prototipagem seguinte.\nunsigned int fatorial(int n);\nNessa nova versão, ainda considerando os tamanhos típicos para inteiros, os valores de retorno podem ser de zero a 4.294.967.295. Esse intervalo comportaria valores até 12\\(!\\) (479.001.600), pois 13\\(!\\) (6.227.020.800) já extrapolaria.\nA versão seguinte expande o tipo de retorno para unsigned long int, o qual usa oito bytes na versão do gcc usada nos programas. Desse modo, a gama de possíveis resultados vai para 18.446.744.073.709.551.615, o que comportaria até 20\\(!\\)3.\nunsigned long int fatorial(int n);\nO mesmo raciocínio se aplicaria ao parâmetro n. Para \\(n!\\), sempre se tem \\(n \\geq 0\\), e, assim, a função poderia ter como protótipo final o formato que segue.\nunsigned long int fatorial(unsigned int n);\nSua implementação seria como se segue.\n/*!\n * Retorna, para um dado n, o valor de n!\n * @param n: valor para o qual seu fatorial é calculado, n &gt;= 0\n * @return n!\n */\nunsigned long int fatorial(unsigned int n) {\n    unsigned long int multiplicador = 1;\n    for (unsigned int i = 2; i &lt;= n; i++)\n        multiplicador *= i;\n\n    return multiplicador;\n}\nA vantagem na escolha dos tipos é que, até certo limite, o compilador consegue verificar consistência nos valores passados para a função. Por exemplo, se houver uma variável i do tipo int (que possui valores negativos), o compilador pode avisar (não é erro) que pode haver algum problema. A mensagem de compilação seguinte mostra que pode haver um problema de conversão caso os valores sejam negativos e o resultado, portanto, pode não ser confiável.\nmain.c:18:31: warning: conversion to ‘unsigned int’ from ‘int’ may change\nthe sign of the result [-Wsign-conversion]\n   18 |     printf(\"%lu.\\n\", fatorial(i));\n      |                               ^\nA boa escolha dos tipos sempre proporciona uma camada adicional de controle na escrita de programas.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Funções em C</span>"
    ]
  },
  {
    "objectID": "c-funcoes.html#footnotes",
    "href": "c-funcoes.html#footnotes",
    "title": "18  Funções em C",
    "section": "",
    "text": "As funções, tanto matemáticas quanto computacionais, podem ter mais que um argumento (funções de múltiplas variáveis).↩︎\nDoxygen: https://www.doxygen.nl.↩︎\nEmbora 20\\(!\\) não pareça muito, vale lembrar seu valor é 2.432.902.008.176.640.000, ou seja, aproximadamente 2,4 \\(\\times\\) 1018.↩︎",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Funções em C</span>"
    ]
  },
  {
    "objectID": "c-regras-de-escopo-com-modularizacao.html",
    "href": "c-regras-de-escopo-com-modularizacao.html",
    "title": "19  Regras de escopo com a modularização",
    "section": "",
    "text": "19.1 Local \\(\\times\\) global\nEste capítulo estende os conceitos de escopo de validade das declarações na linguagem C. A Seção 9.1 abordou as declarações de variáveis internas (locais) a main, enquanto na Seção 18.2.3. Esses assuntos são revisitados e integrados.\nAlém de variáveis e funções, há outros elementos em C que podem ser declarados. Esses não serão cobertos diretamente neste texto e, em grande parte, a discussão exposta aqui também se aplica a eles.\nUm código fonte escrito em C contém declarações, sejam de funções ou de variáveis. Esse código fonte está contido em um arquivo texto, usualmente com extensão .c.\nQualquer função declarada no arquivo tem escopo global, o que quer dizer que sua validade vai desde a linha em que ocorre a declaração até a última linha do arquivo. Em outras palavras, essa função é conhecida e pode ser usada dentro de seu escopo de declaração. Essa regra aplica-se tanto à declaração simples, na forma de protótipo de função, quanto às implementações sem o protótipo (Seção 18.2.3).\nOutra forma de olhar para essa questão é considerar global qualquer declaração feita fora de uma função.\nComo existe o conceito de “fora de uma função”, também há o de “dentro de uma função”. Assim, variáveis declaradas no corpo da implementação de uma função estão dentro da função e são chamadas de declarações locais. O termo se aplica também aos parâmetros formais da função.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regras de escopo com a modularização</span>"
    ]
  },
  {
    "objectID": "c-regras-de-escopo-com-modularizacao.html#local-times-global",
    "href": "c-regras-de-escopo-com-modularizacao.html#local-times-global",
    "title": "19  Regras de escopo com a modularização",
    "section": "",
    "text": "19.1.1 Validade das declarações globais e locais\nPara exemplificar tanto declarações globais quanto locais quanto suas validades, segue um programa para simplificação de números racionais, o qual emprega uma função para o cálculo do máximo divisor comum (MDC) entre dois números inteiros e outra para o cálculo do valor absoluto (módulo, \\(\\lvert n\\rvert\\)) de um inteiro. O objetivo do programa é simplificar um número racional, lembrando que \\(q \\in \\mathbb{Q}\\) é um valor expresso na forma \\(a/b\\), sendo \\(a \\in \\mathbb{Z}\\) com \\(b \\in \\mathbb{Z}^*\\).\nA lógica de modificação do número racional é apresentada no Algoritmo 19.1.\n\n\nAlgoritmo 19.1: Leitura e apresentação de números racionais.\n\n\n\nA codificação em C é apresentada na sequência.\n/*\n * Leitura e escrita de um número racional na forma de fração\n * Requer: a digitação de um valor a/b, a,b inteiros, b != 0\n * Assegura: apresentação do mesmo valor em forma simplificada e padronizada\n */\n#include &lt;stdio.h&gt;\n\n/*!\n * Retorna o MDC de dois inteiros quaisquer (máximo divisor comum).\n * @param n1: primeiro valor\n * @param n2: segundo valor\n * @return MDC(n1, n2)\n */\nunsigned int mdc(int n1, int n2);\n\n/*!\n * Retorna o valor absoluto de um inteiro\n * @param n: valor inteiro\n * @return o valor absoluto do número, |n|\n */\nint valor_absoluto(int n);\n\n/*\n * Main\n */\nint main() {\n    // Leitura\n    printf(\"Digite um número racional a/b (a e b inteiros e b não nulo): \");\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    int numerador, denominador;\n    sscanf(entrada, \"%d/%d\", &numerador, &denominador);\n\n    // Simplificação da fração e colocação do sinal no numerador\n    if (numerador == 0)\n        denominador = 1;  // o valor zero é padronizado para 0/1\n    else {\n        int fator_divisao = mdc(numerador, denominador);\n        int sinal_da_fracao = ((double)numerador / denominador &gt;= 0) ? 1 : -1;\n        numerador = valor_absoluto(numerador);\n        denominador = valor_absoluto(denominador);\n        numerador /= sinal_da_fracao * fator_divisao;\n        denominador /= fator_divisao;\n    }\n\n    // Resultado\n    printf(\"O racional digitado foi: %d/%d.\\n\", numerador, denominador);\n\n    return 0;\n}\n\n// Máximo divisor comum: MDC(n1, n2)\nunsigned int mdc(int n1, int n2) {\n    // Converte n1 e n2 para valores positivos\n    n1 = valor_absoluto(n1);\n    n2 = valor_absoluto(n2);\n\n    // Resolução pelo método de Euclides\n    int resto;\n    do {\n        resto = n1 % n2;\n        n1 = n2;\n        n2 = resto;\n    } while (resto != 0);\n\n    return n1;  // Contém o MDC no final\n}\n\n// Valor absoluto de um inteiro\nint valor_absoluto(int n) {\n    return (n &gt;= 0) ? n : -n;\n}\nDigite um número racional a/b (a e b inteiros e b não nulo): -3553/-627\nO racional digitado foi: 17/3.\nPara esse programa, há declarações tanto de variáveis quanto de funções. A Tabela 19.1 apresenta as declarações de interesse no programa e destaca o escopo e validade (linhas do código) de cada uma.\n\n\n\nTabela 19.1: Declarações relevantes feitas no programa de apresentação de números racionais, seu tipo, escopo e linhas em que são válidas.\n\n\n\n\n\n\n\n\n\n\n\n\nDeclaração\nTipo\nEscopo\nInício\nFim\n\n\n\n\nmdc\nfunção\nglobal\n14\n68\n\n\nvalor_absoluto\nfunção\nglobal\n21\n68\n\n\nentrada\nvariável\nlocal (main)\n29\n46\n\n\nnumerador, denominador\nvariável\nlocal (main)\n31\n46\n\n\nfator_divisao\nvariável\nlocal (main)\n35\n46\n\n\nsinal_da_fracao\nvariável\nlocal (main)\n36\n46\n\n\nn1, n2\nparâmetro\nlocal (mdc)\n49\n63\n\n\nresto\nvariável\nlocal (mdc)\n55\n63\n\n\nn\nparâmetro\nlocal (valor_absoluto)\n66\n68\n\n\n\n\n\n\n\n\n\n\n\n\nCuriosidade\n\n\n\nÉ interessante apontar que n1 e n2 na linha 14, assim como n na linha 21 do programa apresentado não possuem validade, pois o protótipo de uma função é apenas sua declaração e, como tal, seus parâmetros não são realmente criados, mas apenas informados ao compilador.\nNa prática, a linha 14 do código do programa poderia ser escrita como segue, mas com o prejuízo de reduzir as informações de documentação do programa ao não informar semanticamente a que cada parâmetro se refere.\nunsigned int mdc(int, int);  // o nome dos parâmetros é irrelevante, mas sua\n                             // omissão prejudica a documentação e legibilidade",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regras de escopo com a modularização</span>"
    ]
  },
  {
    "objectID": "c-regras-de-escopo-com-modularizacao.html#reuso-de-identificadores",
    "href": "c-regras-de-escopo-com-modularizacao.html#reuso-de-identificadores",
    "title": "19  Regras de escopo com a modularização",
    "section": "19.2 Reuso de identificadores",
    "text": "19.2 Reuso de identificadores\nNos programa em C é possível usar um mesmo identificador desde que eles suas declarações atendam escopos diferentes. Dessa forma, um identificador p pode ser parâmetro para diversas funções diferentes. Da mesma forma, uma variável local a uma função não conflita com qualquer outra declaração. O compilador reclamará, assim, apenas de duas declarações globais com mesmo identificador ou então o uso de um mesmo nome em duplicidade no mesmo contexto local.\nA seguir é apresentado um código fonte genérico, não realiza qualquer processamento útil, O objetivo é indicar como identificadores iguais são tratados.\n/*\n * Programa exemplo de declarações\n */\n#include &lt;stdio.h&gt;\n\nint f1(int a, int b);\n\ndouble f2(double a);\n\nint f3(double f1, double f2);\n\nint main(void) {\n    int a, b, c;\n    double d = 1.25;\n\n    a = (int)f2(d);\n    b = f3(d, 0.5 * a);\n    c = f1(a, b);\n\n    printf(\"%d %d %d %g\\n\", a, b, c, d);\n\n    return 0;\n}\n\nint f1(int a, int b) {\n    int n = f3(a, b);\n    return a + b + n;\n}\n\ndouble f2(double a) {\n    int n = 1;\n    double b = f1(a, n);\n    return b;\n}\n\nint f3(double f1, double f2) {\n    int main = (int)f1 + (int)f2;\n    return main;\n}\n4 3 14 1.25\nOs pontos que requerem atenção neste programa são os seguintes:\n\nAs funções f1, f2 e f3 têm validade em praticamente todo o programa;\nAmbas as funções f1 e f2 possuem parâmetro com identificador a, mas eles são independentes pois estão em escopos diferentes;\nA função principal main também possui variáveis locais a e b, também disjuntas dos parâmetros e outras declarações locais;\nTanto f1 quanto f2 possuem variáveis locais chamadas n, sendo elas completamente separadas dado seu escopo local diferente;\nA função f1 chama f3, que é conhecida dado o escopo global, sendo que o mesmo ocorre com a chamada de f1 em f2;\nf3 possui parâmetros f1 e f2, cujos nomes se sobrepõem às funções globais f1 e f2, significando que, dentro de f3, essas funções não estão acessíveis pois são obscurecidas pelas declarações locais;\nf3 possui uma variável local main, que não conflita com a função global com mesmo nome.\n\nDessa forma, seguem algumas orientações gerais de escopo:\n\nDeclarações globais valem em todo o código fonte a partir de sua declaração;\nParâmetros e declarações em funções são locais, têm apenas validade no escopo da função e são independentes de qualquer outra declaração com mesmo nome em escopo maior;\nDeclarações locais podem se sobrepor e ocultar declarações globais;\nBlocos de comandos podem ter declarações cujo escopo é o próprio bloco apenas (Seção 9.1).",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regras de escopo com a modularização</span>"
    ]
  },
  {
    "objectID": "c-regras-de-escopo-com-modularizacao.html#variáveis-globais",
    "href": "c-regras-de-escopo-com-modularizacao.html#variáveis-globais",
    "title": "19  Regras de escopo com a modularização",
    "section": "19.3 Variáveis globais",
    "text": "19.3 Variáveis globais\nAssim como funções, também variáveis podem ser globais. Uma variável declarada fora do escopo de qualquer função é uma variável global e, como tal, tem sua validade definida e conhecida desde a linha em que é declarada até o final do arquivo.\nVariáveis declaradas como globais possuem duas diferenças importantes em relação às locais, sejam variáveis ou parâmetros de funções:\n\nLocal e momento de criação;\nIniciação automática.\n\nA primeira diferença, portanto, é que as variáveis globais são criadas juntamente com a execução do programa e possuem um espaço de memória específico para elas. As variáveis locais e os parâmetros são criados apenas no momento em que a função é chamada e, dependendo de quando isso ocorre, podem ser criadas em diferentes locais da memória dependendo da chamada.\nVariáveis globais são consideradas estáticas enquanto as locais são criadas dinamicamente em função do momento em que as funções são chamadas\nO segundo ponto é que as variáveis locais nunca possuem lixo, ou seja, são sempre iniciadas com valores nulos. Assim, se uma variável global int i é criada sem atribuição, seu valor será necessariamente zero. Caso exista um double d global, o valor de d será 0,0, exceto se houver outro valor inicial. De forma similar, se uma cadeia de caracteres for criada em escopo global com char s[100], ela terá comprimento zero, pois todas suas posições terão \\0.\n\n19.3.1 Declaração de variáveis globais\nPara que uma variável seja global, basta que sua declaração seja feita fora de uma função. Segue um exemplo simples em que foi criado um contador global para monitorar o número de vezes que uma\n/*\n * Programa exemplo com variável global\n * O código cria duas funções, volta_igual e volta_negativo, mantendo\n *      controle sobre o número de vezes que elas são chamadas\n * Assegura: apresentações diversas do uso da função e do número de vezes\n *      em que foram chamadas\n */\n#include &lt;stdio.h&gt;\n\n//! Contador para uso global\nint numero_chamadas;\n\n/*!\n * Retorna igual ao que foi passado\n * @param n\n * @return n\n */\nint volta_igual(int n);\n\n/*!\n * Retorna o oposto do que foi passado\n * @param n\n * @return -n\n */\nint volta_negativo(int n);\n\n/*\n * Main\n */\nint main(void) {\n    printf(\"%d = %d.\\n\", 10, volta_igual(10));\n    printf(\"%d = -1 * %d.\\n\\n\", -10, volta_negativo(-10));\n    for (int n = -5; n &lt;= 5; n++)\n        printf(\"%d = %d = -1 * %d.\\n\", n, volta_igual(n), volta_negativo(n));\n\n    printf(\"\\nAs funções volta_igual e volta_negativo foram chamadas %d \"\n           \"vezes no total.\\n\", numero_chamadas);\n    return 0;\n}\n\n// Retorna igual\nint volta_igual(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return n;\n}\n\n// Retorna negativo\nint volta_negativo(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return -n;\n}\n10 = 10.\n-10 = -1 * 10.\n\n-5 = -5 = -1 * 5.\n-4 = -4 = -1 * 4.\n-3 = -3 = -1 * 3.\n-2 = -2 = -1 * 2.\n-1 = -1 = -1 * 1.\n0 = 0 = -1 * 0.\n1 = 1 = -1 * -1.\n2 = 2 = -1 * -2.\n3 = 3 = -1 * -3.\n4 = 4 = -1 * -4.\n5 = 5 = -1 * -5.\n\nAs funções volta_igual e volta_negativo foram chamadas 24 vezes no total.\nA variável numero_chamadas é global e seu escopo de validade se inicia na linha de declaração, de forma que ela pode ser usada em todas as funções seguintes, incluindo main. Como ela é global e não há iniciação explícita, seu valor inicial é zero. Cada vez que as funções volta_igual e volta_negativo são chamadas, essa variável é incrementada.\n\n\n19.3.2 Quando usar variáveis globais?\nA resposta rápida e curta para a pergunta do título da seção é simples: nunca. Claro que “nunca” é um exagero, pois há exceções. O ponto é sempre que qualquer variável global deve ser evitada, pois pode induzir a erros no código extremamente difíceis de serem localizados.\nO exemplo do contador de chamadas pode, talvez, ser caracterizado como uma exceção. O programa é pequeno e o uso da variável global para o contador oculta a contagem separando-a do uso da função. Se outro programador fizer modificações no programa, ele poderia até ignorar a contagem e usar as duas funções definidas sem problemas.\nO problema do uso de variáveis locais, entretanto, é exatamente alguém fazer uma modificação no programa e, por um descuido simples, interferir inadvertidamente no valor de uma variável que ele nem sabia que existia.\nPara exemplificar, suponha que seja solicitado a outro programador uma pequena modificação na função main: a inclusão de uma série de exemplos de chamadas à função volta_negativo antes dos exemplos já existentes. O programa seguinte mostra a solução feita rapidamente pelo novo programador.\n/*\n * Programa exemplo com variável global\n * O código cria duas funções, volta_igual e volta_negativo, mantendo\n *      controle sobre o número de vezes que elas são chamadas\n * Assegura: apresentações diversas do uso da função e do número de vezes\n *      em que foram chamadas\n */\n#include &lt;stdio.h&gt;\n\n//! Contador para uso global\nint numero_chamadas;\n\n/*!\n * Retorna igual ao que foi passado\n * @param n\n * @return n\n */\nint volta_igual(int n);\n\n/*!\n * Retorna o oposto do que foi passado\n * @param n\n * @return -n\n */\nint volta_negativo(int n);\n\n/*\n * Main\n */\nint main(void) {\n    // Exemplos novos para volta_negativo\n    int numero_chamadas;\n    for (numero_chamadas = 10; numero_chamadas &gt;= 0; numero_chamadas--)\n        printf(\"&gt; volta_negativo(%d) = %d.\\n\", numero_chamadas,\n               volta_negativo(numero_chamadas));\n\n    // Código com os exemplos orginais\n    printf(\"%d = %d.\\n\", 10, volta_igual(10));\n    printf(\"%d = -1 * %d.\\n\\n\", -10, volta_negativo(-10));\n    for (int n = -5; n &lt;= 5; n++)\n        printf(\"%d = %d = -1 * %d.\\n\", n, volta_igual(n), volta_negativo(n));\n\n    printf(\"\\nAs funções volta_igual e volta_negativo foram chamadas %d \"\n           \"vezes no total.\\n\", numero_chamadas);\n    return 0;\n}\n\n// Retorna igual\nint volta_igual(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return n;\n}\n\n// Retorna negativo\nint volta_negativo(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return -n;\n}\n&gt; volta_negativo(10) = -10.\n&gt; volta_negativo(9) = -9.\n&gt; volta_negativo(8) = -8.\n&gt; volta_negativo(7) = -7.\n&gt; volta_negativo(6) = -6.\n&gt; volta_negativo(5) = -5.\n&gt; volta_negativo(4) = -4.\n&gt; volta_negativo(3) = -3.\n&gt; volta_negativo(2) = -2.\n&gt; volta_negativo(1) = -1.\n&gt; volta_negativo(0) = 0.\n10 = 10.\n-10 = -1 * 10.\n\n-5 = -5 = -1 * 5.\n-4 = -4 = -1 * 4.\n-3 = -3 = -1 * 3.\n-2 = -2 = -1 * 2.\n-1 = -1 = -1 * 1.\n0 = 0 = -1 * 0.\n1 = 1 = -1 * -1.\n2 = 2 = -1 * -2.\n3 = 3 = -1 * -3.\n4 = 4 = -1 * -4.\n5 = 5 = -1 * -5.\n\nAs funções volta_igual e volta_negativo foram chamadas -1 vezes no total.\nO programa foi compilado com sucesso, sem erros e sem avisos. Porém o resultado agora está incorreto. Uma vez criada a variável local numero_chamadas, ela se sobrepõe à global. No último printf, o valor mostrado para a contagem é o da nova variável local e não mais o do contador global, produzindo um resultado inconsistente, provavelmente de fácil detecção, já que o novo resultado é incongruente.\nUm erro mais sutil poderia ser introduzido, gerando uma situação em que o programa afirma que 11 = -10.\n/*\n * Programa exemplo com variável global\n * O código cria duas funções, volta_igual e volta_negativo, mantendo\n *      controle sobre o número de vezes que elas são chamadas\n * Assegura: apresentações diversas do uso da função e do número de vezes\n *      em que foram chamadas\n */\n#include &lt;stdio.h&gt;\n\n//! Contador para uso global\nint numero_chamadas;\n\n/*!\n * Retorna igual ao que foi passado\n * @param n\n * @return n\n */\nint volta_igual(int n);\n\n/*!\n * Retorna o oposto do que foi passado\n * @param n\n * @return -n\n */\nint volta_negativo(int n);\n\n/*\n * Main\n */\nint main(void) {\n    // Exemplo adicional \n    numero_chamadas = 10;\n    printf(\"&gt; volta_negativo(%d) = %d.\\n\", numero_chamadas,\n           volta_negativo(numero_chamadas));\n\n    // Código com os exemplos originais\n    printf(\"%d = %d.\\n\", 10, volta_igual(10));\n    printf(\"%d = -1 * %d.\\n\\n\", -10, volta_negativo(-10));\n    for (int n = -5; n &lt;= 5; n++)\n        printf(\"%d = %d = -1 * %d.\\n\", n, volta_igual(n), volta_negativo(n));\n\n    printf(\"\\nAs funções volta_igual e volta_negativo foram chamadas %d \"\n           \"vezes no total.\\n\", numero_chamadas);\n    return 0;\n}\n\n// Retorna igual\nint volta_igual(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return n;\n}\n\n// Retorna negativo\nint volta_negativo(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return -n;\n}\n&gt; volta_negativo(11) = -10.\n10 = 10.\n-10 = -1 * 10.\n\n-5 = -5 = -1 * 5.\n-4 = -4 = -1 * 4.\n-3 = -3 = -1 * 3.\n-2 = -2 = -1 * 2.\n-1 = -1 = -1 * 1.\n0 = 0 = -1 * 0.\n1 = 1 = -1 * -1.\n2 = 2 = -1 * -2.\n3 = 3 = -1 * -3.\n4 = 4 = -1 * -4.\n5 = 5 = -1 * -5.\n\nAs funções volta_igual e volta_negativo foram chamadas 35 vezes no total.\nEm programas mais longos, mais complexos e com muitas funções, diagnosticar problemas com variáveis globais pode ser uma tarefa árdua e desmotivante.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regras de escopo com a modularização</span>"
    ]
  },
  {
    "objectID": "c-enderecamento-de-memoria-e-ponteiros.html",
    "href": "c-enderecamento-de-memoria-e-ponteiros.html",
    "title": "20  Endereçamento de memória e ponteiros nos programas",
    "section": "",
    "text": "20.1 Endereçamento de memória\nEste capítulo aborda alguns detalhes sobre como os diversos elementos se relacionam à memória do dispositivo onde um programa é executado. Esse tema pode parecer desconexo do conteúdo de todos os capítulos anteriores, mas os conceitos descritos aqui são muito importantes para capítulos seguintes. Para capítulos anteriores este material complementa informações já apresentadas de forma mais superficial. Nos capítulos seguintes este conteúdo será relevante, pois são tratados mecanismos para modificar, dentro de funções, variáveis declaradas em outros escopos (Capítulo 21, Seção 22.2) e também meios para requerer dinamicamente espaços para armazenamento de dados (?sec-alocacao-dinamica-de-memoria).\nNesta parte do texto apenas os conceitos de armazenamento e uso da memória são abordados. As aplicações desses recursos para resolver problemas práticos da linguagem são abordados em outros lugares.\nQuando uma variável é declarada, um espaço na memória é reservado para guardar seu valor. Por exemplo, ao se criar uma variável i do tipo int, alguns bytes da memória precisam ser reservados para guardar o valor da variável.\nAo se fazer uma atribuição, como i = 10, os bytes da variável i são modificados para representar o valor inteiro 10. Se uma chamada printf(\"%d\", i) é feita, os bytes da memória reservados para i são consultados e convertidos para um texto (valor decimal, %d) e apresentado na tela.\nAté este momento, os bytes reservados para a variável i foram irrelevantes. O compilador, apenas tendo o nome da variável (identificador i), sabe onde e quantos são os bytes usados e como os valores devem ser representados. Para usar a memória para os dados, basta usar seu identificador e todo o resto é gerenciado automaticamente. E isso é ótimo para o programador, tanto que essa necessidade pelos detalhes nunca apareceu.\nPara ilustrar esses detalhes ocultos, segue um programa que apresenta mais informações sobre as variáveis do programa.\nNão há novidades na atribuição de valores tanto à variável i quanto d, nem na apresentação de seus valores com o printf. O que este programa introduz é o operador &, o qual significa “endereço de”. Assim, &i é o endereço de memória da variável i, da mesma forma que &d corresponde ao endereço de d. O modificador de tipo (cast) (void *) serve apenas para indicar que o endereço é genérico e desprovido de tipo. Ao longo do texto esse assunto voltará a ser tratado. O operador sizeof também já foi utilizado e indica quantos bytes cada variável usa.\nQuando um programa é colocado em execução, o sistema operacional cria um processo e compartilha com o programa o uso do processador e também uma porção da memória principal. A memória do programa vista por ele como um bloco contínuo de bytes, cada com seu endereço. É usual que endereços de memória sejam apresentados em valores hexadecimais (formato %p do printf).\nPor exemplo, 7FFE51267D3C16 (endereço de i no programa) corresponde ao valor decimal 140.730.259.897.660, mas esse valor, por si só, não é relevante. Dado que a variável está no endereço 7FFE51267D3C16 e possui quatro bytes, os endereços 7FFE51267D3C16, 7FFE51267D3D16, 7FFE51267D3E16 e 7FFE51267D3F16 são usados pela variável. Um raciocínio similar se aplica aos oito bytes da variável d.\nPara os objetivos desta seção, é apenas relevante saber, que cada variável está em algum lugar e que o compilador sabe seu endereço. Desse modo, atribuições triviais como d = -17.2 podem ser feitas, pois o compilador sabe o tipo (double), a quantidade de bytes que serão usados (sizeof d) e quais são esses bytes (os oito bytes começando em 7FFE51267D3016).",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Endereçamento de memória e ponteiros nos programas</span>"
    ]
  },
  {
    "objectID": "c-enderecamento-de-memoria-e-ponteiros.html#endereçamento-de-memória",
    "href": "c-enderecamento-de-memoria-e-ponteiros.html#endereçamento-de-memória",
    "title": "20  Endereçamento de memória e ponteiros nos programas",
    "section": "",
    "text": "int i;  // criação de uma variável inteira\n\ni = 10;  // os bytes de i são modificados para representar o valor inteiro 10\nprintf(\"%d\", i);  // os bytes de i são consultados e convertidos para \"10\"\n\n\n/*\n * Apresentação simples de endereços de memória\n * Assegura: apresentação do valor de variáveis e suas localizações na\n *  memória de execução do programa\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 100;\n    printf(\"i = %d e está no endereço %p e tem %zu bytes.\\n\", i, (void *)&i,\n           sizeof i);\n\n    double d = -17.2;\n    printf(\"d = %g e está no endereço %p e tem %zu bytes.\\n\", d, (void *)&d,\n           sizeof d);\n\n    return 0;\n}\ni = 100 e está no endereço 0x7ffe51267d3c e tem 4 bytes.\nd = -17.2 e está no endereço 0x7ffe51267d30 e tem 8 bytes.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Endereçamento de memória e ponteiros nos programas</span>"
    ]
  },
  {
    "objectID": "c-enderecamento-de-memoria-e-ponteiros.html#armazenamento-de-endereços",
    "href": "c-enderecamento-de-memoria-e-ponteiros.html#armazenamento-de-endereços",
    "title": "20  Endereçamento de memória e ponteiros nos programas",
    "section": "20.2 Armazenamento de endereços",
    "text": "20.2 Armazenamento de endereços\nEndereços de memória podem ser guardados em variáveis, as quais recebem genericamente o nome de ponteiros. Quando um ponteiro guarda um endereço, diz-se que ele guarda uma referência àquele endereço e, portanto, ao seu conteúdo.\n/*\n * Armazenamento de endereços de memória\n * Assegura: apresentação do endereço de uma variável\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double d = 1.125;\n    double *endereco_de_d = &d;\n    \n    printf(\"A variável d usa %zu bytes começando em %p.\\n\", sizeof d,\n           (void *)endereco_de_d);\n\n    return 0;\n}\nA variável d usa 8 bytes começando em 0x7ffd826eb9c8.\nEste programa cria uma variável chamada endereco_de_d, à qual é atribuído o valor &d (que é o endereço de d). O tipo de uma variável que guarda endereços deve ser sempre um ponteiro e sua declaração usa o * para indicar isso.\ndouble *endereco_de_d;  // variável que guarda um endereço\nEntrando em mais detalhes, a variável é declarada com o tipo double * e isso significa que a variável guarda o endereço de algo que ela sabe que é um double. Na prática, uma declaração de ponteiro como a usada significa que o valor armazenado será o endereço primeiro dos oito bytes que estão guardando um valor do tipo double.\nOs ponteiros são criados com tipos associados à referência que vão armazenar e, assim, o compilador têm o controle do que é apontado. Seguem alguns exemplos adicionais de declarações.\nint *pi;  // endereço de um inteiro\nchar *pc;  // endereço de um char\nunsigned long int *puli;  // endereço de um unsigned long int",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Endereçamento de memória e ponteiros nos programas</span>"
    ]
  },
  {
    "objectID": "c-enderecamento-de-memoria-e-ponteiros.html#ponteiros-nulos",
    "href": "c-enderecamento-de-memoria-e-ponteiros.html#ponteiros-nulos",
    "title": "20  Endereçamento de memória e ponteiros nos programas",
    "section": "20.3 Ponteiros nulos",
    "text": "20.3 Ponteiros nulos\nNão custa lembrar que uma variável do tipo ponteiro é como qualquer outra variável e, para ser usada, precisa ter um valor válido atribuído a ela. O programa que segue mostra o conteúdo de um ponteiro para double que não foi iniciado e, portanto, contém lixo.\n/*\n * Uso de um ponteiro sem valor atribuído\n * Assegura: apresentação do endereço de uma variável\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double *ponteiro_para_double;\n    printf(\"%p.\\n\", (void *)ponteiro_para_double);  // lixo\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:9:5: warning: ‘ponteiro_para_double’ is used uninitialized \n[-Wuninitialized]\n    9 |     printf(\"%p.\\n\", (void *)ponteiro_para_double);  // lixo\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nmain.c:8:13: note: ‘ponteiro_para_double’ was declared here\n    8 |     double *ponteiro_para_double;\n      |             ^~~~~~~~~~~~~~~~~~~~\n0x7ffce3050818.\nPorém, há uma diferença entre ter uma variável com valor inválido (nada foi atribuído a ela) e ter uma variável que “não aponta para nada”. Em C, o valor NULL é usado para indicar explicitamente que uma variável não é referência para um endereço real.\n/*\n * Uso de um ponteiro sem valor atribuído\n * Assegura: apresentação do endereço de uma variável\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double *ponteiro_para_double = NULL;  // endereço explicitamente inválido\n    printf(\"%p.\\n\", (void *)ponteiro_para_double); \n\n    return 0;\n}\n(nil).\nNa computação em geral, termos como null, nil ou nulo são usados para se referir a um endereço sabidamente inválido. Em C esse valor é expresso por NULL e permite comparações, como if (p != NULL), por exemplo.\nPara recordar essa situação é possível citar o acesso a arquivos. Uma variável para guardar um arquivo lógico é um ponteiro do tipo FILE *, ou seja, guarda uma referência (endereço) de um objeto do tipo FILE. Quando uma chamada à função fopen não consegue acessar o arquivo, ela retorna NULL, Em outras palavras, fopen retorna o endereço de algo válido em caso de sucesso ou o endereço especial NULL para indicar que o endereço não pode ser usado. Todas as demais funções (fprint, fgets, fclose) apenas usam o endereço válido quando são chamadas.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Endereçamento de memória e ponteiros nos programas</span>"
    ]
  },
  {
    "objectID": "c-enderecamento-de-memoria-e-ponteiros.html#manipulação-da-memória-com-uso-de-ponteiros",
    "href": "c-enderecamento-de-memoria-e-ponteiros.html#manipulação-da-memória-com-uso-de-ponteiros",
    "title": "20  Endereçamento de memória e ponteiros nos programas",
    "section": "20.4 Manipulação da memória com uso de ponteiros",
    "text": "20.4 Manipulação da memória com uso de ponteiros\nUma aplicação importante de ponteiros é a possibilidade de, tendo em mãos um endereço, modificar o que há naquele local. Assim, se um ponteiro contém o endereço de um inteiro, é viável ver e alterar o valor apontado.\nUm exemplo inicial simples é apresentado na sequência, ilustrando como o ponteiro pode ser usado para acessar uma posição de memória.\n/*\n * Uso de ponteiro para ter acesso a um valor armazenado na memória\n * Assegura: Apresentação do valor de duas variáveis usando um ponteiro\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int n1 = 75;\n    int n2 = -3;\n    int *ponteiro;\n\n    // Uso do ponteiro com n1\n    ponteiro = &n1;  // guarda em ponteiro a referência para n1\n    printf(\"Valor apontado: %d.\\n\", *ponteiro);\n\n    // Uso do ponteiro com n2\n    ponteiro = &n2;  // altera a referência para n2\n    printf(\"Valor apontado: %d.\\n\", *ponteiro);\n\n    return 0;\n}\nValor apontado: 75.\nValor apontado: -3.\nNeste programa são criadas duas variáveis int: n1 e n2. À primeira é atribuído o valor 75 e à segunda, -3. Uma variável ponteiro é criada para guardar o endereço de um valor int e o endereço de n1 é armazenado, conforme destacado na sequência.\nint *ponteiro;  // criação de uma variável ponteiro\nponteiro = &n1;  // armazenamento do endereço de n1\nNesse momento, com ponteiro contendo o endereço de n1, a expressão *ponteiro se refere ao valor inteiro guardado nesse endereço. Em outras palavras, ponteiro aponta para n1 e, em consequência, *ponteiro dá o valor apontando, que é o valor de n1. Assim, o printf usa essa valor para “espiar” em n1.\nO programa então dá instruções para que ponteiro aponte para n2 para, em seguida, usar *ponteiro para acessar seu valor, conforme destaque seguinte.\nponteiro = &n2;  // altera a referência para n2\nprintf(\"Valor apontado: %d.\\n\", *ponteiro);\nÉ importante notar que, nesse programa, ponteiro é do tipo int * e guarda endereços de elementos inteiros e, por sua vez, *ponteiro é do tipo int, pois olha o conteúdo apontado naquele endereço. A Tabela 20.1 mostra alguns casos e os tipos associados à notação sem e com o operador *.\n\n\n\nTabela 20.1: Algumas declarações de ponteiros e os tipos associados ao identificador e ao uso do operador *.\n\n\n\n\n\n\n\n\n\n\nDeclaração\nTipos associados\nExemplos\n\n\n\n\nchar *pc\npc é char *\n*pc é char\npc = &c\nprinf(\"%c\", *pc)\n\n\n\n\nint *pi\npi é int *\n*pi é int\npi = &i\nprintf(\"%d\", *pi)\n\n\n\n\ndouble *pd\npd é double *\n*pd é double\npd = &d\nprintf(\"%g\", *pd)\n\n\n\n\nunsigned int *pui\npui é unsigned int *\n*pd é unsigned int\npui = &ui\nprintf(\"%u\", *pui)\n\n\n\n\n\n\n\n\nDe forma similar ao se obter o conteúdo referenciado por um ponteiro, também é possível modificar o valor apontado. Segue um programa para exemplificar essa situação.\n/*\n * Modificação de um valor inteiro com uso de um ponteiro\n * Assegura: Apresentação do valor do inteiro antes e depois da modificação\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int valor_inteiro = 123;\n    printf(\"Valor da variável: %d.\\n\", valor_inteiro);\n\n    int *ponteiro = &valor_inteiro;\n    *ponteiro = 98765;\n    printf(\"Valor da variável: %d.\\n\", valor_inteiro);\n\n    return 0;\n}\nValor da variável: 123.\nValor da variável: 98765.\nA variável valor_inteiro é declarada, tem o valor 123 atribuído a ela e esse valor é apresentado. Então a variável ponteiro é criada e o endereço de valor_inteiro é armazenado nela. A modificação de valor é feita pelo comando destacado.\n*ponteiro = 98765;  // modifica o valor do endereço guardado em ponteiro\nEssa instrução, basicamente, diz “coloque o valor 98765 no endereço armazenado em ponteiro”. Nesse caso, como ponteiro aponta para valor_inteiro, os bytes dessa última variável serão alterados. O resultado é que, em última instância, valor_inteiro tem seu conteúdo atualizado.\nDesse modo, *ponteiro pode ser tanto usado para obter o valor apontado quanto para modificá-lo.\nint i, j, *pi;  // i e j inteiros, pi ponteiro para inteiro\n\ni = 10;\npi = &i;\n\nj = *pi;  // copia o valor 10 (de i) para j\n*pi = 1;  // coloca o valor 1 em i",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Endereçamento de memória e ponteiros nos programas</span>"
    ]
  },
  {
    "objectID": "c-enderecamento-de-memoria-e-ponteiros.html#os-ponteiros-têm-tipos",
    "href": "c-enderecamento-de-memoria-e-ponteiros.html#os-ponteiros-têm-tipos",
    "title": "20  Endereçamento de memória e ponteiros nos programas",
    "section": "20.5 Os ponteiros têm tipos",
    "text": "20.5 Os ponteiros têm tipos\nOs ponteiros são sempre declarados usando um tipo (char, int, double etc.) e especificando um asterisco antes do identificador, conforme os exemplos que seguem.\nint *pi;  // ponteiro para int\nchar *pc;  // ponteiro para char\nlong double *pld;  // ponteiro para long double\nunsigned char *puc;  // ponteiro para um unsigned char\nOs tipos são importantes para o compilador lidar com as diversas operações. Assim, atribuições usando *pi do lado esquerdo do operador de atribuição tratarão uma atribuição para inteiro; ao se escrever *pi + *pld, as promoções de tipo serão feitas segundo as regras; ou para usar o printf para mostrar *puc deve ser usado o formato %u, pois seu tipo é unsigned char.\nSegue um exemplo em que há mistura de tipos e, dada a mistura, os resultados divergem dos esperados.\n/*\n * Uso do tipo incorreto para um ponteiro\n * Assegura: Apresentação do valor do inteiro antes e depois da modificação\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    float f = -1.1;\n\n    int *p = (int *)&f;  // usa int* para apontar para float\n    *p = 1000;  // altera o conteúdo de d\n\n    printf(\"d = %g.\\n\", f);\n\n    return 0;\n}\nd = 1.4013e-42.\nComo as representações de float e int são diferentes, a variável f tenta extrair um valor real a partir de um conjunto de bits que, na realidade, representa um inteiro. A conclusão é simples: não funciona.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Endereçamento de memória e ponteiros nos programas</span>"
    ]
  },
  {
    "objectID": "c-enderecamento-de-memoria-e-ponteiros.html#sec-ponteiros-para-cadeias-de-caracteres",
    "href": "c-enderecamento-de-memoria-e-ponteiros.html#sec-ponteiros-para-cadeias-de-caracteres",
    "title": "20  Endereçamento de memória e ponteiros nos programas",
    "section": "20.6 Ponteiros para cadeias de caracteres",
    "text": "20.6 Ponteiros para cadeias de caracteres\nEm C, uma cadeia de caracteres é uma sequência de bytes contínuos na memória (os caracteres) seguida por um byte nulo \\0. É dessa forma, por exemplo, que a função printf, quando usa o formato %s, interpreta a memória e decide o que apresentar na tela.\nComo está introduzido na Capítulo 16, há cadeias de caracteres constantes e também em variáveis. Em particular, a Seção 16.3 mostra como usar ponteiros para referenciar as constantes literais existentes em um programa.\nDa mesma forma que é possível ter uma variável do tipo char * apontando para uma constante, também é comum que esse ponteiro seja usado para apontar para uma variável.\nPara os ponteiros lidarem com cadeias de caracteres há dois pontos principais: o ponteiro mantém o endereço do primeiro byte da cadeia e o fim da cadeia é indicado pelo terminador \\0.\nO programa seguinte mostra o uso de ponteiros tanto para constantes quanto para variáveis.\n/*\n * Ponteiros para cadeias de caracteres\n * Assegura: apresentação de algumas cadeias de caracteres\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char *texto_ponteiro = \"Texto constante\";  // ponteiro para constante\n    printf(\"Constante: %s.\\n\", texto_ponteiro);\n\n    char texto_variavel[100] = \"Texto de iniciação da variável\";  // variável\n    printf(\"Variável: %s.\\n\", texto_variavel);\n\n    char *outro_ponteiro;\n    outro_ponteiro = texto_ponteiro;  // também aponta para a constante\n    printf(\"Constante de novo: %s.\\n\", outro_ponteiro);\n\n    outro_ponteiro = texto_variavel;  // aponta para a variável\n    printf(\"Variável via ponteiro: %s.\\n\", outro_ponteiro);\n    \n    return 0;\n}\nConstante: Texto constante.\nVariável: Texto de iniciação da variável.\nConstante de novo: Texto constante.\nVariável via ponteiro: Texto de iniciação da variável.\nA variável texto_ponteiro é um ponteiro e contém o endereço do primeiro byte da constante \"Texto constante\". Por sua vez, texto_variavel já é um espaço para uma cadeia de até 99 bytes, ao qual também é copiado um valor inicial.\nUma terceira variável outro_ponteiro é usada, em um primeiro momento, para apontar para a constante, o que é feito copiando-se o endereço armazenado em texto_ponteiro.\noutro_ponteiro = texto_ponteiro;  // copia a referência para outro_ponteiro\nEssa mesma variável é usada para, em um segundo momento, apontar para o primeiro byte da variável texto_variavel.\noutro_ponteiro = texto_variavel;  // aponta para a variável\nAqui, é importante observar que existe uma variável literal denominada texto_variavel e o uso deste identificador não se refere ao texto armazenado nela, mas ao seu endereço. Na prática, texto_variavel equivale a &texto_variavel[0], ou seja, ao endereço do primeiro byte da variável. Esta é uma das razões pelas quais a atribuição direta a variáveis textuais em C não funciona, como exemplificado na sequência.\nchar nome[100] = \"Cervantes\"  // variável \nchar outro_nome[100];\n\noutro_nome = nome;  // não funciona, pois 'nome' é um endereço e não\n                    // o texto \"Cervantes\"",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Endereçamento de memória e ponteiros nos programas</span>"
    ]
  },
  {
    "objectID": "c-enderecamento-de-memoria-e-ponteiros.html#exemplos",
    "href": "c-enderecamento-de-memoria-e-ponteiros.html#exemplos",
    "title": "20  Endereçamento de memória e ponteiros nos programas",
    "section": "20.7 Exemplos",
    "text": "20.7 Exemplos\nNesta seção são apresentados alguns programas relativamente simples e genéricos que usam ponteiros, tendo como objetivo reforçar os conceitos e indicar alguns de seus usos.\n\n20.7.1 Selecionando o menor valor\nO exemplo seguinte usa um ponteiro para modificar o valor de uma entre duas variáveis. A variável a ser modificada é sempre a de valor mínimo.\n/*\n * Duplicando o valor mínimo com uso de ponteiro\n * Requer: dois valores reais quaisquer\n * Assegura: apresentação do dobro do valor mínimo e do valor máximo original\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    // Entrada\n    printf(\"Digite dois valores reais: \");\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    double valor1, valor2;\n    sscanf(entrada, \"%lf%lf\", &valor1, &valor2);\n\n    // Duplicação do valor mínimo usando um ponteiro\n    double *ponteiro_minimo;\n    if (valor1 &lt; valor2)\n        ponteiro_minimo = &valor1;\n    else\n        ponteiro_minimo = &valor2;\n    *ponteiro_minimo = *ponteiro_minimo * 2;  // dobra o valor mínimo\n\n    // Apresentação do resultado\n    printf(\"valor1 = %g e valor2 = %g.\\n\", valor1, valor2);\n\n    return 0;\n}\nDigite dois valores reais: 10.7 18.2\nvalor1 = 21.4 e valor2 = 18.2.\nCom valor1 e valor2 lidos, a variável ponteiro_minimo pode apontar tanto para a primeira quanto para a segunda, a depender de seus valores.\nA estrutura if usada poderia ser substituída por uma atribuição com o condicional ternário:\nponteiro_minimo = (valor1 &lt; valor2) ? &valor1 : &valor2;\n\n\n20.7.2 Vários ponteiros para um mesmo local\nAssim como nada impede que duas ou mais variáveis double tenham um mesmo valor, também é possível que vários ponteiros armazenem o mesmo endereço. Nesse caso, diz-se que vários ponteiros apontam para o mesmo local.\nO programa seguinte define uma variável c do tipo char e usa três ponteiros para referenciá-la.\n/*\n * Uso de vários ponteiros para um mesmo local\n * Assegura: apresentação dos valores apontados dadas algumas modificações\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c = 'A';\n\n    char *p1, *p2, *p3;\n    p1 = p2 = p3 = &c;  // todos os ponteiros apontam para c\n    printf(\"c = %c; *p1 = %c; *p2 = %c; *p3 = %c.\\n\", c, *p1, *p2, *p3);\n\n    c = 'B';\n    printf(\"c = %c; *p1 = %c; *p2 = %c; *p3 = %c.\\n\", c, *p1, *p2, *p3);\n\n    *p1 = 'C';\n    printf(\"c = %c; *p1 = %c; *p2 = %c; *p3 = %c.\\n\", c, *p1, *p2, *p3);\n\n    *p2 = 'D';\n    printf(\"c = %c; *p1 = %c; *p2 = %c; *p3 = %c.\\n\", c, *p1, *p2, *p3);\n\n    *p3 = 'E';\n    printf(\"c = %c; *p1 = %c; *p2 = %c; *p3 = %c.\\n\", c, *p1, *p2, *p3);\n\n    return 0;\n}\nc = A; *p1 = A; *p2 = A; *p3 = A.\nc = B; *p1 = B; *p2 = B; *p3 = B.\nc = C; *p1 = C; *p2 = C; *p3 = C.\nc = D; *p1 = D; *p2 = D; *p3 = D.\nc = E; *p1 = E; *p2 = E; *p3 = E.\nComo todas as variáveis (c, *p1, *p2 e *p3) estão se referenciando ao mesmo char na memória, esse caractere pode ser modificado por qualquer uma delas.\n\n\n20.7.3 Copiando referências\nAo se atribuir o endereço de uma variável a um ponteiro, o valor armazenado é o endereço de memória do primeiro byte dessa variável. Se houver outra variável do tipo ponteiro, esse endereço pode ser copiado para ela com uma atribuição simples. Dessa forma, como no exemplo da Seção 20.7.2, o resultado é que se tem mais de um ponteiro referenciando uma mesma posição.\n/*\n * Cópia de referência entre ponteiros\n * Assegura: apresentação dos valores apontados dadas algumas modificações\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c = 'A';\n\n    char *p1 = &c;\n    char *p2 = p1;\n    printf(\"c = %c; *p1 = %c; *p2 = %c.\\n\", c, *p1, *p2);\n\n    c = 'X';\n    printf(\"c = %c; *p1 = %c; *p2 = %c.\\n\", c, *p1, *p2);\n\n    return 0;\n}\nc = A; *p1 = A; *p2 = A.\nc = X; *p1 = X; *p2 = X.\nNeste programa, p1 aponta para c ao receber &c. Para p2 é atribuído o valor de p1, o qual, nesse momento, é igual ao &c.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Endereçamento de memória e ponteiros nos programas</span>"
    ]
  },
  {
    "objectID": "c-procedimentos.html",
    "href": "c-procedimentos.html",
    "title": "21  Procedimentos em C",
    "section": "",
    "text": "21.1 Funções sem retorno\nA modularização envolve as funções, como apresentado no Capítulo 18. Há casos, porém, em que há necessidades de um módulo para realizar uma ação, mas ele não precisa retornar um valor. Módulos que não retornam valores são chamados procedimentos e, em C, são funções que não voltam valor.\nEste capítulo trata das funções sem retorno de valor.\nUm exemplo simples de função que não retorna nada é a função (procedimento) perror, cuja função é apresentar uma mensagem de erro, como o programa seguinte que mostra as mensagens referentes aos códigos de erro de zero até nove.\nO objetivo de perror é apresentar uma mensagem na tela de acordo com o valor de errno, artificialmente ajustado com o valor de i a cada repetição. Essa função não retorna nenhum valor. Essa função tem a declaração seguinte.\nO tipo de retorno é especificado como void, que poderia ser entendido como “nada”, o que indica que essa função somente pode ser usada como um comando e nunca em uma expressão.\nOutro exemplo de procedimento da biblioteca padrão é bzero1, que preenche todos os bytes de uma cadeia de caracteres com o byte nulo e não retorna qualquer valor.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Procedimentos em C</span>"
    ]
  },
  {
    "objectID": "c-procedimentos.html#funções-sem-retorno",
    "href": "c-procedimentos.html#funções-sem-retorno",
    "title": "21  Procedimentos em C",
    "section": "",
    "text": "/*\n * Mensagens de erro padrão da biblioteca C\n * Assegura: apresentação das 10 primeiras mensagens de erro\n */\n#include &lt;stdio.h&gt;\n#include &lt;errno.h&gt;\n\nint main(void) {\n    for (int i = 0; i &lt; 10; i++) {\n        errno = i;  // ajusta o erro para o valor de i\n        perror(NULL);  // mensagem referente ao erro i\n    }\n\n    return 0;\n}\nSuccess\nOperation not permitted\nNo such file or directory\nNo such process\nInterrupted system call\nInput/output error\nNo such device or address\nArgument list too long\nExec format error\nBad file descriptor\n\nvoid perror(const char *s);\n\n\nvoid bzero(void s[.n], size_t n);\n\n\n\n\n\n\nNota\n\n\n\nEmbora o nome procedimento se refira claramente a um conjunto de instruções que não retornam valor, é comum na linguagem C o uso do nome função. Assim, de forma geral, algumas vezes uma rotina será chamada de procedimento, mas no geral, retornando ou não valores, os módulos com rotinas serão chamados genericamente de funções.\nO leitor, portanto, não deve assumir que o nome função se refere necessariamente à rotina que retorna um valor.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Procedimentos em C</span>"
    ]
  },
  {
    "objectID": "c-procedimentos.html#criação-de-procedimentos",
    "href": "c-procedimentos.html#criação-de-procedimentos",
    "title": "21  Procedimentos em C",
    "section": "21.2 Criação de procedimentos",
    "text": "21.2 Criação de procedimentos\nPara escrever um procedimento, basta que seu tipo de retorno seja void. Os parâmetros podem ser quantos e de quais tipos forem necessários.\nSegue um exemplo de um procedimento que apresenta uma mensagem (bom dia, boa tarde ou boa noite) dependendo da hora do dia.\n/*!\n * Apresenta na tela uma saudação dependente da hora do dia\n * @param hora: hora do dia, de 0 a 23\n */\nvoid faca_uma_saudacao(int hora);\nA implementação dessa função pode ser observada no programa exemplo que segue.\n/*\n * Saudação cordial\n * Assegura: apresentação de uma mensagem de acordo com o horário (bom dia,\n *  boa tarde ou boa noite)\n */\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\n/*!\n * Retorna a hora atual\n * @return hora segundo o sistema operacional, de 0 a 24\n */\nint obtenha_hora_atual();\n\n/*!\n * Apresenta na tela uma saudação dependente da hora do dia (bom dia,\n *  boa tarde ou boa noite)\n */\nvoid faca_uma_saudacao(int hora);\n\n/*\n * Main\n */\nint main(void) {\n    printf(\"Às 8 horas: \");\n    faca_uma_saudacao(8);\n\n    printf(\"Às 17 horas: \");\n    faca_uma_saudacao(17);\n\n    printf(\"Às 22 horas: \");\n    faca_uma_saudacao(22);\n\n    int hora_atual = obtenha_hora_atual();\n    printf(\"Agora, %d hora(s): \", hora_atual);\n    faca_uma_saudacao(hora_atual);\n\n    return 0;\n}\n\n// Apresenta saudação dependente da hora\nvoid faca_uma_saudacao(int hora) {\n    if (hora &lt;= 11)\n        printf(\"Bom dia!\\n\");\n    else if (hora &lt;= 18)\n        printf(\"Boa tarde!\\n\");\n    else\n        printf(\"Boa noite!\\n\");\n}\n\n// Retorna a hora atual do sistema\nint obtenha_hora_atual() {\n    time_t tempo = time(NULL);\n    struct tm horario = *localtime(&tempo);\n    return horario.tm_hour;\n}\nÀs 8 horas: Bom dia!\nÀs 17 horas: Boa tarde!\nÀs 22 horas: Boa noite!\nAgora, 18 hora(s): Boa tarde!\nO procedimento faca_uma_saudacao escolhe qual saudação apresentar, havendo em main três exemplos fixos e um dependente da hora real. É relevante notar que os procedimentos dispensam o return, apenas terminando naturalmente depois de executar a última instrução interna.\nA função obtenha_hora_atual retorna um valor de zero a 23 dependendo da hora atual do sistema operacional. Os detalhes das funções envolvidas não são relevantes e não são discutidos.\nComo talvez tenha já sido constado pelo leitor, o uso de procedimentos costuma ser menor que o de funções (que voltam valores).",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Procedimentos em C</span>"
    ]
  },
  {
    "objectID": "c-procedimentos.html#footnotes",
    "href": "c-procedimentos.html#footnotes",
    "title": "21  Procedimentos em C",
    "section": "",
    "text": "A função bzero, embora seja um bom exemplo para este texto, é obsoleta e não deve ser usada.↩︎",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Procedimentos em C</span>"
    ]
  },
  {
    "objectID": "c-parametros-de-funcoes.html",
    "href": "c-parametros-de-funcoes.html",
    "title": "22  Parâmetros das funções na linguagem C",
    "section": "",
    "text": "22.1 Passagem de parâmetros por valor\nNeste capítulo são retomados os conceitos de parâmetros de funções, detalhando seu funcionamento interno e dando alternativas para algumas necessidades reais dos programas.\nA ideia de se ter parâmetros nas funções é bastante intuitivo. Considerando-se uma função simples, pode ser escrito o código seguinte para o cálculo do quadrado de um valor real.\nA implementação dessa função pode ser dada como se segue.\nDessa forma, um comando usando essa função é bastante direto.\nComo não existe uma única forma de se implementar uma função, uma nova versão pode ser usada, como a que é apresentada na sequência.\nPara essa implementação, não há dúvidas de que o valor retornado sempre será igual ao da primeira implementação. A diferença aqui é que o parâmetro x é modificado dentro da função.\nO que se pode colocar em dúvida aqui é, ao se escrever y = quadrado(x), o valor de x não é também alterado? Da discussão apresentada no Capítulo 19 já é possível deduzir que o parâmetro x é uma declaração local e, portanto, independente de qualquer outro x que exista no programa. A execução do programa exemplo seguinte demonstra isso.\nNo printf usado em main é possível verificar que o valor de x local continua com o valor inicialmente atribuído.\nPara um segundo exemplo, um outro programa é apresentado, o qual contém uma função para apresentar uma cadeia de caracteres entre aspas.\nNeste caso, como cadeias de caracteres não podem ser copiadas diretamente em C, a opção foi usar as referências às cadeias, como está apresentado na Seção 20.6. O “truque” é passar o endereço do que se deseja apresentar na tela, lembrando que, em main, nas duas chamadas para o procedimento escreva_entre_aspas o argumento é sempre o endereço do primeiro byte da cadeia de caracteres de interesse.\nPara especificar claramente as passagens de parâmetros, no exemplo da função quadrado, o parâmetro x recebe uma cópia do valor do x. Para o caso da função escreva_entre_aspas, o parâmetro texto (que é um ponteiro), recebe uma cópia do valor do endereço de texto_constante (na primeira chamada) e de texto_variavel (na segunda).\nEm programação, quando um parâmetro recebe a cópia do valor de seu argumento, essa passagem de parâmetros é chamada passagem por valor.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Parâmetros das funções na linguagem C</span>"
    ]
  },
  {
    "objectID": "c-parametros-de-funcoes.html#passagem-de-parâmetros-por-valor",
    "href": "c-parametros-de-funcoes.html#passagem-de-parâmetros-por-valor",
    "title": "22  Parâmetros das funções na linguagem C",
    "section": "",
    "text": "/*!\n * Retorna x^2\n * @param x \n * @return x^2\n */\ndouble quadrado(double x);\n\n// Retorna o quadrado de x\ndouble quadrado(double x) {\n    return x * x;\n}\n\ndouble x = 32.2;\ndouble y = quadrado(x);\n\nprintf(\"%g^2 = %g.\\n\", x, y);\n\n// Retorna o quadrado de x\ndouble quadrado(double x) {\n    x = x * x;  // transforma x em x^2\n    return x;\n}\n\n\n/*\n * Cálculo do quadrado de um valor real\n * Assegura: apresentação do quadrado de um valor exemplo\n */\n#include &lt;stdio.h&gt;\n\n/*!\n * Retorna x^2\n * @param x\n * @return x^2\n */\ndouble quadrado(double x);\n\n/*\n * Main\n */\nint main(void) {\n    double x = 32.2;\n    double y = quadrado(x);\n\n    printf(\"%g^2 = %g.\\n\", x, y);\n\n    return 0;\n}\n\n// Retorna o quadrado de x\ndouble quadrado(double x) {\n    x = x * x;\n    return x;\n}\n32.2^2 = 1036.84.\n\n\n/*\n * Cálculo do quadrado de um valor real\n * Assegura: apresentação do quadrado de um valor exemplo\n */\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n/*!\n * Escreve o texto na tela entre aspas\n * @param texto: referência ao texto que será escrito\n */\nvoid escreva_entre_aspas(char *texto);\n\n/*\n * Main\n */\nint main(void) {\n    // Constante textual\n    char *texto_constante = \"Programação em C é legal!\";\n    escreva_entre_aspas(texto_constante);\n    printf(\"\\n\");\n\n    // Variável textual\n    char texto_variavel[100];\n    strncpy(texto_variavel, \"Outras linguagens também são!\",\n            sizeof texto_variavel - 1);\n    escreva_entre_aspas(texto_variavel);\n    printf(\"\\n\");\n\n    return 0;\n}\n\n// Escreve texto entre aspas\nvoid escreva_entre_aspas(char *texto) {\n    printf(\"\\\"%s\\\"\", texto);\n}\n\"Programação em C é legal!\"\n\"Outras linguagens também são!\"",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Parâmetros das funções na linguagem C</span>"
    ]
  },
  {
    "objectID": "c-parametros-de-funcoes.html#sec-passagem-por-referencia",
    "href": "c-parametros-de-funcoes.html#sec-passagem-por-referencia",
    "title": "22  Parâmetros das funções na linguagem C",
    "section": "22.2 Passagem de referências",
    "text": "22.2 Passagem de referências\nPara introduzir uma nova necessidade, um novo programa é apresentado. Nele, dois valores são dados pelo usuário e eles devem ser trocados se estiverem em ordem decrescente. Esta implementação é uma nova versão para o Algoritmo 7.1, agora usando um procedimento.\n/*\nApresentação de dois valores em ordem não decrescente\nRequer: dois valores reais v1 e v2\nAssegura: apresentação de v1 e v2, v1 &lt;= v2\n*/\n#include &lt;stdio.h&gt;\n\n/*!\n * Troca o valor do primeiro com o do segundo\n * @param valor1: o primeiro valor\n * @param valor2: o segundo valor\n */\nvoid troque_valores(double valor1, double valor2);\n\n/*\n * Main\n */\nint main(void) {\n    printf(\"Digite dois valores reais: \");\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    double v1, v2;\n    sscanf(entrada, \"%lf%lf\", &v1, &v2);\n\n    if (v2 &lt; v1)\n        troque_valores(v1, v2);\n\n    printf(\"Valores em ordem não decrescente: %g e %g.\\n\", v1, v2);\n\n    return 0;\n}\n\n// Troca os valores de valor1 e valor2 (versão incorreta)\nvoid troque_valores(double valor1, double valor2) {\n    double temporario = valor1;\n    valor1 = valor2;\n    valor2 = temporario;\n}\nDigite dois valores reais: 120 28\nValores em ordem não decrescente: 120 e 28.\nHá uma óbvia frustração ao se executar o programa, visto que os valores não são apresentados na ordem esperada. Isso se deve à passagem por valor de v1 e v2, pois efetivamente os conteúdos de valor1 e valor2 são trocados, porém as variáveis usadas nas chamadas são mantidas intactas.\nMuitas linguagens dispõe de uma forma de passagem de parâmetros conhecida como passagem por referência, de forma que modificações feitas nos parâmetros se refletem nas variáveis usadas para chamar a função. Seguem exemplos de implementações com passagem por referência em Pascal e C++.\nEm Pascal, a palavra chave var indica que os dados serão alterados externamente ao procedimento.\n{ Troca os valores de Valor1 e Valor2 }\nprocedure TroqueValores(var Valor1, Valor2: Real);\nvar Temporario: Real;\nbegin\n    Temporario := Valor1;\n    Valor1 := Valor2;\n    Valor2 := Temporario;\nend;\nEm C++, o var do Pascal é substituído por &, com o mesmo significado.\n// Troca os valores de valor1 e valor2\nvoid troque_valores(double &valor1, double &valor2) {\n    double temporario = valor1;\n    valor1 = valor2;\n    valor2 = temporario;\n}\nEm C, porém, há um limitante importante para códigos similares: a linguagem não possui passagem por referência. A solução, portanto, é contornar essa restrição.\nConforme se discute no Capítulo 20, é possível alterar o valor de uma variável se houver um ponteiro que a referencie. É essa a estratégia usada nos programas em C, passando os endereços das variáveis que devem ser modificadas e usando os ponteiros para fazer as alterações desejadas.\nSegue a versão funcional do programa para a troca dos valores das variáveis.\n/*\nApresentação de dois valores em ordem não decrescente\nRequer: dois valores reais v1 e v2\nAssegura: v1 &lt;= v2\n*/\n#include &lt;stdio.h&gt;\n\n/*!\n * Troca o valor do primeiro com o do segundo\n * @param valor1: referência ao primeiro valor\n * @param valor2: referência ao segundo valor\n */\nvoid troque_valores(double *valor1, double *valor2);\n\n/*\n * Main\n */\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite dois valores reais: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double v1, v2;\n    sscanf(entrada, \"%lf%lf\", &v1, &v2);\n\n    if (v2 &lt; v1)\n        troque_valores(&v1, &v2);\n\n    printf(\"Valores em ordem não decrescente: %g e %g.\\n\", v1, v2);\n\n    return 0;\n}\n\n// Troca os valores de valor1 e valor2\nvoid troque_valores(double *valor1, double *valor2) {\n    double temporario = *valor1;\n    *valor1 = *valor2;\n    *valor2 = temporario;\n}\nDigite dois valores reais: 120 28\nValores em ordem não decrescente: 28 e 120.\nInicialmente, é preciso notar que os parâmetros para chamar as funções não são mais os valores das variáveis, mas seus endereços.\ntroque_valores(&v1, &v2);  // passagem dos endereços das variáveis\nPara receber os endereços, os parâmetros formais da função agora são ponteiros.\nvoid troque_valores(double *valor1, double *valor2);  // parâmetros: ponteiros\nNa implementação da função, temporario é uma variável local do tipo double, sem nada de especial. Para realizar as trocas, o conteúdo apontado pelos parâmetros é usado.\ndouble temporario = *valor1;  // copia o que está no endereço passado para o\n                              // primeiro parâmetro (valor1) para temporario\n*valor1 = *valor2;  // copia o conteúdo de um endereço para o outro\n*valor2 = temporario;  // recupera o temporario e o copia para o endereço \n                       // do segundo parâmetro (valor2)\nNa linguagem C, como não há passagem por referência, as referências têm que ser passadas explicitamente.\n\n22.2.1 Cadeias de caracteres são sempre passagem por referência\nPara as variáveis que armazenam cadeias de caracteres, tem-se que seu identificador já representa seu endereço. Em consequência, quando a função fgets é usada, seu primeiro parâmetro é uma passagem da referência. Isso é ilustrado a seguir.\nchar texto[100];\nfgets(texto, sizeof texto, stdin);  // o parâmetro texto é o endereço onde\n                                    // os dados da variável são guardados\nDessa forma a função fgets consegue, por meio do ponteiro passado, modificar o conteúdo da variável texto. A declaração de fgets é equivalente à apresentada na sequência1.\nchar *fgets(char s*, int size, FILE *stream);\nO primeiro parâmetro da função espera que seja passado um endereço de um char, que é para onde os bytes lidos serão transferidos.\nA consequência é que, na linguagem C, sempre são passadas as referências (endereços) das cadeias de caracteres.\n\n\n\n\n\n\nDica\n\n\n\nQuando se desejar passar uma cadeia de caracteres por valor (o que não é tecnicamente possível), pode-se contornar o problema especificando que a função não tem autorização para mudar o conteúdo da variável. O valor passado como parâmetro continua sendo a referência, mas o compilador gerará um erro caso o programador tente modificar o valor.\nSegue um exemplo simples.\n/*\n * Exemplo de erro ao tentar mudar uma cadeia de caracteres\n */\n#include &lt;stdio.h&gt;\n\n/*!\n * Apresenta uma mensagem na tela\n * @param mensagem: texto a ser apresentado\n */\nvoid apresente_mensagem(char const *mensagem);\n\n/*\n * Main\n */\nint main(void) {\n    char minha_mensagem[] = \"Olá a todos!\";\n    apresente_mensagem(minha_mensagem);\n\n    return 0;\n}\n\n// Apresenta a mensagem \nvoid apresente_mensagem(const char *mensagem) {\n    mensagem[0] = 'X';  // tentativa de alteração\n    printf(\"%s\\n\", mensagem);\n}\nmain.c: In function ‘apresente_mensagem’:\nmain.c:24:17: error: assignment of read-only location ‘*mensagem’\n   24 |     mensagem[0] = 'X';  // tentativa de alteração\n      |                 ^\nO modificador const adicionado ao parâmetro alerta o compilador que o identificador mensagem (parâmetro) não pode ser usado para alterar o valor.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Parâmetros das funções na linguagem C</span>"
    ]
  },
  {
    "objectID": "c-parametros-de-funcoes.html#exemplos",
    "href": "c-parametros-de-funcoes.html#exemplos",
    "title": "22  Parâmetros das funções na linguagem C",
    "section": "22.3 Exemplos",
    "text": "22.3 Exemplos\nNesta seção alguns exemplos interessantes são apresentados.\n\n22.3.1 “Já usei passagem por referência muitas vezes”\nAo longo dos inúmeros exemplos usados neste livro, a passagem por referência já vinha sendo utilizada. Por exemplo, na leitura de um valor real, a conversão é feita pelo sscanf, que pode ter o formato seguinte.\nsscanf(entrada, \"%lf\", &valor);\nÉ importante notar que o endereço da variável valor foi passado para sscanf. Depois de interpretar a cadeia de caracteres em entrada procurando por um %lf presente, o resultado dessa conversão é guardado como um double na posição de memória passada, ou seja, exatamente onde está a variável valor.\nSem o operador &, a função sscanf não conseguiria ter acesso à variável valor, que tem escopo externo a ela, e usa seu endereço para conseguir modificá-la.\nE, naturalmente, também fgets usa referência para fazer a leitura.\n\n\n22.3.2 Simplificação de números racionais\nUm número racional (\\(\\mathbb{Q}\\)) é aquele que pode ser escrito na forma \\(a/b\\), sendo \\(a \\in \\mathbb{Z}\\) com \\(b \\in \\mathbb{Z}^*\\). O Algoritmo 19.1 apresenta uma solução de como fazer a simplificação de um valor racional, padronizando sua apresentação.\nA seguir é apresentada uma versão de implementação desse algoritmo, agora com o emprego de um procedimento para fazer a simplificação.\n/*\n * Leitura e escrita de um número racional na forma de fração\n * Requer: a digitação de um valor a/b, a,b inteiros, a, b != 0\n * Assegura: apresentação do mesmo valor em forma simplificada e padronizada\n */\n#include &lt;stdio.h&gt;\n\n/*!\n * Simplificação de um número racional dados numerador e denominador\n * @param numerador: numerador\n * @param denominador: denominador (não nulo)\n */\nvoid simplifique_racional(int *numerador, int *denominador);\n\n/*!\n * Retorna o MDC de dois inteiros quaisquer (máximo divisor comum).\n * @param n1: primeiro valor\n * @param n2: segundo valor\n * @return MDC(n1, n2)\n */\nunsigned int mdc(int n1, int n2);\n\n/*!\n * Retorna o valor absoluto de um inteiro\n * @param n: valor inteiro\n * @return o valor absoluto do número, |n|\n */\nint valor_absoluto(int n);\n\n/*\n * Main\n */\nint main() {\n    // Leitura\n    printf(\"Digite um número racional a/b (a e b inteiros e b não nulo): \");\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    int numerador, denominador;\n    sscanf(entrada, \"%d/%d\", &numerador, &denominador);\n\n    // Simplificação e apresentação da razão\n    simplifique_racional(&numerador, &denominador);\n    printf(\"O racional digitado foi: %d/%d.\\n\", numerador, denominador);\n\n    return 0;\n}\n\n// Máximo divisor comum: MDC(n1, n2)\nunsigned int mdc(int n1, int n2) {\n    // Converte n1 e n2 para valores positivos\n    n1 = valor_absoluto(n1);\n    n2 = valor_absoluto(n2);\n\n    // Resolução pelo método de Euclides\n    int resto;\n    do {\n        resto = n1 % n2;\n        n1 = n2;\n        n2 = resto;\n    } while (resto != 0);\n\n    return (unsigned int)n1;  // Contém o MDC no final\n}\n\n// Valor absoluto de um inteiro\nint valor_absoluto(int n) {\n    return (n &gt;= 0) ? n : -n;\n}\n\n// Simplificação de um racional\nvoid simplifique_racional(int *numerador, int *denominador) {\n    if (*numerador == 0) {\n        *denominador = 1;  // padroniza zero para 0/1\n    }\n    else {\n        int sinal_da_fracao = ((double)*numerador / *denominador &gt;= 0) ? 1 : -1;\n        int fator_divisao = (int)mdc(*numerador, *denominador);\n        *numerador = valor_absoluto(*numerador);\n        *denominador = valor_absoluto(*denominador);\n        *numerador /= sinal_da_fracao * fator_divisao;\n        *denominador /= fator_divisao;\n    }\n}\nDigite um número racional a/b (a e b inteiros e b não nulo): 18/-26\nO racional digitado foi: -9/13.\nA função simplifique_racional determina o sinal (-1 ou 1, o qual será associado ao numerador) e qual o MDC entre o numerador e o denominador. Como são passadas referências às variáveis que estão em main, dentro da função são usados *numerador e *denominador para acesso às variáveis externas. A chamada para a simplificação, também, requer que os endereços das variáveis sejam passados.\nsimplifique_racional(&numerador, &denominador);  // endereços das variáveis\nUm ponto positivo de ter funções para realizar as diversas tarefas é que a função main fica mais simples e mais legível.",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Parâmetros das funções na linguagem C</span>"
    ]
  },
  {
    "objectID": "c-parametros-de-funcoes.html#footnotes",
    "href": "c-parametros-de-funcoes.html#footnotes",
    "title": "22  Parâmetros das funções na linguagem C",
    "section": "",
    "text": "A declaração foi levemente modificada para maior clareza, porém mantendo a equivalência.↩︎",
    "crumbs": [
      "Modularização e memória",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Parâmetros das funções na linguagem C</span>"
    ]
  },
  {
    "objectID": "c-dados-com-struct.html",
    "href": "c-dados-com-struct.html",
    "title": "23  C: Dados com struct",
    "section": "",
    "text": "23.1 Variáveis compostas\nEste capítulo discute como variáveis compostas heterogêneas, comumente chamadas de registros, são declaradas e usadas em C. São cobertos os aspectos de declaração, atribuição e seu uso com funções.\nA exploração de variáveis compostas se inicia com a apresentação de um problema envolvendo pontos em \\(\\mathbb{R}^3\\). Se três pontos no espaço são especificados, então um triângulo é formado e sua área pode ser calculada. O Algoritmo 23.1 apresenta a estratégia para esse cálculo.\nA função ÁreaTriângulo está apresentada no Algoritmo 23.2, assim como uma função DistânciaPontos necessária à sua execução.\nCom base nessas especificações, é possível escrever um programa em C para implementar essa solução.\nA grande distância entre o algoritmo e a implementação é a complexidade introduzida pelo número de parâmetros que as funções possuem. Enquanto no algoritmo a instrução ÁreaTriângulo(\\(P_1\\), \\(P_2\\), \\(P_3\\)) é clara, a codificação area_triangulo(x1, y1, z1, x2, y2, z2, x3, y3, z3) é mais longa e propensa a erros1.\nA questão envolvida nesse momento é como representar ÁreaTriângulo(\\(P_1\\), \\(P_2\\), \\(P_3\\)) no código area_triangulo(p1, p2, p3).\nPara esse fim, cada ponto pode ser estruturado como um registro e, em C, esse agrupamento é feito na forma de um struct.",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>C: Dados com `struct`</span>"
    ]
  },
  {
    "objectID": "c-dados-com-struct.html#variáveis-compostas",
    "href": "c-dados-com-struct.html#variáveis-compostas",
    "title": "23  C: Dados com struct",
    "section": "",
    "text": "Algoritmo 23.1: Cálculo da área de um triângulo no espaço \\(\\mathbb{R}^3\\).\n\n\n\n\n\n\nAlgoritmo 23.2: Função para cálculo da área de um triângulo dados seus vértices.\n\n\n\n\n/*\n * Determinação da área de um triângulo dados seus vértices em R^3\n * Requer: três pontos, cada um composto por suas coordenadas x, y e z\n * Assegura: a apresentação da área do triângulo definido pelos vértices\n */\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\n/*!\n * Retorna a área de um triângulo dados seus vértices\n * @param x1: x de P1\n * @param y1: y de P1\n * @param z1: z de P1\n * @param x2: x de P2\n * @param y2: y de P2\n * @param z2: z de P2\n * @param x3: x de P3\n * @param y3: y de P3\n * @param z3: z de P3\n * @return área do triângulo\n */\ndouble area_triangulo(double x1, double y1, double z1,\n                      double x2, double y2, double z2,\n                      double x3, double y3, double z3);\n\n/*!\n * Retorna a distância entre P1 e P2\n * @param x1: x de P1\n * @param y1: y de P1\n * @param z1: z de P1\n * @param x2: x de P2\n * @param y2: y de P2\n * @param z2: z de P2\n * @return a distância\n */\n\ndouble distancia_pontos(double x1, double y1, double z1,\n                        double x2, double y2, double z2);\n\n/*!\n * Leitura de um ponto em R^3\n * @param mensagem: mensagem solicitando a digitação dos dados\n * @param x: referência a x\n * @param y: referência a y\n * @param z: referência a z\n */\nvoid leia_ponto(char *mensagem, double *x, double *y, double *z);\n\n/*\n * Main\n */\nint main(void) {\n    double x1, y1, z1;\n    leia_ponto(\"Digite as coordenadas de P1: \", &x1, &y1, &z1);  // P1\n\n    double x2, y2, z2;\n    leia_ponto(\"Digite as coordenadas de P2: \", &x2, &y2, &z2);  // P2\n\n    double x3, y3, z3;\n    leia_ponto(\"Digite as coordenadas de P3: \", &x3, &y3, &z3);  // P3\n\n    double area = area_triangulo(x1, y1, z1, x2, y2, z2, x3, y3, z3);\n    printf(\"Área do triângulo: %.2f.\\n\", area);\n}\n\n// Retorna a área do triângulo dados os vértices\ndouble area_triangulo(double x1, double y1, double z1,\n                      double x2, double y2, double z2,\n                      double x3, double y3, double z3) {\n    double lado1 = distancia_pontos(x1, y1, z1, x2, y2, z2); // P1 e P2\n    double lado2 = distancia_pontos(x1, y1, z1, x3, y3, z3); // P1 e P3\n    double lado3 = distancia_pontos(x2, y2, z2, x3, y3, z3); // P2 e P3\n    double semiperimetro = (lado1 + lado2 + lado3) / 2;\n\n    return sqrt(semiperimetro * (semiperimetro - lado1) *\n                (semiperimetro - lado2) * (semiperimetro - lado3));\n}\n\n// Retorna a distância entre dois pontos\ndouble distancia_pontos(double x1, double y1, double z1,\n                        double x2, double y2, double z2) {\n    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2));\n}\n\n// Leitura de um ponto\nvoid leia_ponto(char *mensagem, double *x, double *y, double *z) {\n    printf(\"%s\", mensagem);\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%lf%lf%lf\", x, y, z);\n}\nDigite as coordenadas de P1: -1 7 3\nDigite as coordenadas de P2: -1 0 0\nDigite as coordenadas de P3: 2 3 5\nÁrea do triângulo: 17.31.",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>C: Dados com `struct`</span>"
    ]
  },
  {
    "objectID": "c-dados-com-struct.html#declaração-e-uso-do-struct",
    "href": "c-dados-com-struct.html#declaração-e-uso-do-struct",
    "title": "23  C: Dados com struct",
    "section": "23.2 Declaração e uso do struct",
    "text": "23.2 Declaração e uso do struct\nAs variáveis compostas, chamadas registros, são criadas com struct em C. A declaração de registros na linguagem pode assumir diversos formatos. Neste texto será adotado, com poucas exceções, um formato padronizado para manter a clareza.\nUm grupo de informações pode ser agrupado em uma única variável criando-se um registro. Como exemplo, um ponto no espaço, composto de coordenadas \\(x\\), \\(y\\) e \\(z\\) pode ser estruturado como segue.\n/*! @struct Ponto em R^3 */\nstruct ponto {\n    double x, y, z;\n};\nEssa instrução define um novo tipo na linguagem, chamado struct ponto. Ela é apenas uma declaração e nenhuma variável criada ou espaço de armazenamento é reservado.\nVariáveis podem ser criadas usando-se o formato geral de declarações: o tipo da variável é precedido pelo identificadores.\nstruct ponto ponto1, ponto2;  // duas variáveis (ponto1 e ponto2), ambas\n                              // do tipo struct ponto\n\n23.2.1 Uso e acesso a campos\nO acesso aos campos é feito com o operador . (ponto). Assim, ponto1.x é o campo x da variável ponto1.\n// Definição de ponto1 como o ponto (1.5, 0, 3.9)\nponto1.x = 1.5;\nponto1.y = 0;\nponto1.z = 3.9;\nUma vantagem interessante de variáveis struct é a capacidade de atribuição direta. Por exemplo, a instrução ponto2 = ponto1 pode ser usada sem problemas. Na prática, o compilador não está ciente dos campos ou de seus valores, mas copia todos os bytes que formam um registro para o outro, resultando em uma cópia idêntica.\n\n\n23.2.2 Declaração com iniciação\nÉ possível, ao declarar uma varável do tipo registro, já incluir a iniciação de seus valores. O programa seguinte ilustra essa manipulação.\n/*\n * Exemplo de iniciação de valores de um registro\n * Assegura: apresentação dos valores iniciados\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    struct pessoa {\n        char nome[100];\n        char cpf[15];\n        int ano_nascimento;\n    };\n\n    struct pessoa alguem = {\"Fulano de tal\", \"123.456.789-00\", 2008};\n\n    printf(\"Nome: %s,\\nCPF: %s,\\nAno: %d.\\n\", alguem.nome, alguem.cpf,\n           alguem.ano_nascimento);\n\n    return 0;\n}\nNome: Fulano de tal,\nCPF: 123.456.789-00,\nAno: 2008.\nEsse recurso, porém, apenas está disponível na declaração. Tentativas de atribuição posteriores não são aceitas. Nestes casos as atribuições necessariamente têm que ser feitas campo a campo.\n/*\n * Exemplo de falha na atribuição de registros\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    struct pessoa {\n        char nome[100];\n        char cpf[15];\n        int ano_nascimento;\n    };\n\n    struct pessoa alguem;\n    alguem = {\"Muriel Gomes Faruak\", \"123.456.789-00\", 2008};  // não funciona!\n\n    printf(\"Nome: %s,\\nCPF: %s,\\nAno: %d.\\n\", alguem.nome, alguem.cpf,\n           alguem.ano_nascimento);\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:14:14: error: expected expression before ‘{’ token\n   14 |     alguem = {\"Muriel Gomes Faruak\", \"123.456.789-00\", 2008};  // \nnão funciona!\n      |              ^",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>C: Dados com `struct`</span>"
    ]
  },
  {
    "objectID": "c-dados-com-struct.html#modularização-com-struct",
    "href": "c-dados-com-struct.html#modularização-com-struct",
    "title": "23  C: Dados com struct",
    "section": "23.3 Modularização com struct",
    "text": "23.3 Modularização com struct\nUm ponto positivo do struct na linguagem C é a possibilidade da atribuição de um registro para outro, copiando todos os campos de uma única vez, desde que sejam do mesmo tipo. Essa característica é interessante, em particular, ao passar um registro completo como parâmetro.\nRetomando o Algoritmo 23.1, a função para o cálculo da área da distância entre dois pontos pode se apresentar conforme segue, juntamente com a nova versão de DistânciaPontos.\n/*! @struct ponto */\nstruct ponto {\n    double x, y, z;\n};\n\n/*!\n * Retorna a área de um triângulo dados seus vértices\n * @param ponto1: primeiro vértice\n * @param ponto2: segundo vértice\n * @param ponto3: terceiro vértice\n * @return área do triângulo\n */\ndouble area_triangulo(struct ponto ponto1,\n                      struct ponto ponto2,\n                      struct ponto ponto3);\n\n/*!\n * Retorna a distância entre P1 e P2\n * @param ponto1: P1\n * @param ponto2: P2\n * @return a distância\n */\ndouble distancia_pontos(struct ponto ponto1, struct ponto ponto2);\nAs funções possuem como parâmetros formais registros do tipo struct ponto. A declaração de tipo desse structtem que ser global, uma vez que precisa ser conhecida nas funções subsequentes e, depois, dentro da função main.\nNa sequência é apresentada a implementação da função area_triangulo.\n// Retorna a área do triângulo dados os vértices\ndouble area_triangulo(struct ponto ponto1,\n                      struct ponto ponto2,\n                      struct ponto ponto3) {\n    double lado1 = distancia_pontos(ponto1, ponto2);\n    double lado2 = distancia_pontos(ponto1, ponto3);\n    double lado3 = distancia_pontos(ponto2, ponto3);\n    double semiperimetro = (lado1 + lado2 + lado3) / 2;\n\n    return sqrt(semiperimetro * (semiperimetro - lado1) *\n                (semiperimetro - lado2) * (semiperimetro - lado3));\n}\nTodas as chamadas são por valor, uma vez que uma cópia do registro inteiro é feita na passagem dos parâmetros.\nO código completo pode ser, então. apresentado.\n/*\n * Determinação da área de um triângulo dados seus vértices em R^3\n * Requer: três pontos, cada um composto por suas coordenadas x, y e z\n * Assegura: a apresentação da área do triângulo definido pelos vértices\n */\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\n/*! @struct ponto */\nstruct ponto {\n    double x, y, z;\n};\n\n/*!\n * Retorna a área de um triângulo dados seus vértices\n * @param ponto1: primeiro vértice\n * @param ponto2: segundo vértice\n * @param ponto3: terceiro vértice\n * @return área do triângulo\n */\ndouble area_triangulo(struct ponto ponto1,\n                      struct ponto ponto2,\n                      struct ponto ponto3);\n\n/*!\n * Retorna a distância entre P1 e P2\n * @param ponto1: P1\n * @param ponto2: P2\n * @return a distância\n */\ndouble distancia_pontos(struct ponto ponto1, struct ponto ponto2);\n\n/*!\n * Leitura de um ponto em R^3\n * @param mensagem: mensagem solicitando a digitação dos dados\n * @param x: referência a x\n * @param y: referência a y\n * @param z: referência a z\n */\nvoid leia_ponto(char *mensagem, double *x, double *y, double *z);\n\n/*\n * Main\n */\nint main(void) {\n    struct ponto vertice1;\n    leia_ponto(\"Digite as coordenadas 1: \", &vertice1.x, &vertice1.y,\n               &vertice1.z);\n\n    struct ponto vertice2;\n    leia_ponto(\"Digite as coordenadas 2: \", &vertice2.x, &vertice2.y,\n               &vertice2.z);\n\n    struct ponto vertice3;\n    leia_ponto(\"Digite as coordenadas 1: \", &vertice3.x, &vertice3.y,\n               &vertice3.z);\n\n    double area = area_triangulo(vertice1, vertice2, vertice3);\n    printf(\"Área do triângulo: %.2f.\\n\", area);\n}\n\n// Retorna a área do triângulo dados os vértices\ndouble area_triangulo(struct ponto ponto1,\n                      struct ponto ponto2,\n                      struct ponto ponto3) {\n    double lado1 = distancia_pontos(ponto1, ponto2);\n    double lado2 = distancia_pontos(ponto1, ponto3);\n    double lado3 = distancia_pontos(ponto2, ponto3);\n    double semiperimetro = (lado1 + lado2 + lado3) / 2;\n\n    return sqrt(semiperimetro * (semiperimetro - lado1) *\n                (semiperimetro - lado2) * (semiperimetro - lado3));\n}\n\n// Retorna a distância entre dois pontos\ndouble distancia_pontos(struct ponto ponto1, struct ponto ponto2) {\n    return sqrt(pow(ponto1.x - ponto2.x, 2) +\n                pow(ponto1.y - ponto2.y, 2) +\n                pow(ponto1.z - ponto2.z, 2));\n}\n\n// Leitura de um ponto\nvoid leia_ponto(char *mensagem, double *x, double *y, double *z) {\n    printf(\"%s\", mensagem);\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%lf%lf%lf\", x, y, z);\n}\nDigite as coordenadas 1: -1 7 3\nDigite as coordenadas 2: -1 0 0\nDigite as coordenadas 1: 2 3 5\nÁrea do triângulo: 17.31.\n\n23.3.1 Passagem de registro por referência\nDa mesma forma que outras variáveis, é possível passar a referência de um registro para uma função. O endereço de um registro é o endereço de seu primeiro byte, independentemente de seus campos.\nNo caso do exemplo da área do triângulo, a leitura de cada ponto está passando cada campo de forma independente. Essa situação pode ser modificada passando um único parâmetro (o registro) para a função, todo ele por referência.\nSegue a nova versão do procedimento leia_ponto.\n/*!\n * Leitura de um ponto em R^3\n * @param mensagem: mensagem solicitando a digitação dos dados\n * @param ponto: referência a um ponto\n */\nvoid leia_ponto(char *mensagem, struct ponto *ponto);\nO primeiro parâmetro, mensagem, está inalterado e as três coordenadas foram substituídas pelo registro todo. Agora, o parâmetro formal aguarda o endereço de uma variável struct ponto, estruturando uma passagem por referência. A chamada para essa função pode ser, por exemplo, como apresentada logo na sequência.\nstruct ponto ponto;\nleia_ponto(\"Digite as coordenadas: \", &ponto);\n\n\n23.3.2 Ponteiros para struct e acesso a campos\nO entendimento da passagem por referência quando os parâmetros são struct requer entender a natureza da notação específica usada em C para esses casos. Dessa forma, uma sequência de exemplos proporcionam o entendimento dos operadores utilizados.\nO programa seguinte mostra o uso de um ponteiro para fazer acesso ao conteúdo de um registro.\n/*\n * Registros e ponteiros para registros\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    /*! @struct registro com campos diversos */\n    struct registro {\n        int i;\n        double d;\n        char c;\n    };\n\n    // Variável comum para registro\n    struct registro r1 = {9, 3.7, 'x'};\n    printf(\"r1 = %d / %g / '%c'.\\n\", r1.i, r1.d, r1.c);\n\n    // Ponteiro para registro\n    struct registro *pr = &r1;  // pr aponta para r1\n\n    // Uso do ponteiro com outra variável comum\n    struct registro r2 = *pr;  // copia r1 para r2\n    printf(\"r2 = %d / %g / '%c'.\\n\", r2.i, r2.d, r2.c);\n\n    return 0;\n}\nr1 = 9 / 3.7 / 'x'.\nr2 = 9 / 3.7 / 'x'.\nNesse programa, r1 é um registro com três campos, iniciados com alguns valores ilustrativos. Há, também, uma variável do tipo ponteiro, cujo tipo base é struct registro.\nstruct registro *pr;  // para guardar o endereço de um registro\nDa mesma forma que outras variáveis e respectivos ponteiros, pr é usado para guardar um endereço (no caso, de r1) e a notação *pr permite o acesso aos dados apontado. Dessa forma, escrever r2 = *pr equivale, no código, a r2 = r1, já que pr aponta para r1. Em outras palavras, o tipo de pr é struct registro* (um ponteiro) e de *pr é struct registro (o registro real que está sendo apontado).\nA questão que se apresenta é o acesso aos campos de um registro apontado. C disponibiliza uma notação particular para essa situação, usando o operador -&gt;, como se ilustra a seguir.\n/*\n * Registros e ponteiros para registros\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    /*! @struct registro com campos diversos */\n    struct registro {\n        int i;\n        double d;\n        char c;\n    };\n\n    struct registro r1 = {9, 3.7, 'x'};\n    printf(\"r1 = %d / %g / '%c'.\\n\", r1.i, r1.d, r1.c);\n\n    struct registro *pr = &r1;\n    printf(\"r2 = %d / %g / '%c'.\\n\", pr-&gt;i, pr-&gt;d, pr-&gt;c);\n\n    return 0;\n}\nr1 = 9 / 3.7 / 'x'.\nr2 = 9 / 3.7 / 'x'.\nQuando uma variável p é um ponteiro para um struct, *p é o registro apontado inteiro e p-&gt;c indica o acesso ao campo c de *p.\n\n\n23.3.3 Uso dos ponteiros na passagem por referência\nCom o uso de ponteiros, a passagem por referência de um registro pode ser feita. O programa seguinte modifica a função de leitura de um ponto, trocando as três coordenadas separadas pelo registro como um todo. As demais funções ficaram inalteradas e foram suprimidas para simplificar a listagem.\n/*\n * Determinação da área de um triângulo dados seus vértices em R^3\n * Requer: três pontos, cada um composto por suas coordenadas x, y e z\n * Assegura: a apresentação da área do triângulo definido pelos vértices\n */\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\n/*! @struct ponto */\nstruct ponto {\n    double x, y, z;\n};\n\n// --- Alguns protótipos foram suprimidos\n\n/*!\n * Leitura de um ponto em R^3\n * @param mensagem: mensagem solicitando a digitação dos dados\n * @param ponto: referência para o ponto\n */\nvoid leia_ponto(char *mensagem, struct ponto *ponto);\n\n/*\n * Main\n */\nint main(void) {\n    struct ponto vertice1;\n    leia_ponto(\"Digite as coordenadas 1: \", &vertice1);\n\n    struct ponto vertice2;\n    leia_ponto(\"Digite as coordenadas 2: \", &vertice2);\n\n    struct ponto vertice3;\n    leia_ponto(\"Digite as coordenadas 1: \", &vertice3);\n\n    double area = area_triangulo(vertice1, vertice2, vertice3);\n    printf(\"Área do triângulo: %.2f.\\n\", area);\n}\n\n// --- Algumas implementações foram suprimidas\n\n// Leitura de um ponto\nvoid leia_ponto(char *mensagem, struct ponto *ponto) {\n    printf(\"%s\", mensagem);\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%lf%lf%lf\", &ponto-&gt;x, &ponto-&gt;y, &ponto-&gt;z);\n}\nDigite as coordenadas 1: -1 7 3\nDigite as coordenadas 2: -1 0 0\nDigite as coordenadas 1: 2 3 5\nÁrea do triângulo: 17.31.\nO procedimento leia_ponto mantém o primeiro parâmetro original, que é a mensagem apresentada e define mais um único parâmetro que é o struct passado como referência (com tipo struct ponto*). Dado que dentro desse procedimento o parâmetro ponto é um ponteiro, o acesso aos campos é escrito ponto-&gt;x, ponto-&gt;y e ponto-&gt;z. Para o sscanf, que também espera passagens por referência, são indicados os endereços de cada campo individualmente: &ponto-&gt;x, &ponto-&gt;y e &ponto-&gt;z.\nNa função main, a chamada para leia_ponto requer que seja passado o endereço do registro que será modificado.\nleia_ponto(\"Digite as coordenadas 1: \", &vertice1);",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>C: Dados com `struct`</span>"
    ]
  },
  {
    "objectID": "c-dados-com-struct.html#mais-sobre-as-declarações-de-struct",
    "href": "c-dados-com-struct.html#mais-sobre-as-declarações-de-struct",
    "title": "23  C: Dados com struct",
    "section": "23.4 Mais sobre as declarações de struct",
    "text": "23.4 Mais sobre as declarações de struct\nDeclarações de registros na linguagem C apresentam uma certa variedade de formatos. Nesta seção há comentários sobre algumas variações, embora nem todas sejam consideradas.\n\n23.4.1 Declaração sem nome de registro\nEm algumas situações, é possível agrupar os campos em um registro sem que o struct tenha um nome próprio.\nSegue um exemplo\n/*\n * Exemplo de struct sem nome\n * Assegura: apresentação dos valores iniciados\n */\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    struct {\n        char nome[100];\n        char cpf[15];\n        int ano_nascimento;\n    } alguem;\n    \n    strncpy(alguem.nome, \"Muriel Gomes Faruak\", sizeof alguem.nome - 1);\n    strncpy(alguem.cpf, \"123.456.789-00\", sizeof alguem.cpf - 1);\n    alguem.ano_nascimento = 2008;\n\n    printf(\"Nome: %s,\\nCPF: %s,\\nAno: %d.\\n\", alguem.nome, alguem.cpf,\n           alguem.ano_nascimento);\n\n    return 0;\n}\nNome: Muriel Gomes Faruak,\nCPF: 123.456.789-00���\u0007,\nAno: 2008.\nNesse exemplo, o registro é criado e a variável é declarada de uma única vez. Um nome para o registro, dado que a variável já está criada, é irrelevante e pode ser omitido.\n\n\n23.4.2 Declarações “iguais”\nEm C, ao se encontrar a definição do registro como um tipo, o compilador adiciona esse novo struct a uma tabela interna de novos tipos. Se duas definições são idênticas, porém criadas em momentos diferentes, elas não são compatíveis.\nSegue um exemplo no qual duas variáveis são criadas sem especificação do nome do struct (Seção 23.4.1) para, em seguida, ser declarada uma terceira variável com struct idêntico no formato.\n\n/*\n * Exemplo de struct sem nome\n * Assegura: apresentação dos valores iniciados\n */\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    // registro1 e registro2 são compatíveis\n    struct {\n        int i;\n        double d;\n    } registro1, registro2;\n    registro1.i = 10;\n    registro1.d = 1.1;\n    registro2 = registro1;  // cópia completa\n\n    // registro3 possui a mesma organização, porém é incompatível\n    struct {\n        int i;\n        double d;\n    } registro3;\n    registro3 = registro1;\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:24:17: error: incompatible types when assigning to type ‘struct \n&lt;anonymous&gt;’ from type ‘struct &lt;anonymous&gt;’\n   24 |     registro3 = registro1;\n      |                 ^~~~~~~~~\nmain.c:23:7: warning: variable ‘registro3’ set but not used \n[-Wunused-but-set-variable]\n   23 |     } registro3;\n      |       ^~~~~~~~~\nmain.c:14:18: warning: variable ‘registro2’ set but not used \n[-Wunused-but-set-variable]\n   14 |     } registro1, registro2;\n      |                  ^~~~~~~~~\nO uso de struct com nome permite a declaração de novas variáveis referenciando um único tipo e, assim, mantendo a compatibilidade entre as variáveis.",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>C: Dados com `struct`</span>"
    ]
  },
  {
    "objectID": "c-dados-com-struct.html#exemplos",
    "href": "c-dados-com-struct.html#exemplos",
    "title": "23  C: Dados com struct",
    "section": "23.5 Exemplos",
    "text": "23.5 Exemplos\nMais alguns exemplos com registros são apresentados.\n\n23.5.1 Apresentação de um registro em uma função\nO programa seguinte mostra mais um exemplo de passagem de um registro como parâmetro por valor.\n/*\n * Apresentação de dados de um vetor 2D com rótulo\n * Assegura: apresentação dos campos do registro\n */\n#include &lt;stdio.h&gt;\n\n/*! @struct vetor 2D */\nstruct vetor {\n    char rotulo;\n    double x, y;\n};\n\n/*!\n * Escreve o conteúdo de um vetor\n * @param vetor: vetor a ser escrito\n */\nvoid escreva_vetor(struct vetor vetor);\n\n/*\n * Main\n */\nint main(void) {\n    struct vetor vetor1 = {'A', 0.0, 0.0};\n    struct vetor vetor2 = {'B', -2.2, 1.7};\n\n    escreva_vetor(vetor1);\n    escreva_vetor(vetor2);\n\n    return 0;\n}\n\n// Apresenta um vetor na tela\nvoid escreva_vetor(struct vetor vetor) {\n    printf(\"vetor %c: (%.1f, %.1f).\\n\", vetor.rotulo, vetor.x, vetor.y);\n}\nvetor A: (0.0, 0.0).\nvetor B: (-2.2, 1.7).\nÉ reforçado, aqui, que a declaração de struct vetor deve ser global, pois isso é necessário para que o registro definido possa ser usado tanto na função escreva_vetor quanto na função main.\nDessa forma, a função escreva_vetor tem como único parâmetro um struct vetor. Em main, duas variáveis (vetor1 e vetor2) são declaradas e compartilham o mesmo tipo do parâmetro. Nas chamadas à função, cada um dos registros é passado por valor, com cópia do registro de main para o parâmetro vetor de escreva_vetor.\n\n\n23.5.2 Normalização de vetores\nUm vetor \\(\\vec{v}\\) é usualmente representando por um segmento orientado, indicando sua direção e intensidade. A norma de um vetor, também chamada módulo, é representada por \\(\\lvert\\vec{v}\\rvert\\) e corresponde, graficamente, ao comprimento do segmento.\nQuando um vetor é normalizado, é mantida sua direção e sentido, alterando-se sua norma para uma unidade, ou seja \\({\\lvert\\vec{v'}\\rvert = 1}\\). O programa seguinte ilustra como vetores são normalizados. Cada vetor é organizado em um struct e são usadas funções para as diversas manipulações.\n/*\n * Apresentação de dados de um vetor 2D com rótulo\n * Assegura: apresentação dos campos do registro\n */\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\n/*! @struct vetor 2D */\nstruct vetor {\n    char rotulo;\n    double x, y;\n};\n\n/*!\n * Escreve o conteúdo de um vetor\n * @param vetor: vetor a ser escrito\n */\nvoid escreva_vetor(struct vetor vetor);\n\n/*!\n * Faz a normalização de um vetor para que tenha norma igual a 1\n * @param vetor: referência para o vetor\n */\nvoid normalize_vetor(struct vetor *vetor);\n\n/*!\n * Retorna a norma (módulo) de um vetor\n * @param vetor\n * @return norma do vetor\n */\ndouble norma_vetor(struct vetor vetor);\n\n/*\n * Main\n */\nint main(void) {\n    struct vetor vetor1 = {'A', 3.0, 4.0};\n    escreva_vetor(vetor1);\n    normalize_vetor(&vetor1);\n    escreva_vetor(vetor1);\n\n    struct vetor vetor2 = {'B', 300.0, 400.0};\n    escreva_vetor(vetor2);\n    normalize_vetor(&vetor2);\n    escreva_vetor(vetor2);\n\n    struct vetor vetor3 = {'C', -18.7, 41.1};\n    escreva_vetor(vetor3);\n    normalize_vetor(&vetor3);\n    escreva_vetor(vetor3);\n\n    return 0;\n}\n\n// Apresenta um vetor na tela\nvoid escreva_vetor(struct vetor vetor) {\n    printf(\"vetor %c: (%.1f, %.1f); norma %.2f.\\n\", vetor.rotulo, vetor.x,\n            vetor.y, norma_vetor(vetor));\n}\n\n// Normalização de um vetor\nvoid normalize_vetor(struct vetor *vetor) {\n    double norma = norma_vetor(*vetor);\n\n    vetor-&gt;x /= norma;\n    vetor-&gt;y /= norma;\n}\n\n// Calcula a norma de um vetor\ndouble norma_vetor(struct vetor vetor) {\n    return sqrt(vetor.x * vetor.x + vetor.y * vetor.y);\n}\nvetor A: (3.0, 4.0); norma 5.00.\nvetor A: (0.6, 0.8); norma 1.00.\nvetor B: (300.0, 400.0); norma 500.00.\nvetor B: (0.6, 0.8); norma 1.00.\nvetor C: (-18.7, 41.1); norma 45.15.\nvetor C: (-0.4, 0.9); norma 1.00.\nAs funções escreva_vetor e norma_vetor recebem um struct vetor por valor, com cópia do conteúdo do argumento. A normalização, por sua vez, recebe seu parâmetro por referência e altera o conteúdo do registro apontado.",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>C: Dados com `struct`</span>"
    ]
  },
  {
    "objectID": "c-dados-com-struct.html#footnotes",
    "href": "c-dados-com-struct.html#footnotes",
    "title": "23  C: Dados com struct",
    "section": "",
    "text": "Este autor reconhece que um certo número de recompilações foi necessário por erros na digitação dos parâmetros ao criar o exemplo.↩︎",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>C: Dados com `struct`</span>"
    ]
  },
  {
    "objectID": "c-dados-em-vetores.html",
    "href": "c-dados-em-vetores.html",
    "title": "24  C: Dados em vetores",
    "section": "",
    "text": "24.1 Declaração de vetores em C\nOs vetores são estruturas de dados que agrupam coleções de itens, todos com o mesmo tipo. Cada item de um vetor é individualizado por seu índice, que é um valor inteiro. Neste capítulo é abordado como vetores são criados em C e quais as peculiaridades que possuem.\nAo se criar uma coleção de itens como um arranjo (outro nome comum para vetor), é preciso especificar o tipo que cada item deve ter e a quantidade de itens.\nCada item individual pode ser especificado por seu índice, que é um valor inteiro sempre iniciado em zero. Dessa forma, se um vetor v possui \\(n\\) itens, seu primeiro item é v[0] e seu último, v[\\(n-1\\)]. Os comandos seguintes ilustram como preencher um vetor v com dados.\nQuando um vetor é criado, um bloco de memória contínuo é criado, de forma que, por exemplo, os endereços do bytes de v[i] vêm na sequência de v[i - 1].\nSe não houver uma atribuição inicial de valores junto com uma declaração local, os valores contidos no vetor devem ser considerados como não iniciados, ou seja, lixo. Se houver uma declaração global, todos os valores conterão bytes nulos, o que implica em zero para inteiros e reais, \\0 para caracteres, NULL para ponteiros, mesmo que o tipo base do vetor seja um registro.\nNo programa C seguinte, dois vetores de double são criados, um global e outro local. Nenhum deles é explicitamente iniciado com valores.\nÉ interessante observar que o compilador ajuda o programador com uma mensagem sobre a possibilidade de uso de vetor_local com valores não iniciados (o que é, propositalmente, o caso), porém nada é apresentado sobre o vetor global, visto que esse foi, necessariamente, iniciado com zeros.\nA saída produzida pelo programa, que o a quantidade de zeros em cada variável, atesta que todos os valores de vetor_global são zeros, mas o mesmo não é verdade para vetor_local.\nComo sempre, o programador nunca deve usar uma variável sem que um valor tenha sido anteriormente atribuído a ela, mesmo que essa “variável” seja uma posição qualquer em um vetor.",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>C: Dados em vetores</span>"
    ]
  },
  {
    "objectID": "c-dados-em-vetores.html#declaração-de-vetores-em-c",
    "href": "c-dados-em-vetores.html#declaração-de-vetores-em-c",
    "title": "24  C: Dados em vetores",
    "section": "",
    "text": "int v[100];  // criação de 100 valores do tipo int\n\nint v[100];\nfor(int i = 0; i &lt; 100; i++)  // de 0 a 99\n    v[i] = i;\n\n\n\n\n\n\nDica\n\n\n\nA atenção aos índices é sempre importante, tanto para se ter acesso ao item desejado quanto não ultrapassar os limites do vetor, atribuindo valores a áreas que não pertencem à variável.\nÉ sempre importante lembrar que C não faz verificações de acesso fora dos índices válidos e cabe, portanto, ao programador garantir que esse acesso não aconteça.\n\n\n\n\n\n/*\n * Programa mostrando a declaração de vetores\n * Assegura: apresentação da quantidade de valores nulos em cada vetor\n */\n#include &lt;stdio.h&gt;\n\ndouble vetor_global[1000];  // criado com todos itens iguais a zero\n\nint main(void) {\n    double vetor_local[1000];  // criado sem iniciação (i.e., contém lixo)\n\n    int contador_de_zeros_global = 0;\n    int contador_de_zeros_local = 0;\n    for (int i = 0; i &lt; 1000; i++) {\n        if (vetor_global[i] == 0)\n            contador_de_zeros_global++;\n        if (vetor_local[i] == 0)\n            contador_de_zeros_local++;\n    }\n    printf(\"No vetor global: %d de 1000 valores zero.\\n\",\n           contador_de_zeros_global);\n    printf(\"No vetor local: %d de 1000 valores zero.\\n\",\n           contador_de_zeros_local);\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:17:24: warning: ‘vetor_local’ may be used uninitialized \n[-Wmaybe-uninitialized]\n   17 |         if (vetor_local[i] == 0)\n      |             ~~~~~~~~~~~^~~\nmain.c:10:12: note: ‘vetor_local’ declared here\n   10 |     double vetor_local[1000];  // criado sem iniciação (i.e., \ncontém lixo)\n      |            ^~~~~~~~~~~\nNo vetor global: 1000 de 1000 valores zero.\nNo vetor local: 521 de 1000 valores zero.\n\n\n\n\n24.1.1 Declarações com atribuição explícita\nAssim como outras variáveis, é possível iniciar os valores de um vetor juntamente com sua declaração.\nPara vetores com itens inteiros ou reais, a iniciação é indicada por uma atribuição com os valores indicados entre chaves. Segue um exemplo simples com a iniciação de um vetor de valores reais.\n/*\n * Programa mostrando a declaração de vetor com iniciação\n * Assegura: apresentação dos valores do vetor\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double vetor[5] = {1.7, 8.2, -6.5, 0.0, 1.2};\n\n    for(int i = 0; i &lt; 5; i++)\n        printf(\"%g \", vetor[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n1.7 8.2 -6.5 0 1.2 \nTambém é possível atribuir apenas às posições iniciais do vetor, como se exemplifica.\n/*\n * Programa mostrando a declaração de vetor com iniciação\n * Assegura: apresentação dos valores do vetor\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double vetor[10] = {-8.23, 0.0, -6.5};\n\n    for(int i = 0; i &lt; 10; i++)\n        printf(\"%g \", vetor[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n-8.23 0 -6.5 0 0 0 0 0 0 0 \nNo programa, apenas são indicados valores para as três primeiras posições de vetor, sendo que para as demais nada é explicitamente especificado. Neste caso, todas as posições não especificadas terão valores nulos (ou equivalente, dependendo do tipo base do vetor).\nO programa seguinte exemplifica um vetor que tem apenas suas duas posições iniciais com valores explicitamente atribuídos. As demais, uma vez que houve a atribuição, têm seus valores zerados.\n/*\n * Programa mostrando a declaração de vetores com iniciação parcial\n * Assegura: apresentação da quantidade de zeros no vetor\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double vetor[1000] = {1.1, 2.2};  // valores para posições 0 e 1\n\n    int contador_de_zeros = 0;\n    for (int i = 0; i &lt; 1000; i++)\n        if (vetor[i] == 0)\n            contador_de_zeros++;\n    printf(\"No vetor local: %d de 1000 valores zero.\\n\", contador_de_zeros);\n\n    return 0;\n}\nNo vetor local: 998 de 1000 valores zero.\nA execução mostra que, exceto pelos pelas duas posições iniciais do vetor, todas as demais possuem valor nulo.\nEssa atribuição é interessante para casos em que se precisa de um vetor com zeros inicialmente em todas suas posições. Assim, uma declaração como a seguinte é suficiente.\nint v[500000] = {0};  // todo o vetor é iniciado com 500.000 zeros\nQuando o tipo base do vetor é char, as mesmas regras gerais valem. Se um vetor local sem iniciação explícita é criado, seu conteúdo é considerado lixo.\nchar s[300];  // 300 caracteres simples\nA iniciação do vetor pode ser realizada juntamente com a declaração da variável especificando-se os valores, posição a posição. Como nos casos de inteiros e reais, as primeiras posições recebem valores e as demais ficam com bytes nulos. No caso de cadeias de caracteres, o byte nulo é o caractere \\0.\nchar s[10] = {'H', 'e', 'l', 'l', 'o'};\nO programa seguinte comprova esse comportamento.\n/*\n * Criação de vetor de caracteres com iniciação parcial\n * Assegura: apresentação do conteúdo do vetor, posição a posição\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char s[10] = {'H', 'e', 'l', 'l', 'o'};\n\n    for (int i = 0; i &lt; 10; i++)\n        printf(\"s[%d] = '%c' \\t(código %d)\\n\", i, s[i], s[i]);\n\n    return 0;\n}\ns[0] = 'H' \t(código 72)\ns[1] = 'e' \t(código 101)\ns[2] = 'l' \t(código 108)\ns[3] = 'l' \t(código 108)\ns[4] = 'o' \t(código 111)\ns[5] = '' \t(código 0)\ns[6] = '' \t(código 0)\ns[7] = '' \t(código 0)\ns[8] = '' \t(código 0)\ns[9] = '' \t(código 0)\nAqui é importante relembrar a compatibilidade dessa iniciação com a representação de cadeias de caraceteres. Por exemplo, a função printf, usando o formato %s, escreva na tela o texto Hello, pois interpreta o \\0 de s[5] com fim da cadeia.\nHá também que se ter uma concordância dos programadores que digitar 'H', 'e', 'l', 'l', 'o' é uma tarefa, no mínimo, aborrecida. A linguagem aceita a iniciação com os valores entre aspas, usando o conceito dos valores textuais. Dessa forma, a mesma declaração com a mesma iniciação pode ser escrita usando as aspas duplas, com o mesmo resultado.\nchar s[10] = \"Hello\";\nA versão que especifica o conteúdo caractere a caractere é útil se o vetor não for usado como uma cadeia de caracteres usual, mas como um vetor de caracteres qualquer. O programa seguinte, variação do anterior, ilustra que o conteúdo do vetor é tratado como vários caracteres e não como uma string.\n/*\n * Criação de vetor de caracteres com iniciação parcial\n * Assegura: apresentação do conteúdo do vetor, posição a posição\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char s[10] = {'a', 'e', 'K', '\\0', 'G', '\\t', 'o', '\\a', '\\0', 'A'};\n\n    for (int i = 0; i &lt; 10; i++)\n        printf(\"s[%2d] = '%c' \\t(código %d)\\n\", i, s[i], s[i]);\n\n    return 0;\n}\ns[ 0] = 'a' \t(código 97)\ns[ 1] = 'e' \t(código 101)\ns[ 2] = 'K' \t(código 75)\ns[ 3] = '' \t(código 0)\ns[ 4] = 'G' \t(código 71)\ns[ 5] = '\t' \t(código 9)\ns[ 6] = 'o' \t(código 111)\ns[ 7] = '\u0007' \t(código 7)\ns[ 8] = '' \t(código 0)\ns[ 9] = 'A' \t(código 65)\n\n\n24.1.2 Declarações com tamanho automático\nA linguagem permite uma facilidade ao programador quando um vetor é criado com valores inicialmente atribuídos, que é omitir a quantidade de itens que o vetor possui. Esse tamanho é determinado pelos valores atribuídos. Segue um exemplo.\n/*\n * Programa mostrando a declaração de vetores com tamanho automático\n * Assegura: apresentação dos valores do vetor\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int vetor[] = {5, 4, 3, 2, 1};  // vetor com 5 itens\n\n    for (int i = 0; i &lt; 5; i++)\n        printf(\"%d \", vetor[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n5 4 3 2 1 \nA variável vetor é criada com exatamente cinco itens, já que há especificação de cinco valores na iniciação. A declaração feita no programa é exatamente equivalente à declaração seguinte.\nint vetor[5] = {5, 4, 3, 2, 1};\nA vantagem dessa omissão do tamanho é facilitar a escrita do código, sem que o programador tenha que contar quantos valores estão sendo usados na iniciação para colocá-lo dentro dos colchetes.\nEmbora esse recurso de escrita facilite a declaração, ele não se estende ao resto do código. Por exemplo, no programa exemplo o for usou a condição i &lt; 5, o que significa que o programador tem que saber quantos valores há efetivamente no vetor. Para esses casos, um truque de programação pode ser usado e ele é exemplificado no programa seguinte.\n/*\n * Programa mostrando a declaração de vetores com tamanho automático\n * Assegura: apresentação do tamanho de vetor em bytes, do tamanho do \n *  tipo base em bytes e a quantidade de itens no vetor\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int vetor[] = {18, -2, 0, 3, 1, 7, 22, 13, 255, 1, 0, 0, 3};\n    printf(\"O vetor de int possui %zu bytes.\\n\", sizeof vetor);\n    printf(\"Um único int possui %zu bytes.\\n\", sizeof(int));\n    printf(\"Portanto, o vetor possui %zu/%zu = %zu itens!\\n\",\n           sizeof vetor, sizeof(int), sizeof vetor / sizeof(int));\n\n    return 0;\n}\nO vetor de int possui 52 bytes.\nUm único int possui 4 bytes.\nPortanto, o vetor possui 52/4 = 13 itens!\nSabendo-se o tamanho total em bytes do vetor (sizeof vetor) e o tamanho em bytes de cada um de seus itens (sizeof (int)), é possível deduzir quantos itens há no vetor. Segue um novo programa exemplo que usa essa estratégia.\n/*\n * Apresentação das unidades monetárias da moeda brasileira\n * Assegura: apresentação de cada valor de cédula ou moeda (reais ou\n *  centavos)\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Moeda brasileira\\n\"\n           \"----------------\\n\\n\"\n           \"Notas:\\n\");\n    double valores_notas[] = {200.00, 100.00, 50.00, 20.00, 10.00, 5.00, 2.00};\n    for (int i = 0; i &lt; (int)(sizeof valores_notas / sizeof(double)); i++)\n        printf(\"R$ %6.2f\\n\", valores_notas[i]);\n\n    printf(\"\\nMoedas:\\n\");\n    double valores_moedas[] = {1.00, 0.50, 0.25, 0.10, 0.05, 0.01};\n    for (int i = 0; i &lt; (int)(sizeof valores_moedas / sizeof(double)); i++)\n        printf(\"R$ %.2f\\n\", valores_moedas[i]);\n\n    return 0;\n}\nMoeda brasileira\n----------------\n\nNotas:\nR$ 200.00\nR$ 100.00\nR$  50.00\nR$  20.00\nR$  10.00\nR$   5.00\nR$   2.00\n\nMoedas:\nR$ 1.00\nR$ 0.50\nR$ 0.25\nR$ 0.10\nR$ 0.05\nR$ 0.01\n\n\n24.1.3 Vetores com tamanho sob demanda\nO número de itens de um vetor pode ser especificado de duas formas básicas: com a especificação explícita do tamanho nos colchetes ou fazendo a iniciação com o número desejado de itens. Uma possibilidade adicional, relativa ao primeiro formato, é o uso de uma expressão para indicar a quantidade.\nint n = 10;\ndouble v1[n];  // vetor com 10 itens\ndouble v2[2 * n];  // vetor com 20 itens\nNa prática, a quantidade de itens usada para dimensionar o vetor pode depender de um cálculo ou uma informação em tempo de execução.\nO programa seguinte mostra vetores criados com tamanhos aleatórios, usando a função rand de stdlib.h.\n/*\n * Criação de vetores com diferentes quantidades de itens\n * Assegura: apresentação do número de itens de cada vetor\n */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    for (int exemplo = 1; exemplo &lt;= 10; exemplo++) {\n        // rand() % 20 + 1 resulta em um valor aleatório de 1 até 20\n        double vetor[rand() % 20 + 1];\n        printf(\"Exemplo %d: vetor criado com %zu itens.\\n\", exemplo,\n               sizeof vetor/sizeof (double));\n    }\n\n    return 0;\n}\nExemplo 1: vetor criado com 4 itens.\nExemplo 2: vetor criado com 7 itens.\nExemplo 3: vetor criado com 18 itens.\nExemplo 4: vetor criado com 16 itens.\nExemplo 5: vetor criado com 14 itens.\nExemplo 6: vetor criado com 16 itens.\nExemplo 7: vetor criado com 7 itens.\nExemplo 8: vetor criado com 13 itens.\nExemplo 9: vetor criado com 10 itens.\nExemplo 10: vetor criado com 2 itens.\nA cada repetição do for é criado um vetor com um tamanho aleatório, podendo ter de 1 a 20 itens. A quantidade de itens é apresentada verificando o tamanho real do vetor.\nO uso desse recurso é interessante, por exemplo, quando o usuário fornece a quantidade de itens inicialmente, seguida dos valores de cada dado. O vetor pode ser criado exatamente do tamanho para armazenar os dados esperados.",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>C: Dados em vetores</span>"
    ]
  },
  {
    "objectID": "c-dados-em-vetores.html#vetores-de-struct",
    "href": "c-dados-em-vetores.html#vetores-de-struct",
    "title": "24  C: Dados em vetores",
    "section": "24.2 Vetores de struct",
    "text": "24.2 Vetores de struct\nO tipo base de um vetore pode ser um registro (struct), de modo que uma coleção de registros pode ser facilmente organizada.\nComo exemplo, pode-se considerar um registro contendo as três coordenadas de um ponto em \\(\\mathbb{R}^3\\).\nstruct ponto3d {\n    double x, y, z;\n};\n\nstruct ponto3d lista_pontos[200];  // 200 registros\nCada elemento do vetor lista_pontos é um registro. Assim, lista_pontos[0] é o primeiro registro do vetor, o que leva a lista_pontos[0].x, lista_pontos[0].y e lista_pontos[0].z serem a especificação de cada um dos seus campos.",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>C: Dados em vetores</span>"
    ]
  },
  {
    "objectID": "c-dados-em-vetores.html#ponteiros-para-vetores",
    "href": "c-dados-em-vetores.html#ponteiros-para-vetores",
    "title": "24  C: Dados em vetores",
    "section": "24.3 Ponteiros para vetores",
    "text": "24.3 Ponteiros para vetores\nEm C, quando o identificador de um vetor é usado, o compilador associa a ele o endereço dessa variável na memória.\nint i; \nint vet[10];\n\n// &i é o endereço de i\n// vet é o endereço de vet",
    "crumbs": [
      "Estruturação de dados",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>C: Dados em vetores</span>"
    ]
  }
]